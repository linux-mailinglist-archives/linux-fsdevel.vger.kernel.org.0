Return-Path: <linux-fsdevel+bounces-19618-lists+linux-fsdevel=lfdr.de@vger.kernel.org>
X-Original-To: lists+linux-fsdevel@lfdr.de
Delivered-To: lists+linux-fsdevel@lfdr.de
Received: from ny.mirrors.kernel.org (ny.mirrors.kernel.org [147.75.199.223])
	by mail.lfdr.de (Postfix) with ESMTPS id 1A0B18C7CF1
	for <lists+linux-fsdevel@lfdr.de>; Thu, 16 May 2024 21:10:50 +0200 (CEST)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by ny.mirrors.kernel.org (Postfix) with ESMTPS id EBD0D1C2354D
	for <lists+linux-fsdevel@lfdr.de>; Thu, 16 May 2024 19:10:48 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 95236158A20;
	Thu, 16 May 2024 19:05:47 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=cisco.com header.i=@cisco.com header.b="NofPZdgK"
X-Original-To: linux-fsdevel@vger.kernel.org
Received: from aer-iport-1.cisco.com (aer-iport-1.cisco.com [173.38.203.51])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id AB5181581EE;
	Thu, 16 May 2024 19:05:11 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=173.38.203.51
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1715886346; cv=none; b=rImxqpr/bwl/L3PhL0MPHqFXKxPuJQPtgReWfUybqh89FlYrX4QzZswmf0PEYOMkMWavTIUEwGagzi+oQT3c06JHIyEZGPR/fN4bkA8BLMCqZjOZGdwPPW5GPIKWNelqfD0rHR3IOG1R1wFoSAausA6yAkVvxnrRoZHxPAPArds=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1715886346; c=relaxed/simple;
	bh=l1Ck2k+Ek+FoDiX7MdCY/O7IhZYyvBSXJ8HUMoyE/nE=;
	h=From:To:Cc:Subject:Date:Message-Id:In-Reply-To:References:
	 MIME-Version; b=F5SnjEwicr1KVEJ2l/vLflt4ndMzHX8pLwTk8dBkTdOi3wa/BXylciFmPY8CQyCjQj/s1J7SZ076MjPZDSw50mYidzZgXiK413XNGFNcZBsGhD2X0UUi8RFewg0hgNAD+P6cae8Y/i24vZIeYAMH8ZcToPAdJKJizqaC388ApUo=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=cisco.com; spf=pass smtp.mailfrom=cisco.com; dkim=pass (1024-bit key) header.d=cisco.com header.i=@cisco.com header.b=NofPZdgK; arc=none smtp.client-ip=173.38.203.51
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=reject dis=none) header.from=cisco.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=cisco.com
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
  d=cisco.com; i=@cisco.com; l=932915; q=dns/txt;
  s=iport; t=1715886312; x=1717095912;
  h=from:to:cc:subject:date:message-id:in-reply-to:
   references:mime-version:content-transfer-encoding;
  bh=M1n6BYrSPprOVkR5cxW6LU9CD1Y5iOXyBM2uYJT5uYE=;
  b=NofPZdgKPQl7FkuVwkgATfOCct7GE9evK/AXyLnov3QXdMl2PiXHiVkr
   YZ4I+bWwd24bT5rk2sml/zkDnb+i/uVSPclO/n5P7Y6/gAyQeM5FhcE5f
   kXKcXRbxIkXb37OA3cdjGfrXYpkMBrRp6txzPXR94rwnUqeaQFoSFd9dR
   E=;
X-CSE-ConnectionGUID: ytwXVbTeQUyD5ujJag2ufA==
X-CSE-MsgGUID: O6J2vq9FR1eTdyekl/GzGA==
X-IronPort-AV: E=Sophos;i="6.08,165,1712620800"; 
   d="scan'208";a="12419633"
Received: from aer-iport-nat.cisco.com (HELO aer-core-3.cisco.com) ([173.38.203.22])
  by aer-iport-1.cisco.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 16 May 2024 19:04:09 +0000
Received: from localhost (ams3-vpn-dhcp4879.cisco.com [10.61.83.14])
	(authenticated bits=0)
	by aer-core-3.cisco.com (8.15.2/8.15.2) with ESMTPSA id 44GJ44as017876
	(version=TLSv1.2 cipher=DHE-RSA-AES256-GCM-SHA384 bits=256 verify=NO);
	Thu, 16 May 2024 19:04:04 GMT
From: Ariel Miculas <amiculas@cisco.com>
To: rust-for-linux@vger.kernel.org
Cc: linux-kernel@vger.kernel.org, linux-fsdevel@vger.kernel.org,
        tycho@tycho.pizza, brauner@kernel.org, viro@zeniv.linux.org.uk,
        ojeda@kernel.org, alex.gaynor@gmail.com, wedsonaf@gmail.com,
        shallyn@cisco.com, Ariel Miculas <amiculas@cisco.com>
Subject: [RFC PATCH v3 06/22] rust: capnp: import crate
Date: Thu, 16 May 2024 22:03:29 +0300
Message-Id: <20240516190345.957477-7-amiculas@cisco.com>
X-Mailer: git-send-email 2.34.1
In-Reply-To: <20240516190345.957477-1-amiculas@cisco.com>
References: <20240516190345.957477-1-amiculas@cisco.com>
Precedence: bulk
X-Mailing-List: linux-fsdevel@vger.kernel.org
List-Id: <linux-fsdevel.vger.kernel.org>
List-Subscribe: <mailto:linux-fsdevel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-fsdevel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-Authenticated-User: amiculas@cisco.com
X-Outbound-SMTP-Client: 10.61.83.14, ams3-vpn-dhcp4879.cisco.com
X-Outbound-Node: aer-core-3.cisco.com

This is a subset of the Rust `capnp` crate,
version capnpc-v0.18.0, licensed under "MIT", from:

    https://github.com/capnproto/capnproto-rust/tree/capnpc-v0.18.0/capnp/src

The files are copied as-is, with no modifications whatsoever
(not even adding the SPDX identifiers).

For copyright details, please see:

    https://github.com/capnproto/capnproto-rust/blob/capnpc-v0.18.0/LICENSE

The next patches modify these files as needed for use within the kernel.
This patch split allows reviewers to double-check the import and to
clearly see the differences introduced.

The following script may be used to verify the contents:

    for path in $(cd rust/capnp/ && find . -type f -name '*.rs'); do
        curl --silent --show-error --location \
            https://github.com/capnproto/capnproto-rust/raw/capnpc-v0.18.0/capnp/src/$path \
            | diff --unified rust/capnp/$path - && echo $path: OK
    done

Signed-off-by: Ariel Miculas <amiculas@cisco.com>
---
 rust/capnp/any_pointer.rs                     |   313 +
 rust/capnp/any_pointer_list.rs                |   208 +
 rust/capnp/capability.rs                      |   363 +
 rust/capnp/capability_list.rs                 |   297 +
 rust/capnp/constant.rs                        |    54 +
 rust/capnp/data.rs                            |    95 +
 rust/capnp/data_list.rs                       |   218 +
 rust/capnp/dynamic_list.rs                    |   408 +
 rust/capnp/dynamic_struct.rs                  |   782 +
 rust/capnp/dynamic_value.rs                   |   317 +
 rust/capnp/enum_list.rs                       |   237 +
 rust/capnp/introspect.rs                      |   282 +
 rust/capnp/io.rs                              |   202 +
 rust/capnp/lib.rs                             |   651 +
 rust/capnp/list_list.rs                       |   296 +
 rust/capnp/message.rs                         |   878 +
 rust/capnp/primitive_list.rs                  |   279 +
 rust/capnp/private/arena.rs                   |   417 +
 rust/capnp/private/capability.rs              |   155 +
 rust/capnp/private/layout.rs                  |  4210 +++++
 rust/capnp/private/layout_test.rs             |   192 +
 rust/capnp/private/mask.rs                    |    62 +
 rust/capnp/private/mod.rs                     |    36 +
 rust/capnp/private/primitive.rs               |   119 +
 rust/capnp/private/read_limiter.rs            |   113 +
 rust/capnp/private/units.rs                   |    68 +
 rust/capnp/private/zero.rs                    |    46 +
 rust/capnp/raw.rs                             |    69 +
 rust/capnp/schema.rs                          |   430 +
 rust/capnp/schema_capnp.rs                    | 14448 ++++++++++++++++
 rust/capnp/serialize.rs                       |   961 +
 .../serialize/no_alloc_buffer_segments.rs     |   627 +
 rust/capnp/serialize_packed.rs                |   618 +
 rust/capnp/stringify.rs                       |   181 +
 rust/capnp/struct_list.rs                     |   300 +
 rust/capnp/text.rs                            |   294 +
 rust/capnp/text_list.rs                       |   216 +
 rust/capnp/traits.rs                          |   233 +
 38 files changed, 29675 insertions(+)
 create mode 100644 rust/capnp/any_pointer.rs
 create mode 100644 rust/capnp/any_pointer_list.rs
 create mode 100644 rust/capnp/capability.rs
 create mode 100644 rust/capnp/capability_list.rs
 create mode 100644 rust/capnp/constant.rs
 create mode 100644 rust/capnp/data.rs
 create mode 100644 rust/capnp/data_list.rs
 create mode 100644 rust/capnp/dynamic_list.rs
 create mode 100644 rust/capnp/dynamic_struct.rs
 create mode 100644 rust/capnp/dynamic_value.rs
 create mode 100644 rust/capnp/enum_list.rs
 create mode 100644 rust/capnp/introspect.rs
 create mode 100644 rust/capnp/io.rs
 create mode 100644 rust/capnp/lib.rs
 create mode 100644 rust/capnp/list_list.rs
 create mode 100644 rust/capnp/message.rs
 create mode 100644 rust/capnp/primitive_list.rs
 create mode 100644 rust/capnp/private/arena.rs
 create mode 100644 rust/capnp/private/capability.rs
 create mode 100644 rust/capnp/private/layout.rs
 create mode 100644 rust/capnp/private/layout_test.rs
 create mode 100644 rust/capnp/private/mask.rs
 create mode 100644 rust/capnp/private/mod.rs
 create mode 100644 rust/capnp/private/primitive.rs
 create mode 100644 rust/capnp/private/read_limiter.rs
 create mode 100644 rust/capnp/private/units.rs
 create mode 100644 rust/capnp/private/zero.rs
 create mode 100644 rust/capnp/raw.rs
 create mode 100644 rust/capnp/schema.rs
 create mode 100644 rust/capnp/schema_capnp.rs
 create mode 100644 rust/capnp/serialize.rs
 create mode 100644 rust/capnp/serialize/no_alloc_buffer_segments.rs
 create mode 100644 rust/capnp/serialize_packed.rs
 create mode 100644 rust/capnp/stringify.rs
 create mode 100644 rust/capnp/struct_list.rs
 create mode 100644 rust/capnp/text.rs
 create mode 100644 rust/capnp/text_list.rs
 create mode 100644 rust/capnp/traits.rs

diff --git a/rust/capnp/any_pointer.rs b/rust/capnp/any_pointer.rs
new file mode 100644
index 000000000000..c49216cd031e
--- /dev/null
+++ b/rust/capnp/any_pointer.rs
@@ -0,0 +1,313 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Untyped pointer that can be cast to any struct, list, or capability type.
+
+#[cfg(feature = "alloc")]
+use alloc::{boxed::Box, vec::Vec};
+
+#[cfg(feature = "alloc")]
+use crate::capability::FromClientHook;
+#[cfg(feature = "alloc")]
+use crate::private::capability::{ClientHook, PipelineHook, PipelineOp};
+use crate::private::layout::{PointerBuilder, PointerReader};
+use crate::traits::{FromPointerBuilder, FromPointerReader, SetPointerBuilder};
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned(());
+
+impl crate::traits::Owned for Owned {
+    type Reader<'a> = Reader<'a>;
+    type Builder<'a> = Builder<'a>;
+}
+
+impl crate::introspect::Introspect for Owned {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::TypeVariant::AnyPointer.into()
+    }
+}
+
+impl crate::traits::Pipelined for Owned {
+    type Pipeline = Pipeline;
+}
+
+#[derive(Copy, Clone)]
+pub struct Reader<'a> {
+    pub(crate) reader: PointerReader<'a>,
+}
+
+impl<'a> Reader<'a> {
+    pub fn new(reader: PointerReader<'_>) -> Reader<'_> {
+        Reader { reader }
+    }
+
+    #[inline]
+    pub fn is_null(&self) -> bool {
+        self.reader.is_null()
+    }
+
+    /// Gets the total size of the target and all of its children. Does not count far pointer overhead.
+    pub fn target_size(&self) -> Result<crate::MessageSize> {
+        self.reader.total_size()
+    }
+
+    #[inline]
+    pub fn get_as<T: FromPointerReader<'a>>(&self) -> Result<T> {
+        FromPointerReader::get_from_pointer(&self.reader, None)
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn get_as_capability<T: FromClientHook>(&self) -> Result<T> {
+        Ok(FromClientHook::new(self.reader.get_capability()?))
+    }
+
+    //# Used by RPC system to implement pipelining. Applications
+    //# generally shouldn't use this directly.
+    #[cfg(feature = "alloc")]
+    pub fn get_pipelined_cap(&self, ops: &[PipelineOp]) -> Result<Box<dyn ClientHook>> {
+        let mut pointer = self.reader;
+
+        for op in ops {
+            match *op {
+                PipelineOp::Noop => {}
+                PipelineOp::GetPointerField(idx) => {
+                    pointer = pointer.get_struct(None)?.get_pointer_field(idx as usize);
+                }
+            }
+        }
+
+        pointer.get_capability()
+    }
+}
+
+impl<'a> FromPointerReader<'a> for Reader<'a> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a>> {
+        if default.is_some() {
+            panic!("Unsupported: any_pointer with a default value.");
+        }
+        Ok(Reader { reader: *reader })
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.copy_from(value.reader, canonicalize)
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+    fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+        self.reader
+            .imbue(crate::private::layout::CapTableReader::Plain(cap_table));
+    }
+}
+
+pub struct Builder<'a> {
+    builder: PointerBuilder<'a>,
+}
+
+impl<'a> Builder<'a> {
+    pub fn new(builder: PointerBuilder<'a>) -> Builder<'a> {
+        Builder { builder }
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        Builder {
+            builder: self.builder.reborrow(),
+        }
+    }
+
+    pub fn is_null(&self) -> bool {
+        self.builder.is_null()
+    }
+
+    /// Gets the total size of the target and all of its children. Does not count far pointer overhead.
+    pub fn target_size(&self) -> Result<crate::MessageSize> {
+        self.builder.as_reader().total_size()
+    }
+
+    pub fn get_as<T: FromPointerBuilder<'a>>(self) -> Result<T> {
+        FromPointerBuilder::get_from_pointer(self.builder, None)
+    }
+
+    pub fn init_as<T: FromPointerBuilder<'a>>(self) -> T {
+        FromPointerBuilder::init_pointer(self.builder, 0)
+    }
+
+    pub fn initn_as<T: FromPointerBuilder<'a>>(self, size: u32) -> T {
+        FromPointerBuilder::init_pointer(self.builder, size)
+    }
+
+    pub fn set_as<From: SetPointerBuilder>(&mut self, value: From) -> Result<()> {
+        SetPointerBuilder::set_pointer_builder(self.builder.reborrow(), value, false)
+    }
+
+    // XXX value should be a user client.
+    #[cfg(feature = "alloc")]
+    pub fn set_as_capability(&mut self, value: Box<dyn ClientHook>) {
+        self.builder.set_capability(value);
+    }
+
+    #[inline]
+    pub fn clear(&mut self) {
+        self.builder.clear()
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader {
+            reader: self.builder.into_reader(),
+        }
+    }
+}
+
+impl<'a> FromPointerBuilder<'a> for Builder<'a> {
+    fn init_pointer(mut builder: PointerBuilder<'a>, _len: u32) -> Builder<'a> {
+        if !builder.is_null() {
+            builder.clear();
+        }
+        Builder { builder }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a>> {
+        if default.is_some() {
+            panic!("AnyPointer defaults are unsupported")
+        }
+        Ok(Builder { builder })
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+    fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+        self.builder
+            .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table));
+    }
+}
+
+pub struct Pipeline {
+    // XXX this should not be public
+    #[cfg(feature = "alloc")]
+    pub hook: Box<dyn PipelineHook>,
+
+    #[cfg(feature = "alloc")]
+    ops: Vec<PipelineOp>,
+}
+
+impl Pipeline {
+    #[cfg(feature = "alloc")]
+    pub fn new(hook: Box<dyn PipelineHook>) -> Self {
+        Self {
+            hook,
+            ops: Vec::new(),
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn noop(&self) -> Self {
+        Self {
+            hook: self.hook.add_ref(),
+            ops: self.ops.clone(),
+        }
+    }
+
+    #[cfg(not(feature = "alloc"))]
+    pub fn noop(&self) -> Self {
+        Self {}
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn get_pointer_field(&self, pointer_index: u16) -> Self {
+        let mut new_ops = Vec::with_capacity(self.ops.len() + 1);
+        for op in &self.ops {
+            new_ops.push(*op)
+        }
+        new_ops.push(PipelineOp::GetPointerField(pointer_index));
+        Self {
+            hook: self.hook.add_ref(),
+            ops: new_ops,
+        }
+    }
+
+    #[cfg(not(feature = "alloc"))]
+    pub fn get_pointer_field(&self, _pointer_index: u16) -> Self {
+        Self {}
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn as_cap(&self) -> Box<dyn ClientHook> {
+        self.hook.get_pipelined_cap(&self.ops)
+    }
+}
+
+impl crate::capability::FromTypelessPipeline for Pipeline {
+    fn new(typeless: Pipeline) -> Self {
+        typeless
+    }
+}
+
+impl<'a> From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+    fn from(a: Reader<'a>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::AnyPointer(a)
+    }
+}
+
+impl<'a> From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+    fn from(a: Builder<'a>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::AnyPointer(a)
+    }
+}
+
+#[cfg(feature = "alloc")]
+#[test]
+fn init_clears_value() {
+    let mut message = crate::message::Builder::new_default();
+    {
+        let root: crate::any_pointer::Builder = message.init_root();
+        let mut list: crate::primitive_list::Builder<u16> = root.initn_as(10);
+        for idx in 0..10 {
+            list.set(idx, idx as u16);
+        }
+    }
+
+    {
+        let root: crate::any_pointer::Builder = message.init_root();
+        assert!(root.is_null());
+    }
+
+    let mut output: Vec<u8> = Vec::new();
+    crate::serialize::write_message(&mut output, &message).unwrap();
+    assert_eq!(output.len(), 40);
+    for byte in &output[8..] {
+        // Everything not in the message header is zero.
+        assert_eq!(*byte, 0u8);
+    }
+}
diff --git a/rust/capnp/any_pointer_list.rs b/rust/capnp/any_pointer_list.rs
new file mode 100644
index 000000000000..1c4e9e40c879
--- /dev/null
+++ b/rust/capnp/any_pointer_list.rs
@@ -0,0 +1,208 @@
+// Copyright (c) 2018 the capnproto-rust contributors
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of AnyPointers.
+//!
+//! Note: this cannot be used for a list of structs, since such lists are not encoded
+//! as pointer lists.
+
+use crate::private::layout::{ListBuilder, ListReader, Pointer, PointerBuilder, PointerReader};
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Clone, Copy)]
+pub struct Owned;
+
+impl crate::traits::Owned for Owned {
+    type Reader<'a> = Reader<'a>;
+    type Builder<'a> = Builder<'a>;
+}
+
+impl crate::introspect::Introspect for Owned {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::Type::list_of(crate::introspect::TypeVariant::AnyPointer.into())
+    }
+}
+
+#[derive(Clone, Copy)]
+pub struct Reader<'a> {
+    pub reader: ListReader<'a>,
+}
+
+impl<'a> Reader<'a> {
+    pub(crate) fn new(reader: ListReader<'_>) -> Reader<'_> {
+        Reader { reader }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a>, Result<crate::any_pointer::Reader<'a>>> {
+        let l = self.len();
+        ListIter::new(self, l)
+    }
+
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> crate::any_pointer::Reader<'a> {
+        assert!(index < self.len());
+        crate::any_pointer::Reader::new(self.reader.get_pointer_element(index))
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<crate::any_pointer::Reader<'a>> {
+        if index < self.len() {
+            Some(crate::any_pointer::Reader::new(
+                self.reader.get_pointer_element(index),
+            ))
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a> IndexMove<u32, Result<crate::any_pointer::Reader<'a>>> for Reader<'a> {
+    fn index_move(&self, index: u32) -> Result<crate::any_pointer::Reader<'a>> {
+        Ok(self.get(index))
+    }
+}
+
+impl<'a> FromPointerReader<'a> for Reader<'a> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a>> {
+        Ok(Reader {
+            reader: reader.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a> crate::traits::IntoInternalListReader<'a> for Reader<'a> {
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a> {
+    builder: ListBuilder<'a>,
+}
+
+impl<'a> Builder<'a> {
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader {
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> crate::any_pointer::Builder<'a> {
+        assert!(index < self.len());
+        crate::any_pointer::Builder::new(self.builder.get_pointer_element(index))
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<crate::any_pointer::Builder<'a>> {
+        if index < self.len() {
+            Some(crate::any_pointer::Builder::new(
+                self.builder.get_pointer_element(index),
+            ))
+        } else {
+            None
+        }
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        Builder {
+            builder: self.builder.reborrow(),
+        }
+    }
+}
+
+impl<'a> FromPointerBuilder<'a> for Builder<'a> {
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a> {
+        Builder {
+            builder: builder.init_list(Pointer, size),
+        }
+    }
+
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a>> {
+        Ok(Builder {
+            builder: builder.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: PointerBuilder<'b>,
+        value: Reader<'a>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)?;
+        Ok(())
+    }
+}
+
+impl<'a> core::iter::IntoIterator for Reader<'a> {
+    type Item = Result<crate::any_pointer::Reader<'a>>;
+    type IntoIter = ListIter<Reader<'a>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a> From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader::new(
+            t.reader,
+            <crate::any_pointer::Owned as crate::introspect::Introspect>::introspect(),
+        ))
+    }
+}
+
+impl<'a> From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder::new(
+            t.builder,
+            <crate::any_pointer::Owned as crate::introspect::Introspect>::introspect(),
+        ))
+    }
+}
diff --git a/rust/capnp/capability.rs b/rust/capnp/capability.rs
new file mode 100644
index 000000000000..7cff20bbbcb9
--- /dev/null
+++ b/rust/capnp/capability.rs
@@ -0,0 +1,363 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Hooks for for the RPC system.
+//!
+//! Roughly corresponds to capability.h in the C++ implementation.
+
+#[cfg(feature = "alloc")]
+use alloc::boxed::Box;
+#[cfg(feature = "alloc")]
+use core::future::Future;
+#[cfg(feature = "alloc")]
+use core::marker::{PhantomData, Unpin};
+#[cfg(feature = "rpc_try")]
+use core::ops::Try;
+#[cfg(feature = "alloc")]
+use core::pin::Pin;
+#[cfg(feature = "alloc")]
+use core::task::Poll;
+
+use crate::any_pointer;
+#[cfg(feature = "alloc")]
+use crate::private::capability::{ClientHook, ParamsHook, RequestHook, ResponseHook, ResultsHook};
+#[cfg(feature = "alloc")]
+use crate::traits::{Owned, Pipelined};
+#[cfg(feature = "alloc")]
+use crate::{Error, MessageSize};
+
+/// A computation that might eventually resolve to a value of type `T` or to an error
+///  of type `E`. Dropping the promise cancels the computation.
+#[cfg(feature = "alloc")]
+#[must_use = "futures do nothing unless polled"]
+pub struct Promise<T, E> {
+    inner: PromiseInner<T, E>,
+}
+
+#[cfg(feature = "alloc")]
+enum PromiseInner<T, E> {
+    Immediate(Result<T, E>),
+    Deferred(Pin<Box<dyn Future<Output = core::result::Result<T, E>> + 'static>>),
+    Empty,
+}
+
+// Allow Promise<T,E> to be Unpin, regardless of whether T and E are.
+#[cfg(feature = "alloc")]
+impl<T, E> Unpin for PromiseInner<T, E> {}
+
+#[cfg(feature = "alloc")]
+impl<T, E> Promise<T, E> {
+    pub fn ok(value: T) -> Self {
+        Self {
+            inner: PromiseInner::Immediate(Ok(value)),
+        }
+    }
+
+    pub fn err(error: E) -> Self {
+        Self {
+            inner: PromiseInner::Immediate(Err(error)),
+        }
+    }
+
+    pub fn from_future<F>(f: F) -> Self
+    where
+        F: Future<Output = core::result::Result<T, E>> + 'static,
+    {
+        Self {
+            inner: PromiseInner::Deferred(Box::pin(f)),
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<T, E> Future for Promise<T, E> {
+    type Output = core::result::Result<T, E>;
+
+    fn poll(self: Pin<&mut Self>, cx: &mut ::core::task::Context) -> Poll<Self::Output> {
+        match self.get_mut().inner {
+            PromiseInner::Empty => panic!("Promise polled after done."),
+            ref mut imm @ PromiseInner::Immediate(_) => {
+                match core::mem::replace(imm, PromiseInner::Empty) {
+                    PromiseInner::Immediate(r) => Poll::Ready(r),
+                    _ => unreachable!(),
+                }
+            }
+            PromiseInner::Deferred(ref mut f) => f.as_mut().poll(cx),
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+#[cfg(feature = "rpc_try")]
+impl<T> core::ops::Try for Promise<T, crate::Error> {
+    type Output = Self;
+    type Residual = Result<core::convert::Infallible, crate::Error>;
+
+    fn from_output(output: Self::Output) -> Self {
+        output
+    }
+
+    fn branch(self) -> core::ops::ControlFlow<Self::Residual, Self::Output> {
+        unimplemented!();
+    }
+}
+
+#[cfg(feature = "alloc")]
+#[cfg(feature = "rpc_try")]
+impl<T> core::ops::FromResidual for Promise<T, crate::Error> {
+    fn from_residual(residual: <Self as Try>::Residual) -> Self {
+        match residual {
+            Ok(_) => unimplemented!(),
+            Err(e) => Self::err(e),
+        }
+    }
+}
+
+/// A promise for a result from a method call.
+#[cfg(feature = "alloc")]
+#[must_use]
+pub struct RemotePromise<Results>
+where
+    Results: Pipelined + Owned + 'static,
+{
+    pub promise: Promise<Response<Results>, crate::Error>,
+    pub pipeline: Results::Pipeline,
+}
+
+/// A response from a method call, as seen by the client.
+#[cfg(feature = "alloc")]
+pub struct Response<Results> {
+    pub marker: PhantomData<Results>,
+    pub hook: Box<dyn ResponseHook>,
+}
+
+#[cfg(feature = "alloc")]
+impl<Results> Response<Results>
+where
+    Results: Pipelined + Owned,
+{
+    pub fn new(hook: Box<dyn ResponseHook>) -> Self {
+        Self {
+            marker: PhantomData,
+            hook,
+        }
+    }
+    pub fn get(&self) -> crate::Result<Results::Reader<'_>> {
+        self.hook.get()?.get_as()
+    }
+}
+
+/// A method call that has not been sent yet.
+#[cfg(feature = "alloc")]
+pub struct Request<Params, Results> {
+    pub marker: PhantomData<(Params, Results)>,
+    pub hook: Box<dyn RequestHook>,
+}
+
+#[cfg(feature = "alloc")]
+impl<Params, Results> Request<Params, Results>
+where
+    Params: Owned,
+{
+    pub fn new(hook: Box<dyn RequestHook>) -> Self {
+        Self {
+            hook,
+            marker: PhantomData,
+        }
+    }
+
+    pub fn get(&mut self) -> Params::Builder<'_> {
+        self.hook.get().get_as().unwrap()
+    }
+
+    pub fn set(&mut self, from: Params::Reader<'_>) -> crate::Result<()> {
+        self.hook.get().set_as(from)
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<Params, Results> Request<Params, Results>
+where
+    Results: Pipelined + Owned + 'static + Unpin,
+    <Results as Pipelined>::Pipeline: FromTypelessPipeline,
+{
+    pub fn send(self) -> RemotePromise<Results> {
+        let RemotePromise {
+            promise, pipeline, ..
+        } = self.hook.send();
+        let typed_promise = Promise::from_future(async move {
+            Ok(Response {
+                hook: promise.await?.hook,
+                marker: PhantomData,
+            })
+        });
+        RemotePromise {
+            promise: typed_promise,
+            pipeline: FromTypelessPipeline::new(pipeline),
+        }
+    }
+}
+
+/// The values of the parameters passed to a method call, as seen by the server.
+#[cfg(feature = "alloc")]
+pub struct Params<T> {
+    pub marker: PhantomData<T>,
+    pub hook: Box<dyn ParamsHook>,
+}
+
+#[cfg(feature = "alloc")]
+impl<T> Params<T> {
+    pub fn new(hook: Box<dyn ParamsHook>) -> Self {
+        Self {
+            marker: PhantomData,
+            hook,
+        }
+    }
+    pub fn get(&self) -> crate::Result<T::Reader<'_>>
+    where
+        T: Owned,
+    {
+        self.hook.get()?.get_as()
+    }
+}
+
+/// The return values of a method, written in-place by the method body.
+#[cfg(feature = "alloc")]
+pub struct Results<T> {
+    pub marker: PhantomData<T>,
+    pub hook: Box<dyn ResultsHook>,
+}
+
+#[cfg(feature = "alloc")]
+impl<T> Results<T>
+where
+    T: Owned,
+{
+    pub fn new(hook: Box<dyn ResultsHook>) -> Self {
+        Self {
+            marker: PhantomData,
+            hook,
+        }
+    }
+
+    pub fn get(&mut self) -> T::Builder<'_> {
+        self.hook.get().unwrap().get_as().unwrap()
+    }
+
+    pub fn set(&mut self, other: T::Reader<'_>) -> crate::Result<()> {
+        self.hook.get().unwrap().set_as(other)
+    }
+}
+
+pub trait FromTypelessPipeline {
+    fn new(typeless: any_pointer::Pipeline) -> Self;
+}
+
+/// Trait implemented (via codegen) by all user-defined capability client types.
+#[cfg(feature = "alloc")]
+pub trait FromClientHook {
+    /// Wraps a client hook to create a new client.
+    fn new(hook: Box<dyn ClientHook>) -> Self;
+
+    /// Unwraps client to get the underlying client hook.
+    fn into_client_hook(self) -> Box<dyn ClientHook>;
+
+    /// Gets a reference to the underlying client hook.
+    fn as_client_hook(&self) -> &dyn ClientHook;
+
+    /// Casts `self` to another instance of `FromClientHook`. This always succeeds,
+    /// but if the underlying capability does not actually implement `T`'s interface,
+    /// then method calls will fail with "unimplemented" errors.
+    fn cast_to<T: FromClientHook + Sized>(self) -> T
+    where
+        Self: Sized,
+    {
+        FromClientHook::new(self.into_client_hook())
+    }
+}
+
+/// An untyped client.
+#[cfg(feature = "alloc")]
+pub struct Client {
+    pub hook: Box<dyn ClientHook>,
+}
+
+#[cfg(feature = "alloc")]
+impl Client {
+    pub fn new(hook: Box<dyn ClientHook>) -> Self {
+        Self { hook }
+    }
+
+    pub fn new_call<Params, Results>(
+        &self,
+        interface_id: u64,
+        method_id: u16,
+        size_hint: Option<MessageSize>,
+    ) -> Request<Params, Results> {
+        let typeless = self.hook.new_call(interface_id, method_id, size_hint);
+        Request {
+            hook: typeless.hook,
+            marker: PhantomData,
+        }
+    }
+
+    /// If the capability is actually only a promise, the returned promise resolves once the
+    /// capability itself has resolved to its final destination (or propagates the exception if
+    /// the capability promise is rejected).  This is mainly useful for error-checking in the case
+    /// where no calls are being made.  There is no reason to wait for this before making calls; if
+    /// the capability does not resolve, the call results will propagate the error.
+    pub fn when_resolved(&self) -> Promise<(), Error> {
+        self.hook.when_resolved()
+    }
+}
+
+/// An untyped server.
+#[cfg(feature = "alloc")]
+pub trait Server {
+    fn dispatch_call(
+        &mut self,
+        interface_id: u64,
+        method_id: u16,
+        params: Params<any_pointer::Owned>,
+        results: Results<any_pointer::Owned>,
+    ) -> Promise<(), Error>;
+}
+
+/// Trait to track the relationship between generated Server traits and Client structs.
+#[cfg(feature = "alloc")]
+pub trait FromServer<S>: FromClientHook {
+    // Implemented by the generated ServerDispatch struct.
+    type Dispatch: Server + 'static + core::ops::DerefMut<Target = S>;
+
+    fn from_server(s: S) -> Self::Dispatch;
+}
+
+/// Gets the "resolved" version of a capability. One place this is useful is for pre-resolving
+/// the argument to `capnp_rpc::CapabilityServerSet::get_local_server_of_resolved()`.
+#[cfg(feature = "alloc")]
+pub async fn get_resolved_cap<C: FromClientHook>(cap: C) -> C {
+    let mut hook = cap.into_client_hook();
+    let _ = hook.when_resolved().await;
+    while let Some(resolved) = hook.get_resolved() {
+        hook = resolved;
+    }
+    FromClientHook::new(hook)
+}
diff --git a/rust/capnp/capability_list.rs b/rust/capnp/capability_list.rs
new file mode 100644
index 000000000000..083794e073d1
--- /dev/null
+++ b/rust/capnp/capability_list.rs
@@ -0,0 +1,297 @@
+// Copyright (c) 2017 David Renshaw and contributors
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of capabilities.
+#![cfg(feature = "alloc")]
+
+use alloc::boxed::Box;
+use core::marker::PhantomData;
+
+use crate::capability::FromClientHook;
+use crate::private::capability::ClientHook;
+use crate::private::layout::{ListBuilder, ListReader, Pointer, PointerBuilder, PointerReader};
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned<T>
+where
+    T: FromClientHook,
+{
+    marker: PhantomData<T>,
+}
+
+impl<T> crate::introspect::Introspect for Owned<T>
+where
+    T: FromClientHook,
+{
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::Type::list_of(crate::introspect::TypeVariant::Capability.into())
+    }
+}
+
+impl<T> crate::traits::Owned for Owned<T>
+where
+    T: FromClientHook,
+{
+    type Reader<'a> = Reader<'a, T>;
+    type Builder<'a> = Builder<'a, T>;
+}
+
+pub struct Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    marker: PhantomData<T>,
+    reader: ListReader<'a>,
+}
+
+impl<'a, T> Clone for Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    fn clone(&self) -> Reader<'a, T> {
+        *self
+    }
+}
+impl<'a, T> Copy for Reader<'a, T> where T: FromClientHook {}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a, T>, Result<T>> {
+        ListIter::new(self, self.len())
+    }
+}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    pub fn reborrow(&self) -> Reader<'_, T> {
+        Reader {
+            reader: self.reader,
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<'a, T> FromPointerReader<'a> for Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a, T>> {
+        Ok(Reader {
+            reader: reader.get_list(Pointer, default)?,
+            marker: PhantomData,
+        })
+    }
+}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> Result<T> {
+        assert!(index < self.len());
+        Ok(FromClientHook::new(
+            self.reader.get_pointer_element(index).get_capability()?,
+        ))
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<T>> {
+        if index < self.len() {
+            Some(
+                self.reader
+                    .get_pointer_element(index)
+                    .get_capability()
+                    .map(FromClientHook::new),
+            )
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> IndexMove<u32, Result<T>> for Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    fn index_move(&self, index: u32) -> Result<T> {
+        self.get(index)
+    }
+}
+
+pub struct Builder<'a, T>
+where
+    T: FromClientHook,
+{
+    marker: PhantomData<T>,
+    builder: ListBuilder<'a>,
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: FromClientHook,
+{
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a, T> {
+        Reader {
+            marker: PhantomData,
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    pub fn set(&mut self, index: u32, value: Box<dyn ClientHook>) {
+        assert!(index < self.len());
+        self.builder
+            .reborrow()
+            .get_pointer_element(index)
+            .set_capability(value);
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: FromClientHook,
+{
+    pub fn reborrow(&mut self) -> Builder<'_, T> {
+        Builder {
+            builder: self.builder.reborrow(),
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<'a, T> FromPointerBuilder<'a> for Builder<'a, T>
+where
+    T: FromClientHook,
+{
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a, T> {
+        Builder {
+            marker: PhantomData,
+            builder: builder.init_list(Pointer, size),
+        }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a, T>> {
+        Ok(Builder {
+            marker: PhantomData,
+            builder: builder.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: FromClientHook,
+{
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> Result<T> {
+        assert!(index < self.len());
+        Ok(FromClientHook::new(
+            self.builder.get_pointer_element(index).get_capability()?,
+        ))
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<T>> {
+        if index < self.len() {
+            Some(
+                self.builder
+                    .get_pointer_element(index)
+                    .get_capability()
+                    .map(FromClientHook::new),
+            )
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> crate::traits::SetPointerBuilder for Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a, T>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
+
+impl<'a, T> ::core::iter::IntoIterator for Reader<'a, T>
+where
+    T: FromClientHook,
+{
+    type Item = Result<T>;
+    type IntoIter = ListIter<Reader<'a, T>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a, T: FromClientHook> From<Reader<'a, T>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a, T>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader::new(
+            t.reader,
+            crate::introspect::TypeVariant::Capability.into(),
+        ))
+    }
+}
+
+impl<'a, T: FromClientHook> From<Builder<'a, T>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a, T>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder::new(
+            t.builder,
+            crate::introspect::TypeVariant::Capability.into(),
+        ))
+    }
+}
diff --git a/rust/capnp/constant.rs b/rust/capnp/constant.rs
new file mode 100644
index 000000000000..fdd1edf487ff
--- /dev/null
+++ b/rust/capnp/constant.rs
@@ -0,0 +1,54 @@
+// Copyright (c) 2013-2017 Sandstorm Development Group, Inc. and contributors
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Helper type for generated Struct and List constants.
+//!
+//! `constant::Reader` does not do bounds-checking, so it is unsafe to
+//! manually construct one of these.
+
+use core::marker::PhantomData;
+
+use crate::any_pointer;
+use crate::private::layout::PointerReader;
+use crate::traits::Owned;
+use crate::Result;
+
+#[derive(Copy, Clone)]
+#[repr(C, align(8))]
+pub struct Reader<T> {
+    #[doc(hidden)]
+    pub phantom: PhantomData<T>,
+
+    #[doc(hidden)]
+    pub words: &'static [crate::Word],
+}
+
+impl<T> Reader<T>
+where
+    T: Owned,
+{
+    /// Retrieve the value.
+    pub fn get(&self) -> Result<<T as Owned>::Reader<'static>> {
+        any_pointer::Reader::new(unsafe {
+            PointerReader::get_root_unchecked(self.words.as_ptr() as *const u8)
+        })
+        .get_as()
+    }
+}
diff --git a/rust/capnp/data.rs b/rust/capnp/data.rs
new file mode 100644
index 000000000000..89e0c6c19ea4
--- /dev/null
+++ b/rust/capnp/data.rs
@@ -0,0 +1,95 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Sequence of bytes.
+
+use crate::private::layout::{PointerBuilder, PointerReader};
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned(());
+
+impl crate::traits::Owned for Owned {
+    type Reader<'a> = Reader<'a>;
+    type Builder<'a> = Builder<'a>;
+}
+
+impl crate::introspect::Introspect for Owned {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::TypeVariant::Data.into()
+    }
+}
+
+pub type Reader<'a> = &'a [u8];
+
+pub(crate) unsafe fn reader_from_raw_parts<'a>(p: *const u8, len: u32) -> Reader<'a> {
+    ::core::slice::from_raw_parts(p, len as usize)
+}
+
+impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a>> {
+        reader.get_data(default)
+    }
+}
+
+pub type Builder<'a> = &'a mut [u8];
+
+pub(crate) unsafe fn builder_from_raw_parts<'a>(p: *mut u8, len: u32) -> Builder<'a> {
+    ::core::slice::from_raw_parts_mut(p, len as usize)
+}
+
+impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a> {
+        builder.init_data(size)
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a>> {
+        builder.get_data(default)
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: PointerBuilder<'b>,
+        value: Reader<'a>,
+        _canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_data(value);
+        Ok(())
+    }
+}
+
+impl<'a> From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+    fn from(d: Reader<'a>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::Data(d)
+    }
+}
+
+impl<'a> From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+    fn from(d: Builder<'a>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::Data(d)
+    }
+}
diff --git a/rust/capnp/data_list.rs b/rust/capnp/data_list.rs
new file mode 100644
index 000000000000..f5fee2575fd2
--- /dev/null
+++ b/rust/capnp/data_list.rs
@@ -0,0 +1,218 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of sequences of bytes.
+
+use crate::private::layout::*;
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned;
+
+impl crate::traits::Owned for Owned {
+    type Reader<'a> = Reader<'a>;
+    type Builder<'a> = Builder<'a>;
+}
+
+impl crate::introspect::Introspect for Owned {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::Type::list_of(crate::introspect::TypeVariant::Data.into())
+    }
+}
+
+#[derive(Clone, Copy)]
+pub struct Reader<'a> {
+    pub reader: ListReader<'a>,
+}
+
+impl<'a> Reader<'a> {
+    pub fn new(reader: ListReader<'_>) -> Reader<'_> {
+        Reader { reader }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a>, Result<crate::data::Reader<'a>>> {
+        let l = self.len();
+        ListIter::new(self, l)
+    }
+}
+
+impl<'a> FromPointerReader<'a> for Reader<'a> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a>> {
+        Ok(Reader {
+            reader: reader.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a> IndexMove<u32, Result<crate::data::Reader<'a>>> for Reader<'a> {
+    fn index_move(&self, index: u32) -> Result<crate::data::Reader<'a>> {
+        self.get(index)
+    }
+}
+
+impl<'a> Reader<'a> {
+    /// Gets the `data::Reader` at position `index`. Panics if `index` is
+    /// greater than or equal to `len()`.
+    pub fn get(self, index: u32) -> Result<crate::data::Reader<'a>> {
+        assert!(index < self.len());
+        self.reader.get_pointer_element(index).get_data(None)
+    }
+
+    /// Gets the `data::Reader` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<crate::data::Reader<'a>>> {
+        if index < self.len() {
+            Some(self.reader.get_pointer_element(index).get_data(None))
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a> crate::traits::IntoInternalListReader<'a> for Reader<'a> {
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a> {
+    builder: ListBuilder<'a>,
+}
+
+impl<'a> Builder<'a> {
+    pub fn new(builder: ListBuilder<'a>) -> Builder<'a> {
+        Builder { builder }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader {
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    pub fn set(&mut self, index: u32, value: crate::data::Reader) {
+        assert!(index < self.len());
+        self.builder
+            .reborrow()
+            .get_pointer_element(index)
+            .set_data(value);
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        Builder {
+            builder: self.builder.reborrow(),
+        }
+    }
+}
+
+impl<'a> FromPointerBuilder<'a> for Builder<'a> {
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a> {
+        Builder {
+            builder: builder.init_list(Pointer, size),
+        }
+    }
+
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a>> {
+        Ok(Builder {
+            builder: builder.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a> Builder<'a> {
+    /// Gets the `data::Builder` at position `index`. Panics if `index` is
+    /// greater than or equal to `len()`.
+    pub fn get(self, index: u32) -> Result<crate::data::Builder<'a>> {
+        assert!(index < self.len());
+        self.builder.get_pointer_element(index).get_data(None)
+    }
+
+    /// Gets the `data::Builder` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<crate::data::Builder<'a>>> {
+        if index < self.len() {
+            Some(self.builder.get_pointer_element(index).get_data(None))
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)?;
+        Ok(())
+    }
+}
+
+impl<'a> ::core::iter::IntoIterator for Reader<'a> {
+    type Item = Result<crate::data::Reader<'a>>;
+    type IntoIter = ListIter<Reader<'a>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a> From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader {
+            reader: t.reader,
+            element_type: crate::introspect::TypeVariant::Data.into(),
+        })
+    }
+}
+
+impl<'a> From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder {
+            builder: t.builder,
+            element_type: crate::introspect::TypeVariant::Data.into(),
+        })
+    }
+}
diff --git a/rust/capnp/dynamic_list.rs b/rust/capnp/dynamic_list.rs
new file mode 100644
index 000000000000..f2c93e1cbe16
--- /dev/null
+++ b/rust/capnp/dynamic_list.rs
@@ -0,0 +1,408 @@
+//! Dynamically-typed lists.
+
+use crate::dynamic_value;
+use crate::introspect::{Type, TypeVariant};
+use crate::private::layout::{self, PrimitiveElement};
+use crate::traits::{IndexMove, ListIter};
+use crate::{Error, ErrorKind, Result};
+
+/// A read-only dynamically-typed list.
+#[derive(Copy, Clone)]
+pub struct Reader<'a> {
+    pub(crate) reader: layout::ListReader<'a>,
+    pub(crate) element_type: Type,
+}
+
+impl<'a> From<Reader<'a>> for dynamic_value::Reader<'a> {
+    fn from(x: Reader<'a>) -> dynamic_value::Reader<'a> {
+        dynamic_value::Reader::List(x)
+    }
+}
+
+impl<'a> Reader<'a> {
+    pub(crate) fn new(reader: layout::ListReader<'a>, element_type: Type) -> Self {
+        Self {
+            reader,
+            element_type,
+        }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn element_type(&self) -> Type {
+        self.element_type
+    }
+
+    pub fn get(self, index: u32) -> Result<crate::dynamic_value::Reader<'a>> {
+        assert!(index < self.reader.len());
+        match self.element_type.which() {
+            TypeVariant::Void => Ok(dynamic_value::Reader::Void),
+            TypeVariant::Bool => Ok(dynamic_value::Reader::Bool(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Int8 => Ok(dynamic_value::Reader::Int8(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Int16 => Ok(dynamic_value::Reader::Int16(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Int32 => Ok(dynamic_value::Reader::Int32(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Int64 => Ok(dynamic_value::Reader::Int64(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::UInt8 => Ok(dynamic_value::Reader::UInt8(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::UInt16 => Ok(dynamic_value::Reader::UInt16(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::UInt32 => Ok(dynamic_value::Reader::UInt32(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::UInt64 => Ok(dynamic_value::Reader::UInt64(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Float32 => Ok(dynamic_value::Reader::Float32(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Float64 => Ok(dynamic_value::Reader::Float64(PrimitiveElement::get(
+                &self.reader,
+                index,
+            ))),
+            TypeVariant::Enum(e) => Ok(dynamic_value::Enum::new(
+                PrimitiveElement::get(&self.reader, index),
+                e.into(),
+            )
+            .into()),
+            TypeVariant::Text => Ok(dynamic_value::Reader::Text(
+                self.reader.get_pointer_element(index).get_text(None)?,
+            )),
+            TypeVariant::Data => Ok(dynamic_value::Reader::Data(
+                self.reader.get_pointer_element(index).get_data(None)?,
+            )),
+            TypeVariant::List(element_type) => Ok(Reader {
+                reader: self
+                    .reader
+                    .get_pointer_element(index)
+                    .get_list(element_type.expected_element_size(), None)?,
+                element_type,
+            }
+            .into()),
+            TypeVariant::Struct(ss) => {
+                let r = self.reader.get_struct_element(index);
+                Ok(dynamic_value::Reader::Struct(
+                    crate::dynamic_struct::Reader::new(r, ss.into()),
+                ))
+            }
+            TypeVariant::AnyPointer => {
+                Ok(crate::any_pointer::Reader::new(self.reader.get_pointer_element(index)).into())
+            }
+            TypeVariant::Capability => {
+                Ok(dynamic_value::Reader::Capability(dynamic_value::Capability))
+            }
+        }
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a>, Result<dynamic_value::Reader<'a>>> {
+        ListIter::new(self, self.len())
+    }
+}
+
+impl<'a> IndexMove<u32, Result<dynamic_value::Reader<'a>>> for Reader<'a> {
+    fn index_move(&self, index: u32) -> Result<dynamic_value::Reader<'a>> {
+        self.get(index)
+    }
+}
+
+impl<'a> ::core::iter::IntoIterator for Reader<'a> {
+    type Item = Result<dynamic_value::Reader<'a>>;
+    type IntoIter = ListIter<Reader<'a>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+/// A mutable dynamically-typed list.
+pub struct Builder<'a> {
+    pub(crate) builder: layout::ListBuilder<'a>,
+    pub(crate) element_type: Type,
+}
+
+impl<'a> From<Builder<'a>> for dynamic_value::Builder<'a> {
+    fn from(x: Builder<'a>) -> dynamic_value::Builder<'a> {
+        dynamic_value::Builder::List(x)
+    }
+}
+
+impl<'a> Builder<'a> {
+    pub(crate) fn new(builder: layout::ListBuilder<'a>, element_type: Type) -> Self {
+        Self {
+            builder,
+            element_type,
+        }
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        Builder {
+            builder: self.builder.reborrow(),
+            element_type: self.element_type,
+        }
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader {
+            reader: self.builder.into_reader(),
+            element_type: self.element_type,
+        }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn element_type(&self) -> Type {
+        self.element_type
+    }
+
+    pub fn get(self, index: u32) -> Result<dynamic_value::Builder<'a>> {
+        assert!(index < self.builder.len());
+        match self.element_type.which() {
+            TypeVariant::Void => Ok(dynamic_value::Builder::Void),
+            TypeVariant::Bool => Ok(dynamic_value::Builder::Bool(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Int8 => Ok(dynamic_value::Builder::Int8(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Int16 => Ok(dynamic_value::Builder::Int16(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Int32 => Ok(dynamic_value::Builder::Int32(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Int64 => Ok(dynamic_value::Builder::Int64(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::UInt8 => Ok(dynamic_value::Builder::UInt8(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::UInt16 => Ok(dynamic_value::Builder::UInt16(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::UInt32 => Ok(dynamic_value::Builder::UInt32(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::UInt64 => Ok(dynamic_value::Builder::UInt64(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Float32 => Ok(dynamic_value::Builder::Float32(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Float64 => Ok(dynamic_value::Builder::Float64(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+            )),
+            TypeVariant::Enum(e) => Ok(dynamic_value::Enum::new(
+                PrimitiveElement::get_from_builder(&self.builder, index),
+                e.into(),
+            )
+            .into()),
+            TypeVariant::Text => Ok(dynamic_value::Builder::Text(
+                self.builder.get_pointer_element(index).get_text(None)?,
+            )),
+            TypeVariant::Data => Ok(dynamic_value::Builder::Data(
+                self.builder.get_pointer_element(index).get_data(None)?,
+            )),
+            TypeVariant::List(element_type) => Ok(Builder {
+                builder: self
+                    .builder
+                    .get_pointer_element(index)
+                    .get_list(element_type.expected_element_size(), None)?,
+                element_type,
+            }
+            .into()),
+            TypeVariant::Struct(ss) => {
+                let r = self.builder.get_struct_element(index);
+                Ok(dynamic_value::Builder::Struct(
+                    crate::dynamic_struct::Builder::new(r, ss.into()),
+                ))
+            }
+            TypeVariant::AnyPointer => Ok(crate::any_pointer::Builder::new(
+                self.builder.get_pointer_element(index),
+            )
+            .into()),
+            TypeVariant::Capability => Ok(dynamic_value::Builder::Capability(
+                dynamic_value::Capability,
+            )),
+        }
+    }
+
+    pub fn set(&mut self, index: u32, value: dynamic_value::Reader<'_>) -> Result<()> {
+        assert!(index < self.builder.len());
+        match (self.element_type.which(), value) {
+            (TypeVariant::Void, _) => Ok(()),
+            (TypeVariant::Bool, dynamic_value::Reader::Bool(b)) => {
+                PrimitiveElement::set(&self.builder, index, b);
+                Ok(())
+            }
+            (TypeVariant::Int8, dynamic_value::Reader::Int8(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::Int16, dynamic_value::Reader::Int16(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::Int32, dynamic_value::Reader::Int32(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::Int64, dynamic_value::Reader::Int64(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::UInt8, dynamic_value::Reader::UInt8(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::UInt16, dynamic_value::Reader::UInt16(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::UInt32, dynamic_value::Reader::UInt32(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::UInt64, dynamic_value::Reader::UInt64(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::Float32, dynamic_value::Reader::Float32(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::Float64, dynamic_value::Reader::Float64(x)) => {
+                PrimitiveElement::set(&self.builder, index, x);
+                Ok(())
+            }
+            (TypeVariant::Enum(_es), dynamic_value::Reader::Enum(e)) => {
+                PrimitiveElement::set(&self.builder, index, e.get_value());
+                Ok(())
+            }
+            (TypeVariant::Text, dynamic_value::Reader::Text(t)) => {
+                self.builder
+                    .reborrow()
+                    .get_pointer_element(index)
+                    .set_text(t);
+                Ok(())
+            }
+            (TypeVariant::Data, dynamic_value::Reader::Data(d)) => {
+                self.builder
+                    .reborrow()
+                    .get_pointer_element(index)
+                    .set_data(d);
+                Ok(())
+            }
+            (TypeVariant::Struct(ss), dynamic_value::Reader::Struct(s)) => {
+                assert_eq!(ss, s.get_schema().raw);
+                self.builder
+                    .reborrow()
+                    .get_struct_element(index)
+                    .copy_content_from(&s.reader)
+            }
+            (TypeVariant::List(_element_type), dynamic_value::Reader::List(list)) => self
+                .builder
+                .reborrow()
+                .get_pointer_element(index)
+                .set_list(&list.reader, false),
+            (TypeVariant::AnyPointer, _) => {
+                Err(Error::from_kind(ErrorKind::ListAnyPointerNotSupported))
+            }
+            (TypeVariant::Capability, dynamic_value::Reader::Capability(_)) => {
+                Err(Error::from_kind(ErrorKind::ListCapabilityNotSupported))
+            }
+            (_, _) => Err(Error::from_kind(ErrorKind::TypeMismatch)),
+        }
+    }
+
+    pub fn init(self, index: u32, size: u32) -> Result<dynamic_value::Builder<'a>> {
+        assert!(index < self.builder.len());
+        match self.element_type.which() {
+            TypeVariant::Void
+            | TypeVariant::Bool
+            | TypeVariant::Int8
+            | TypeVariant::Int16
+            | TypeVariant::Int32
+            | TypeVariant::Int64
+            | TypeVariant::UInt8
+            | TypeVariant::UInt16
+            | TypeVariant::UInt32
+            | TypeVariant::UInt64
+            | TypeVariant::Float32
+            | TypeVariant::Float64
+            | TypeVariant::Enum(_)
+            | TypeVariant::Struct(_)
+            | TypeVariant::Capability => Err(Error::from_kind(ErrorKind::ExpectedAListOrBlob)),
+            TypeVariant::Text => Ok(self
+                .builder
+                .get_pointer_element(index)
+                .init_text(size)
+                .into()),
+            TypeVariant::Data => Ok(self
+                .builder
+                .get_pointer_element(index)
+                .init_data(size)
+                .into()),
+            TypeVariant::List(inner_element_type) => match inner_element_type.which() {
+                TypeVariant::Struct(rbs) => Ok(Builder::new(
+                    self.builder.get_pointer_element(index).init_struct_list(
+                        size,
+                        crate::dynamic_struct::struct_size_from_schema(rbs.into())?,
+                    ),
+                    inner_element_type,
+                )
+                .into()),
+                _ => Ok(Builder::new(
+                    self.builder
+                        .get_pointer_element(index)
+                        .init_list(inner_element_type.expected_element_size(), size),
+                    inner_element_type,
+                )
+                .into()),
+            },
+            TypeVariant::AnyPointer => Err(Error::from_kind(ErrorKind::ListAnyPointerNotSupported)),
+        }
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
diff --git a/rust/capnp/dynamic_struct.rs b/rust/capnp/dynamic_struct.rs
new file mode 100644
index 000000000000..d0244fc29f40
--- /dev/null
+++ b/rust/capnp/dynamic_struct.rs
@@ -0,0 +1,782 @@
+//! Dynamically-typed structs.
+
+use crate::introspect::TypeVariant;
+use crate::private::layout;
+use crate::schema::{Field, StructSchema};
+use crate::schema_capnp::{field, node, value};
+use crate::{dynamic_list, dynamic_value};
+use crate::{Error, ErrorKind, Result};
+
+fn has_discriminant_value(reader: field::Reader) -> bool {
+    reader.get_discriminant_value() != field::NO_DISCRIMINANT
+}
+
+pub(crate) fn struct_size_from_schema(schema: StructSchema) -> Result<layout::StructSize> {
+    if let node::Struct(s) = schema.proto.which()? {
+        Ok(layout::StructSize {
+            data: s.get_data_word_count(),
+            pointers: s.get_pointer_count(),
+        })
+    } else {
+        Err(Error::from_kind(ErrorKind::NotAStruct))
+    }
+}
+
+/// A read-only dynamically-typed struct.
+#[derive(Clone, Copy)]
+pub struct Reader<'a> {
+    pub(crate) reader: layout::StructReader<'a>,
+    schema: StructSchema,
+}
+
+impl<'a> From<Reader<'a>> for dynamic_value::Reader<'a> {
+    fn from(x: Reader<'a>) -> dynamic_value::Reader<'a> {
+        dynamic_value::Reader::Struct(x)
+    }
+}
+
+impl<'a> Reader<'a> {
+    pub fn new(reader: layout::StructReader<'a>, schema: StructSchema) -> Self {
+        Self { reader, schema }
+    }
+
+    pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+        self.reader.total_size()
+    }
+
+    pub fn get_schema(&self) -> StructSchema {
+        self.schema
+    }
+
+    pub fn get(self, field: Field) -> Result<dynamic_value::Reader<'a>> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        let ty = field.get_type();
+        match field.get_proto().which()? {
+            field::Slot(slot) => {
+                let offset = slot.get_offset();
+                let default_value = slot.get_default_value()?;
+
+                match (ty.which(), default_value.which()?) {
+                    (TypeVariant::Void, _) => Ok(dynamic_value::Reader::Void),
+                    (TypeVariant::Bool, value::Bool(b)) => Ok(dynamic_value::Reader::Bool(
+                        self.reader.get_bool_field_mask(offset as usize, b),
+                    )),
+                    (TypeVariant::Int8, value::Int8(x)) => Ok(dynamic_value::Reader::Int8(
+                        self.reader.get_data_field_mask::<i8>(offset as usize, x),
+                    )),
+                    (TypeVariant::Int16, value::Int16(x)) => Ok(dynamic_value::Reader::Int16(
+                        self.reader.get_data_field_mask::<i16>(offset as usize, x),
+                    )),
+                    (TypeVariant::Int32, value::Int32(x)) => Ok(dynamic_value::Reader::Int32(
+                        self.reader.get_data_field_mask::<i32>(offset as usize, x),
+                    )),
+                    (TypeVariant::Int64, value::Int64(x)) => Ok(dynamic_value::Reader::Int64(
+                        self.reader.get_data_field_mask::<i64>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt8, value::Uint8(x)) => Ok(dynamic_value::Reader::UInt8(
+                        self.reader.get_data_field_mask::<u8>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt16, value::Uint16(x)) => Ok(dynamic_value::Reader::UInt16(
+                        self.reader.get_data_field_mask::<u16>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt32, value::Uint32(x)) => Ok(dynamic_value::Reader::UInt32(
+                        self.reader.get_data_field_mask::<u32>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt64, value::Uint64(x)) => Ok(dynamic_value::Reader::UInt64(
+                        self.reader.get_data_field_mask::<u64>(offset as usize, x),
+                    )),
+                    (TypeVariant::Float32, value::Float32(x)) => {
+                        Ok(dynamic_value::Reader::Float32(
+                            self.reader
+                                .get_data_field_mask::<f32>(offset as usize, x.to_bits()),
+                        ))
+                    }
+                    (TypeVariant::Float64, value::Float64(x)) => {
+                        Ok(dynamic_value::Reader::Float64(
+                            self.reader
+                                .get_data_field_mask::<f64>(offset as usize, x.to_bits()),
+                        ))
+                    }
+                    (TypeVariant::Enum(schema), value::Enum(d)) => Ok(dynamic_value::Enum::new(
+                        self.reader.get_data_field_mask::<u16>(offset as usize, d),
+                        schema.into(),
+                    )
+                    .into()),
+                    (TypeVariant::Text, dval) => {
+                        let p = self.reader.get_pointer_field(offset as usize);
+                        // If the type is a generic, then the default value
+                        // is always an empty AnyPointer. Ignore that case.
+                        let t1 = if let (true, value::Text(t)) = (p.is_null(), dval) {
+                            t?
+                        } else {
+                            p.get_text(None)?
+                        };
+                        Ok(dynamic_value::Reader::Text(t1))
+                    }
+                    (TypeVariant::Data, dval) => {
+                        let p = self.reader.get_pointer_field(offset as usize);
+                        // If the type is a generic, then the default value
+                        // is always an empty AnyPointer. Ignore that case.
+                        let d1 = if let (true, value::Data(d)) = (p.is_null(), dval) {
+                            d?
+                        } else {
+                            p.get_data(None)?
+                        };
+                        Ok(dynamic_value::Reader::Data(d1))
+                    }
+                    (TypeVariant::Struct(schema), dval) => {
+                        let p = self.reader.get_pointer_field(offset as usize);
+                        // If the type is a generic, then the default value
+                        // is always an empty AnyPointer. Ignore that case.
+                        let p1 = if let (true, value::Struct(s)) = (p.is_null(), dval) {
+                            s.reader
+                        } else {
+                            p
+                        };
+                        let r = p1.get_struct(None)?;
+                        Ok(Reader::new(r, schema.into()).into())
+                    }
+                    (TypeVariant::List(element_type), dval) => {
+                        let p = self.reader.get_pointer_field(offset as usize);
+                        // If the type is a generic, then the default value
+                        // is always an empty AnyPointer. Ignore that case.
+                        let p1 = if let (true, value::List(l)) = (p.is_null(), dval) {
+                            l.reader
+                        } else {
+                            p
+                        };
+                        let l = p1.get_list(element_type.expected_element_size(), None)?;
+                        Ok(dynamic_list::Reader::new(l, element_type).into())
+                    }
+                    (TypeVariant::AnyPointer, value::AnyPointer(a)) => {
+                        let p = self.reader.get_pointer_field(offset as usize);
+                        let a1 = if p.is_null() {
+                            a
+                        } else {
+                            crate::any_pointer::Reader::new(p)
+                        };
+                        Ok(dynamic_value::Reader::AnyPointer(a1))
+                    }
+                    (TypeVariant::Capability, value::Interface(())) => {
+                        Ok(dynamic_value::Reader::Capability(dynamic_value::Capability))
+                    }
+                    _ => Err(Error::from_kind(ErrorKind::FieldAndDefaultMismatch)),
+                }
+            }
+            field::Group(_) => {
+                if let TypeVariant::Struct(schema) = ty.which() {
+                    Ok(Reader::new(self.reader, schema.into()).into())
+                } else {
+                    Err(Error::from_kind(ErrorKind::GroupFieldButTypeIsNotStruct))
+                }
+            }
+        }
+    }
+
+    /// Gets the field with the given name.
+    pub fn get_named(self, field_name: &str) -> Result<dynamic_value::Reader<'a>> {
+        self.get(self.schema.get_field_by_name(field_name)?)
+    }
+
+    /// If this struct has union fields, returns the one that is currently active.
+    /// Otherwise, returns None.
+    pub fn which(&self) -> Result<Option<Field>> {
+        let node::Struct(st) = self.schema.get_proto().which()? else {
+            return Err(Error::from_kind(ErrorKind::NotAStruct));
+        };
+        if st.get_discriminant_count() == 0 {
+            Ok(None)
+        } else {
+            let discrim = self
+                .reader
+                .get_data_field::<u16>(st.get_discriminant_offset() as usize);
+            self.schema.get_field_by_discriminant(discrim)
+        }
+    }
+
+    /// Returns `false` if the field is a pointer and the pointer is null.
+    pub fn has(&self, field: Field) -> Result<bool> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        let proto = field.get_proto();
+        if has_discriminant_value(proto) {
+            let node::Struct(st) = self.schema.get_proto().which()? else {
+                return Err(Error::from_kind(ErrorKind::NotAStruct));
+            };
+
+            let discrim = self
+                .reader
+                .get_data_field::<u16>(st.get_discriminant_offset() as usize);
+            if discrim != proto.get_discriminant_value() {
+                // Field is not active in the union.
+                return Ok(false);
+            }
+        }
+        let slot = match proto.which()? {
+            field::Group(_) => return Ok(true),
+            field::Slot(s) => s,
+        };
+        let ty = field.get_type();
+        if ty.is_pointer_type() {
+            Ok(!self
+                .reader
+                .get_pointer_field(slot.get_offset() as usize)
+                .is_null())
+        } else {
+            Ok(true)
+        }
+    }
+
+    pub fn has_named(&self, field_name: &str) -> Result<bool> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.has(field)
+    }
+}
+
+/// A mutable dynamically-typed struct.
+pub struct Builder<'a> {
+    builder: layout::StructBuilder<'a>,
+    schema: StructSchema,
+}
+
+impl<'a> From<Builder<'a>> for dynamic_value::Builder<'a> {
+    fn from(x: Builder<'a>) -> dynamic_value::Builder<'a> {
+        dynamic_value::Builder::Struct(x)
+    }
+}
+
+impl<'a> Builder<'a> {
+    pub fn new(builder: layout::StructBuilder<'a>, schema: StructSchema) -> Self {
+        Self { builder, schema }
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        Builder {
+            builder: self.builder.reborrow(),
+            schema: self.schema,
+        }
+    }
+
+    pub fn reborrow_as_reader(&self) -> Reader<'_> {
+        Reader {
+            reader: self.builder.as_reader(),
+            schema: self.schema,
+        }
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader {
+            schema: self.schema,
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    pub fn get_schema(&self) -> StructSchema {
+        self.schema
+    }
+
+    pub fn get(self, field: Field) -> Result<dynamic_value::Builder<'a>> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        let ty = field.get_type();
+        match field.get_proto().which()? {
+            field::Slot(slot) => {
+                let offset = slot.get_offset();
+                let default_value = slot.get_default_value()?;
+
+                match (ty.which(), default_value.which()?) {
+                    (TypeVariant::Void, _) => Ok(dynamic_value::Builder::Void),
+                    (TypeVariant::Bool, value::Bool(b)) => Ok(dynamic_value::Builder::Bool(
+                        self.builder.get_bool_field_mask(offset as usize, b),
+                    )),
+                    (TypeVariant::Int8, value::Int8(x)) => Ok(dynamic_value::Builder::Int8(
+                        self.builder.get_data_field_mask::<i8>(offset as usize, x),
+                    )),
+                    (TypeVariant::Int16, value::Int16(x)) => Ok(dynamic_value::Builder::Int16(
+                        self.builder.get_data_field_mask::<i16>(offset as usize, x),
+                    )),
+                    (TypeVariant::Int32, value::Int32(x)) => Ok(dynamic_value::Builder::Int32(
+                        self.builder.get_data_field_mask::<i32>(offset as usize, x),
+                    )),
+                    (TypeVariant::Int64, value::Int64(x)) => Ok(dynamic_value::Builder::Int64(
+                        self.builder.get_data_field_mask::<i64>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt8, value::Uint8(x)) => Ok(dynamic_value::Builder::UInt8(
+                        self.builder.get_data_field_mask::<u8>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt16, value::Uint16(x)) => Ok(dynamic_value::Builder::UInt16(
+                        self.builder.get_data_field_mask::<u16>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt32, value::Uint32(x)) => Ok(dynamic_value::Builder::UInt32(
+                        self.builder.get_data_field_mask::<u32>(offset as usize, x),
+                    )),
+                    (TypeVariant::UInt64, value::Uint64(x)) => Ok(dynamic_value::Builder::UInt64(
+                        self.builder.get_data_field_mask::<u64>(offset as usize, x),
+                    )),
+                    (TypeVariant::Float32, value::Float32(x)) => {
+                        Ok(dynamic_value::Builder::Float32(
+                            self.builder
+                                .get_data_field_mask::<f32>(offset as usize, x.to_bits()),
+                        ))
+                    }
+                    (TypeVariant::Float64, value::Float64(x)) => {
+                        Ok(dynamic_value::Builder::Float64(
+                            self.builder
+                                .get_data_field_mask::<f64>(offset as usize, x.to_bits()),
+                        ))
+                    }
+                    (TypeVariant::Enum(schema), value::Enum(d)) => Ok(dynamic_value::Enum::new(
+                        self.builder.get_data_field_mask::<u16>(offset as usize, d),
+                        schema.into(),
+                    )
+                    .into()),
+                    (TypeVariant::Text, dval) => {
+                        let mut p = self.builder.get_pointer_field(offset as usize);
+                        if p.is_null() {
+                            // If the type is a generic, then the default value
+                            // is always an empty AnyPointer. Ignore that case.
+                            if let value::Text(t) = dval {
+                                p.set_text(t?);
+                            }
+                        }
+                        Ok(dynamic_value::Builder::Text(p.get_text(None)?))
+                    }
+                    (TypeVariant::Data, dval) => {
+                        let mut p = self.builder.get_pointer_field(offset as usize);
+                        if p.is_null() {
+                            // If the type is a generic, then the default value
+                            // is always an empty AnyPointer. Ignore that case.
+                            if let value::Data(d) = dval {
+                                p.set_data(d?);
+                            }
+                        }
+                        Ok(dynamic_value::Builder::Data(p.get_data(None)?))
+                    }
+                    (TypeVariant::Struct(schema), dval) => {
+                        let mut p = self.builder.get_pointer_field(offset as usize);
+                        if p.is_null() {
+                            // If the type is a generic, then the default value
+                            // is always an empty AnyPointer. Ignore that case.
+                            if let value::Struct(s) = dval {
+                                p.copy_from(s.reader, false)?;
+                            }
+                        }
+                        Ok(Builder::new(
+                            p.get_struct(struct_size_from_schema(schema.into())?, None)?,
+                            schema.into(),
+                        )
+                        .into())
+                    }
+                    (TypeVariant::List(element_type), dval) => {
+                        let mut p = self.builder.get_pointer_field(offset as usize);
+                        if p.is_null() {
+                            if let value::List(l) = dval {
+                                p.copy_from(l.reader, false)?;
+                            }
+                        }
+                        let l = if let TypeVariant::Struct(ss) = element_type.which() {
+                            p.get_struct_list(struct_size_from_schema(ss.into())?, None)?
+                        } else {
+                            p.get_list(element_type.expected_element_size(), None)?
+                        };
+
+                        Ok(dynamic_list::Builder::new(l, element_type).into())
+                    }
+                    (TypeVariant::AnyPointer, value::AnyPointer(_a)) => {
+                        // AnyPointer fields can't have a nontrivial default.
+                        Ok(crate::any_pointer::Builder::new(
+                            self.builder.get_pointer_field(offset as usize),
+                        )
+                        .into())
+                    }
+                    (TypeVariant::Capability, value::Interface(())) => Ok(
+                        dynamic_value::Builder::Capability(dynamic_value::Capability),
+                    ),
+                    _ => Err(Error::from_kind(ErrorKind::FieldAndDefaultMismatch)),
+                }
+            }
+            field::Group(_) => {
+                if let TypeVariant::Struct(schema) = ty.which() {
+                    Ok(Builder::new(self.builder, schema.into()).into())
+                } else {
+                    Err(Error::from_kind(ErrorKind::GroupFieldButTypeIsNotStruct))
+                }
+            }
+        }
+    }
+
+    pub fn get_named(self, field_name: &str) -> Result<dynamic_value::Builder<'a>> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.get(field)
+    }
+
+    pub fn which(&self) -> Result<Option<Field>> {
+        let node::Struct(st) = self.schema.get_proto().which()? else {
+            return Err(Error::from_kind(ErrorKind::NotAStruct));
+        };
+        if st.get_discriminant_count() == 0 {
+            Ok(None)
+        } else {
+            let discrim = self
+                .builder
+                .get_data_field::<u16>(st.get_discriminant_offset() as usize);
+            self.schema.get_field_by_discriminant(discrim)
+        }
+    }
+
+    pub fn has(&self, field: Field) -> Result<bool> {
+        self.reborrow_as_reader().has(field)
+    }
+
+    pub fn has_named(&self, field_name: &str) -> Result<bool> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.has(field)
+    }
+
+    pub fn set(&mut self, field: Field, value: dynamic_value::Reader<'_>) -> Result<()> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        self.set_in_union(field)?;
+        let ty = field.get_type();
+        match field.get_proto().which()? {
+            field::Slot(slot) => {
+                let dval = slot.get_default_value()?;
+                let offset = slot.get_offset() as usize;
+                match (ty.which(), value, dval.which()?) {
+                    (TypeVariant::Void, _, _) => Ok(()),
+                    (TypeVariant::Bool, dynamic_value::Reader::Bool(v), value::Bool(b)) => {
+                        self.builder.set_bool_field_mask(offset, v, b);
+                        Ok(())
+                    }
+                    (TypeVariant::Int8, dynamic_value::Reader::Int8(v), value::Int8(d)) => {
+                        self.builder.set_data_field_mask::<i8>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::Int16, dynamic_value::Reader::Int16(v), value::Int16(d)) => {
+                        self.builder.set_data_field_mask::<i16>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::Int32, dynamic_value::Reader::Int32(v), value::Int32(d)) => {
+                        self.builder.set_data_field_mask::<i32>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::Int64, dynamic_value::Reader::Int64(v), value::Int64(d)) => {
+                        self.builder.set_data_field_mask::<i64>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::UInt8, dynamic_value::Reader::UInt8(v), value::Uint8(d)) => {
+                        self.builder.set_data_field_mask::<u8>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::UInt16, dynamic_value::Reader::UInt16(v), value::Uint16(d)) => {
+                        self.builder.set_data_field_mask::<u16>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::UInt32, dynamic_value::Reader::UInt32(v), value::Uint32(d)) => {
+                        self.builder.set_data_field_mask::<u32>(offset, v, d);
+                        Ok(())
+                    }
+                    (TypeVariant::UInt64, dynamic_value::Reader::UInt64(v), value::Uint64(d)) => {
+                        self.builder.set_data_field_mask::<u64>(offset, v, d);
+                        Ok(())
+                    }
+                    (
+                        TypeVariant::Float32,
+                        dynamic_value::Reader::Float32(v),
+                        value::Float32(d),
+                    ) => {
+                        self.builder
+                            .set_data_field_mask::<f32>(offset, v, d.to_bits());
+                        Ok(())
+                    }
+                    (
+                        TypeVariant::Float64,
+                        dynamic_value::Reader::Float64(v),
+                        value::Float64(d),
+                    ) => {
+                        self.builder
+                            .set_data_field_mask::<f64>(offset, v, d.to_bits());
+                        Ok(())
+                    }
+                    (TypeVariant::Enum(_), dynamic_value::Reader::Enum(ev), value::Enum(d)) => {
+                        self.builder
+                            .set_data_field_mask::<u16>(offset, ev.get_value(), d);
+                        Ok(())
+                    }
+                    (TypeVariant::Text, dynamic_value::Reader::Text(tv), _) => {
+                        let mut p = self.builder.reborrow().get_pointer_field(offset);
+                        p.set_text(tv);
+                        Ok(())
+                    }
+                    (TypeVariant::Data, dynamic_value::Reader::Data(v), _) => {
+                        let mut p = self.builder.reborrow().get_pointer_field(offset);
+                        p.set_data(v);
+                        Ok(())
+                    }
+                    (TypeVariant::List(_), dynamic_value::Reader::List(l), _) => {
+                        let mut p = self.builder.reborrow().get_pointer_field(offset);
+                        p.set_list(&l.reader, false)
+                    }
+                    (TypeVariant::Struct(_), dynamic_value::Reader::Struct(v), _) => {
+                        let mut p = self.builder.reborrow().get_pointer_field(offset);
+                        p.set_struct(&v.reader, false)
+                    }
+                    (TypeVariant::AnyPointer, _, _) => {
+                        let mut target = crate::any_pointer::Builder::new(
+                            self.builder.reborrow().get_pointer_field(offset),
+                        );
+                        match value {
+                            dynamic_value::Reader::Text(t) => target.set_as(t),
+                            dynamic_value::Reader::Data(t) => target.set_as(t),
+                            dynamic_value::Reader::Struct(s) => target.set_as(s),
+                            dynamic_value::Reader::List(l) => target.set_as(l),
+                            dynamic_value::Reader::Capability(_) => Err(Error::from_kind(
+                                ErrorKind::SettingDynamicCapabilitiesIsUnsupported,
+                            )),
+                            _ => Err(Error::from_kind(
+                                ErrorKind::CannotSetAnyPointerFieldToAPrimitiveValue,
+                            )),
+                        }
+                    }
+                    (TypeVariant::Capability, _, _) => Err(Error::from_kind(
+                        ErrorKind::SettingDynamicCapabilitiesIsUnsupported,
+                    )),
+                    _ => Err(Error::from_kind(ErrorKind::TypeMismatch)),
+                }
+            }
+            field::Group(_group) => {
+                let dynamic_value::Reader::Struct(src) = value else {
+                    return Err(Error::from_kind(ErrorKind::NotAStruct));
+                };
+                let dynamic_value::Builder::Struct(mut dst) = self.reborrow().init(field)? else {
+                    return Err(Error::from_kind(ErrorKind::NotAStruct));
+                };
+                if let Some(union_field) = src.which()? {
+                    dst.set(union_field, src.get(union_field)?)?;
+                }
+
+                let non_union_fields = src.schema.get_non_union_fields()?;
+                for idx in 0..non_union_fields.len() {
+                    let field = non_union_fields.get(idx);
+                    if src.has(field)? {
+                        dst.set(field, src.get(field)?)?;
+                    }
+                }
+                Ok(())
+            }
+        }
+    }
+
+    pub fn set_named(&mut self, field_name: &str, value: dynamic_value::Reader<'_>) -> Result<()> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.set(field, value)
+    }
+
+    pub fn init(mut self, field: Field) -> Result<dynamic_value::Builder<'a>> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        self.set_in_union(field)?;
+        let ty = field.get_type();
+        match field.get_proto().which()? {
+            field::Slot(slot) => {
+                let offset = slot.get_offset() as usize;
+                match ty.which() {
+                    TypeVariant::Struct(ss) => Ok(Builder {
+                        schema: ss.into(),
+                        builder: self
+                            .builder
+                            .get_pointer_field(offset)
+                            .init_struct(struct_size_from_schema(ss.into())?),
+                    }
+                    .into()),
+                    TypeVariant::AnyPointer => {
+                        let mut p = self.builder.get_pointer_field(offset);
+                        p.clear();
+                        Ok(crate::any_pointer::Builder::new(p).into())
+                    }
+                    _ => Err(Error::from_kind(
+                        ErrorKind::InitIsOnlyValidForStructAndAnyPointerFields,
+                    )),
+                }
+            }
+            field::Group(_) => {
+                self.clear(field)?;
+                let TypeVariant::Struct(schema) = ty.which() else {
+                    return Err(Error::from_kind(ErrorKind::NotAStruct));
+                };
+                Ok((Builder::new(self.builder, schema.into())).into())
+            }
+        }
+    }
+
+    pub fn init_named(self, field_name: &str) -> Result<dynamic_value::Builder<'a>> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.init(field)
+    }
+
+    pub fn initn(mut self, field: Field, size: u32) -> Result<dynamic_value::Builder<'a>> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        self.set_in_union(field)?;
+        let ty = field.get_type();
+        match field.get_proto().which()? {
+            field::Slot(slot) => {
+                let offset = slot.get_offset() as usize;
+                match ty.which() {
+                    TypeVariant::List(element_type) => match element_type.which() {
+                        TypeVariant::Struct(ss) => Ok(dynamic_list::Builder::new(
+                            self.builder
+                                .get_pointer_field(offset)
+                                .init_struct_list(size, struct_size_from_schema(ss.into())?),
+                            element_type,
+                        )
+                        .into()),
+                        _ => Ok(dynamic_list::Builder::new(
+                            self.builder
+                                .get_pointer_field(offset)
+                                .init_list(element_type.expected_element_size(), size),
+                            element_type,
+                        )
+                        .into()),
+                    },
+                    TypeVariant::Text => Ok(self
+                        .builder
+                        .get_pointer_field(offset)
+                        .init_text(size)
+                        .into()),
+                    TypeVariant::Data => Ok(self
+                        .builder
+                        .get_pointer_field(offset)
+                        .init_data(size)
+                        .into()),
+
+                    _ => Err(Error::from_kind(
+                        ErrorKind::InitnIsOnlyValidForListTextOrDataFields,
+                    )),
+                }
+            }
+            field::Group(_) => Err(Error::from_kind(
+                ErrorKind::InitnIsOnlyValidForListTextOrDataFields,
+            )),
+        }
+    }
+
+    pub fn initn_named(self, field_name: &str, size: u32) -> Result<dynamic_value::Builder<'a>> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.initn(field, size)
+    }
+
+    /// Clears a field, setting it to its default value. For pointer fields,
+    /// this makes the field null.
+    pub fn clear(&mut self, field: Field) -> Result<()> {
+        assert_eq!(self.schema.raw, field.parent.raw);
+        self.set_in_union(field)?;
+        let ty = field.get_type();
+        match field.get_proto().which()? {
+            field::Slot(slot) => {
+                let offset = slot.get_offset() as usize;
+                match ty.which() {
+                    TypeVariant::Void => Ok(()),
+                    TypeVariant::Bool => {
+                        self.builder.set_bool_field(offset, false);
+                        Ok(())
+                    }
+                    TypeVariant::Int8 => {
+                        self.builder.set_data_field::<i8>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::Int16 => {
+                        self.builder.set_data_field::<i16>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::Int32 => {
+                        self.builder.set_data_field::<i32>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::Int64 => {
+                        self.builder.set_data_field::<i64>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::UInt8 => {
+                        self.builder.set_data_field::<u8>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::UInt16 => {
+                        self.builder.set_data_field::<u16>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::UInt32 => {
+                        self.builder.set_data_field::<u32>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::UInt64 => {
+                        self.builder.set_data_field::<u64>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::Float32 => {
+                        self.builder.set_data_field::<f32>(offset, 0f32);
+                        Ok(())
+                    }
+                    TypeVariant::Float64 => {
+                        self.builder.set_data_field::<f64>(offset, 0f64);
+                        Ok(())
+                    }
+                    TypeVariant::Enum(_) => {
+                        self.builder.set_data_field::<u16>(offset, 0);
+                        Ok(())
+                    }
+                    TypeVariant::Text
+                    | TypeVariant::Data
+                    | TypeVariant::Struct(_)
+                    | TypeVariant::List(_)
+                    | TypeVariant::AnyPointer
+                    | TypeVariant::Capability => {
+                        self.builder.reborrow().get_pointer_field(offset).clear();
+                        Ok(())
+                    }
+                }
+            }
+            field::Group(_) => {
+                let TypeVariant::Struct(schema) = ty.which() else {
+                    return Err(Error::from_kind(ErrorKind::NotAStruct));
+                };
+                let mut group = Builder::new(self.builder.reborrow(), schema.into());
+
+                // We clear the union field with discriminant 0 rather than the one that
+                // is set because we want the union to end up with its default field active.
+                if let Some(union_field) = group.schema.get_field_by_discriminant(0)? {
+                    group.clear(union_field)?;
+                }
+
+                let non_union_fields = group.schema.get_non_union_fields()?;
+                for idx in 0..non_union_fields.len() {
+                    group.clear(non_union_fields.get(idx))?;
+                }
+                Ok(())
+            }
+        }
+    }
+
+    pub fn clear_named(&mut self, field_name: &str) -> Result<()> {
+        let field = self.schema.get_field_by_name(field_name)?;
+        self.clear(field)
+    }
+
+    fn set_in_union(&mut self, field: Field) -> Result<()> {
+        if has_discriminant_value(field.get_proto()) {
+            let node::Struct(st) = self.schema.get_proto().which()? else {
+                return Err(Error::from_kind(ErrorKind::NotAStruct));
+            };
+            self.builder.set_data_field::<u16>(
+                st.get_discriminant_offset() as usize,
+                field.get_proto().get_discriminant_value(),
+            );
+        }
+        Ok(())
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_struct(&value.reader, canonicalize)
+    }
+}
diff --git a/rust/capnp/dynamic_value.rs b/rust/capnp/dynamic_value.rs
new file mode 100644
index 000000000000..83646e26de31
--- /dev/null
+++ b/rust/capnp/dynamic_value.rs
@@ -0,0 +1,317 @@
+//! Dynamically typed values.
+
+use crate::introspect::{self, TypeVariant};
+use crate::schema_capnp::value;
+use crate::Result;
+use crate::{dynamic_list, dynamic_struct};
+
+/// A dynamically-typed read-only value.
+#[derive(Clone, Copy)]
+pub enum Reader<'a> {
+    Void,
+    Bool(bool),
+    Int8(i8),
+    Int16(i16),
+    Int32(i32),
+    Int64(i64),
+    UInt8(u8),
+    UInt16(u16),
+    UInt32(u32),
+    UInt64(u64),
+    Float32(f32),
+    Float64(f64),
+    Enum(Enum),
+    Text(crate::text::Reader<'a>),
+    Data(crate::data::Reader<'a>),
+    Struct(dynamic_struct::Reader<'a>),
+    List(dynamic_list::Reader<'a>),
+    AnyPointer(crate::any_pointer::Reader<'a>),
+    Capability(Capability),
+}
+
+impl<'a> Reader<'a> {
+    pub fn new(value: value::Reader<'a>, ty: introspect::Type) -> Result<Self> {
+        match (value.which()?, ty.which()) {
+            (value::Void(()), _) => Ok(Reader::Void),
+            (value::Bool(b), _) => Ok(Reader::Bool(b)),
+            (value::Int8(x), _) => Ok(Reader::Int8(x)),
+            (value::Int16(x), _) => Ok(Reader::Int16(x)),
+            (value::Int32(x), _) => Ok(Reader::Int32(x)),
+            (value::Int64(x), _) => Ok(Reader::Int64(x)),
+            (value::Uint8(x), _) => Ok(Reader::UInt8(x)),
+            (value::Uint16(x), _) => Ok(Reader::UInt16(x)),
+            (value::Uint32(x), _) => Ok(Reader::UInt32(x)),
+            (value::Uint64(x), _) => Ok(Reader::UInt64(x)),
+            (value::Float32(x), _) => Ok(Reader::Float32(x)),
+            (value::Float64(x), _) => Ok(Reader::Float64(x)),
+            (value::Enum(d), TypeVariant::Enum(e)) => Ok(Reader::Enum(Enum::new(d, e.into()))),
+            (value::Text(t), _) => Ok(Reader::Text(t?)),
+            (value::Data(d), _) => Ok(Reader::Data(d?)),
+            (value::Struct(d), TypeVariant::Struct(schema)) => Ok(Reader::Struct(
+                dynamic_struct::Reader::new(d.reader.get_struct(None)?, schema.into()),
+            )),
+            (value::List(l), TypeVariant::List(element_type)) => {
+                Ok(Reader::List(dynamic_list::Reader::new(
+                    l.reader
+                        .get_list(element_type.expected_element_size(), None)?,
+                    element_type,
+                )))
+            }
+            (value::Interface(()), TypeVariant::Capability) => Ok(Capability.into()),
+            (value::AnyPointer(a), TypeVariant::AnyPointer) => Ok(a.into()),
+            _ => Err(crate::Error::from_kind(crate::ErrorKind::TypeMismatch)),
+        }
+    }
+
+    /// Downcasts the `Reader` into a more specific type. Panics if the
+    /// expected type does not match the value.
+    pub fn downcast<T: DowncastReader<'a>>(self) -> T {
+        T::downcast_reader(self)
+    }
+}
+
+impl<'a> From<()> for Reader<'a> {
+    fn from((): ()) -> Reader<'a> {
+        Reader::Void
+    }
+}
+
+macro_rules! primitive_dynamic_value(
+    ($t:ty, $v:ident) => (
+        impl <'a> From<$t> for Reader<'a> {
+            fn from(x: $t) -> Reader<'a> { Reader::$v(x) }
+        }
+    )
+);
+
+primitive_dynamic_value!(bool, Bool);
+primitive_dynamic_value!(i8, Int8);
+primitive_dynamic_value!(i16, Int16);
+primitive_dynamic_value!(i32, Int32);
+primitive_dynamic_value!(i64, Int64);
+primitive_dynamic_value!(u8, UInt8);
+primitive_dynamic_value!(u16, UInt16);
+primitive_dynamic_value!(u32, UInt32);
+primitive_dynamic_value!(u64, UInt64);
+primitive_dynamic_value!(f32, Float32);
+primitive_dynamic_value!(f64, Float64);
+
+/// Helper trait for the `dynamic_value::Reader::downcast()` method.
+pub trait DowncastReader<'a> {
+    fn downcast_reader(v: Reader<'a>) -> Self;
+}
+
+impl<'a> DowncastReader<'a> for () {
+    fn downcast_reader(value: Reader<'a>) {
+        let Reader::Void = value else {
+            panic!("error downcasting to void")
+        };
+    }
+}
+
+macro_rules! downcast_reader_impl(
+    ($t:ty, $v:ident, $s:expr) => (
+        impl <'a> DowncastReader<'a> for $t {
+            fn downcast_reader(value: Reader<'a>) -> Self {
+                let Reader::$v(x) = value else { panic!("error downcasting to {}", $s) };
+                x
+            }
+        }
+    )
+);
+
+downcast_reader_impl!(bool, Bool, "bool");
+downcast_reader_impl!(i8, Int8, "i8");
+downcast_reader_impl!(i16, Int16, "i16");
+downcast_reader_impl!(i32, Int32, "i32");
+downcast_reader_impl!(i64, Int64, "i64");
+downcast_reader_impl!(u8, UInt8, "u8");
+downcast_reader_impl!(u16, UInt16, "u16");
+downcast_reader_impl!(u32, UInt32, "u32");
+downcast_reader_impl!(u64, UInt64, "u64");
+downcast_reader_impl!(f32, Float32, "f32");
+downcast_reader_impl!(f64, Float64, "f64");
+downcast_reader_impl!(Enum, Enum, "enum");
+downcast_reader_impl!(crate::text::Reader<'a>, Text, "text");
+downcast_reader_impl!(crate::data::Reader<'a>, Data, "data");
+downcast_reader_impl!(dynamic_list::Reader<'a>, List, "list");
+downcast_reader_impl!(dynamic_struct::Reader<'a>, Struct, "struct");
+downcast_reader_impl!(crate::any_pointer::Reader<'a>, AnyPointer, "anypointer");
+
+/// A dynamically-typed value with mutable interior.
+pub enum Builder<'a> {
+    Void,
+    Bool(bool),
+    Int8(i8),
+    Int16(i16),
+    Int32(i32),
+    Int64(i64),
+    UInt8(u8),
+    UInt16(u16),
+    UInt32(u32),
+    UInt64(u64),
+    Float32(f32),
+    Float64(f64),
+    Enum(Enum),
+    Text(crate::text::Builder<'a>),
+    Data(crate::data::Builder<'a>),
+    Struct(dynamic_struct::Builder<'a>),
+    List(dynamic_list::Builder<'a>),
+    AnyPointer(crate::any_pointer::Builder<'a>),
+    Capability(Capability),
+}
+
+impl<'a> Builder<'a> {
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        match self {
+            Builder::Void => Builder::Void,
+            Builder::Bool(b) => Builder::Bool(*b),
+            Builder::Int8(x) => Builder::Int8(*x),
+            Builder::Int16(x) => Builder::Int16(*x),
+            Builder::Int32(x) => Builder::Int32(*x),
+            Builder::Int64(x) => Builder::Int64(*x),
+            Builder::UInt8(x) => Builder::UInt8(*x),
+            Builder::UInt16(x) => Builder::UInt16(*x),
+            Builder::UInt32(x) => Builder::UInt32(*x),
+            Builder::UInt64(x) => Builder::UInt64(*x),
+            Builder::Float32(x) => Builder::Float32(*x),
+            Builder::Float64(x) => Builder::Float64(*x),
+            Builder::Enum(e) => Builder::Enum(*e),
+            Builder::Text(t) => Builder::Text(t.reborrow()),
+            Builder::Data(d) => Builder::Data(d),
+            Builder::Struct(ref mut s) => Builder::Struct(s.reborrow()),
+            Builder::List(ref mut l) => Builder::List(l.reborrow()),
+            Builder::AnyPointer(ref mut a) => Builder::AnyPointer(a.reborrow()),
+            Builder::Capability(c) => Builder::Capability(*c),
+        }
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        match self {
+            Builder::Void => Reader::Void,
+            Builder::Bool(b) => Reader::Bool(b),
+            Builder::Int8(x) => Reader::Int8(x),
+            Builder::Int16(x) => Reader::Int16(x),
+            Builder::Int32(x) => Reader::Int32(x),
+            Builder::Int64(x) => Reader::Int64(x),
+            Builder::UInt8(x) => Reader::UInt8(x),
+            Builder::UInt16(x) => Reader::UInt16(x),
+            Builder::UInt32(x) => Reader::UInt32(x),
+            Builder::UInt64(x) => Reader::UInt64(x),
+            Builder::Float32(x) => Reader::Float32(x),
+            Builder::Float64(x) => Reader::Float64(x),
+            Builder::Enum(e) => Reader::Enum(e),
+            Builder::Text(t) => Reader::Text(t.into_reader()),
+            Builder::Data(d) => Reader::Data(d),
+            Builder::Struct(s) => Reader::Struct(s.into_reader()),
+            Builder::List(l) => Reader::List(l.into_reader()),
+            Builder::AnyPointer(a) => Reader::AnyPointer(a.into_reader()),
+            Builder::Capability(c) => Reader::Capability(c),
+        }
+    }
+
+    /// Downcasts the `Reader` into a more specific type. Panics if the
+    /// expected type does not match the value.
+    pub fn downcast<T: DowncastBuilder<'a>>(self) -> T {
+        T::downcast_builder(self)
+    }
+}
+
+/// Helper trait for the `dynamic_value::Builder::downcast()` method.
+pub trait DowncastBuilder<'a> {
+    fn downcast_builder(v: Builder<'a>) -> Self;
+}
+
+impl<'a> DowncastBuilder<'a> for () {
+    fn downcast_builder(value: Builder<'a>) {
+        let Builder::Void = value else {
+            panic!("error downcasting to void")
+        };
+    }
+}
+
+macro_rules! downcast_builder_impl(
+    ($t:ty, $v:ident, $s:expr) => (
+        impl <'a> DowncastBuilder<'a> for $t {
+            fn downcast_builder(value: Builder<'a>) -> Self {
+                let Builder::$v(x) = value else { panic!("error downcasting to {}", $s) };
+                x
+            }
+        }
+    )
+);
+
+downcast_builder_impl!(bool, Bool, "bool");
+downcast_builder_impl!(i8, Int8, "i8");
+downcast_builder_impl!(i16, Int16, "i16");
+downcast_builder_impl!(i32, Int32, "i32");
+downcast_builder_impl!(i64, Int64, "i64");
+downcast_builder_impl!(u8, UInt8, "u8");
+downcast_builder_impl!(u16, UInt16, "u16");
+downcast_builder_impl!(u32, UInt32, "u32");
+downcast_builder_impl!(u64, UInt64, "u64");
+downcast_builder_impl!(f32, Float32, "f32");
+downcast_builder_impl!(f64, Float64, "f64");
+downcast_builder_impl!(Enum, Enum, "enum");
+downcast_builder_impl!(crate::text::Builder<'a>, Text, "text");
+downcast_builder_impl!(crate::data::Builder<'a>, Data, "data");
+downcast_builder_impl!(dynamic_list::Builder<'a>, List, "list");
+downcast_builder_impl!(dynamic_struct::Builder<'a>, Struct, "struct");
+downcast_builder_impl!(crate::any_pointer::Builder<'a>, AnyPointer, "anypointer");
+
+/// A dynamically-typed enum value.
+#[derive(Clone, Copy)]
+pub struct Enum {
+    value: u16,
+    schema: crate::schema::EnumSchema,
+}
+
+impl Enum {
+    pub fn new(value: u16, schema: crate::schema::EnumSchema) -> Self {
+        Self { value, schema }
+    }
+
+    /// Gets the u16 representation of this value.
+    pub fn get_value(&self) -> u16 {
+        self.value
+    }
+
+    /// Gets the schema of this enumerant.
+    pub fn get_enumerant(self) -> crate::Result<Option<crate::schema::Enumerant>> {
+        let enumerants = self.schema.get_enumerants()?;
+        if (self.value) < enumerants.len() {
+            Ok(Some(enumerants.get(self.value)))
+        } else {
+            Ok(None)
+        }
+    }
+}
+
+impl<'a> From<Enum> for Reader<'a> {
+    fn from(e: Enum) -> Reader<'a> {
+        Reader::Enum(e)
+    }
+}
+
+impl<'a> From<Enum> for Builder<'a> {
+    fn from(e: Enum) -> Builder<'a> {
+        Builder::Enum(e)
+    }
+}
+
+/// A dynamic capability. Currently, this is just a stub and does not support calling
+/// of methods.
+#[derive(Clone, Copy)]
+pub struct Capability;
+
+impl<'a> From<Capability> for Reader<'a> {
+    fn from(c: Capability) -> Reader<'a> {
+        Reader::Capability(c)
+    }
+}
+
+impl<'a> From<Capability> for Builder<'a> {
+    fn from(c: Capability) -> Builder<'a> {
+        Builder::Capability(c)
+    }
+}
diff --git a/rust/capnp/enum_list.rs b/rust/capnp/enum_list.rs
new file mode 100644
index 000000000000..8fa713029250
--- /dev/null
+++ b/rust/capnp/enum_list.rs
@@ -0,0 +1,237 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of enums.
+
+use crate::private::layout::{
+    ListBuilder, ListReader, PointerBuilder, PointerReader, PrimitiveElement, TwoBytes,
+};
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::{NotInSchema, Result};
+
+use core::marker::PhantomData;
+
+#[derive(Clone, Copy)]
+pub struct Owned<T> {
+    marker: PhantomData<T>,
+}
+
+impl<T> crate::introspect::Introspect for Owned<T>
+where
+    T: crate::introspect::Introspect,
+{
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::Type::list_of(T::introspect())
+    }
+}
+
+impl<T> crate::traits::Owned for Owned<T>
+where
+    T: TryFrom<u16, Error = NotInSchema> + crate::introspect::Introspect,
+{
+    type Reader<'a> = Reader<'a, T>;
+    type Builder<'a> = Builder<'a, T>;
+}
+
+#[derive(Clone, Copy)]
+pub struct Reader<'a, T> {
+    marker: PhantomData<T>,
+    reader: ListReader<'a>,
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema>> Reader<'a, T> {
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a, T>, ::core::result::Result<T, NotInSchema>> {
+        let l = self.len();
+        ListIter::new(self, l)
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema>> FromPointerReader<'a> for Reader<'a, T> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a, T>> {
+        Ok(Reader {
+            reader: reader.get_list(TwoBytes, default)?,
+            marker: PhantomData,
+        })
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema>>
+    IndexMove<u32, ::core::result::Result<T, NotInSchema>> for Reader<'a, T>
+{
+    fn index_move(&self, index: u32) -> ::core::result::Result<T, NotInSchema> {
+        self.get(index)
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema>> Reader<'a, T> {
+    /// Gets the `T` at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(&self, index: u32) -> ::core::result::Result<T, NotInSchema> {
+        assert!(index < self.len());
+        let result: u16 = PrimitiveElement::get(&self.reader, index);
+        result.try_into()
+    }
+
+    /// Gets the `T` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(&self, index: u32) -> Option<::core::result::Result<T, NotInSchema>> {
+        if index < self.len() {
+            let result: u16 = PrimitiveElement::get(&self.reader, index);
+            Some(result.try_into())
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> crate::traits::IntoInternalListReader<'a> for Reader<'a, T>
+where
+    T: PrimitiveElement,
+{
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a, T> {
+    marker: PhantomData<T>,
+    builder: ListBuilder<'a>,
+}
+
+impl<'a, T: Into<u16> + TryFrom<u16, Error = NotInSchema>> Builder<'a, T> {
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a, T> {
+        Reader {
+            reader: self.builder.into_reader(),
+            marker: PhantomData,
+        }
+    }
+
+    pub fn set(&mut self, index: u32, value: T) {
+        assert!(index < self.len());
+        PrimitiveElement::set(&self.builder, index, value.into());
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema>> FromPointerBuilder<'a> for Builder<'a, T> {
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a, T> {
+        Builder {
+            builder: builder.init_list(TwoBytes, size),
+            marker: PhantomData,
+        }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a, T>> {
+        Ok(Builder {
+            builder: builder.get_list(TwoBytes, default)?,
+            marker: PhantomData,
+        })
+    }
+}
+
+impl<'a, T: Into<u16> + TryFrom<u16, Error = NotInSchema>> Builder<'a, T> {
+    /// Gets the `T` at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(&self, index: u32) -> ::core::result::Result<T, NotInSchema> {
+        assert!(index < self.len());
+        let result: u16 = PrimitiveElement::get_from_builder(&self.builder, index);
+        result.try_into()
+    }
+
+    /// Gets the `T` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(&self, index: u32) -> Option<::core::result::Result<T, NotInSchema>> {
+        if index < self.len() {
+            let result: u16 = PrimitiveElement::get_from_builder(&self.builder, index);
+            Some(result.try_into())
+        } else {
+            None
+        }
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_, T> {
+        Builder {
+            builder: self.builder.reborrow(),
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<'a, T> crate::traits::SetPointerBuilder for Reader<'a, T> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a, T>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema>> ::core::iter::IntoIterator for Reader<'a, T> {
+    type Item = ::core::result::Result<T, NotInSchema>;
+    type IntoIter = ListIter<Reader<'a, T>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema> + crate::introspect::Introspect> From<Reader<'a, T>>
+    for crate::dynamic_value::Reader<'a>
+{
+    fn from(t: Reader<'a, T>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader::new(
+            t.reader,
+            T::introspect(),
+        ))
+    }
+}
+
+impl<'a, T: TryFrom<u16, Error = NotInSchema> + crate::introspect::Introspect> From<Builder<'a, T>>
+    for crate::dynamic_value::Builder<'a>
+{
+    fn from(t: Builder<'a, T>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder::new(
+            t.builder,
+            T::introspect(),
+        ))
+    }
+}
diff --git a/rust/capnp/introspect.rs b/rust/capnp/introspect.rs
new file mode 100644
index 000000000000..d994b180c93a
--- /dev/null
+++ b/rust/capnp/introspect.rs
@@ -0,0 +1,282 @@
+//! Traits and types to support run-time type introspection, i.e. reflection.
+
+use crate::private::layout::ElementSize;
+
+/// A type that supports reflection. All types that can appear in a Cap'n Proto message
+/// implement this trait.
+pub trait Introspect {
+    /// Retrieves a description of the type.
+    fn introspect() -> Type;
+}
+
+/// A description of a Cap'n Proto type. The representation is
+/// optimized to avoid heap allocation.
+///
+/// To examine a `Type`, you should call the `which()` method.
+#[derive(Copy, Clone, PartialEq, Eq)]
+pub struct Type {
+    /// The type, minus any outer `List( )`.
+    base: BaseType,
+
+    /// How many times `base` is wrapped in `List( )`.
+    list_count: usize,
+}
+
+impl Type {
+    /// Constructs a new `Type` that is not a list.
+    fn new_base(base: BaseType) -> Self {
+        Self {
+            base,
+            list_count: 0,
+        }
+    }
+
+    /// Constructs a new `Type` that is a list wrapping some other `Type`.
+    pub fn list_of(mut element_type: Type) -> Self {
+        element_type.list_count += 1;
+        element_type
+    }
+
+    /// Unfolds a single layer of the `Type`, to allow for pattern matching.
+    pub fn which(&self) -> TypeVariant {
+        if self.list_count > 0 {
+            TypeVariant::List(Type {
+                base: self.base,
+                list_count: self.list_count - 1,
+            })
+        } else {
+            match self.base {
+                BaseType::Void => TypeVariant::Void,
+                BaseType::Bool => TypeVariant::Bool,
+                BaseType::Int8 => TypeVariant::Int8,
+                BaseType::Int16 => TypeVariant::Int16,
+                BaseType::Int32 => TypeVariant::Int32,
+                BaseType::Int64 => TypeVariant::Int64,
+                BaseType::UInt8 => TypeVariant::UInt8,
+                BaseType::UInt16 => TypeVariant::UInt16,
+                BaseType::UInt32 => TypeVariant::UInt32,
+                BaseType::UInt64 => TypeVariant::UInt64,
+                BaseType::Float32 => TypeVariant::Float32,
+                BaseType::Float64 => TypeVariant::Float64,
+                BaseType::Text => TypeVariant::Text,
+                BaseType::Data => TypeVariant::Data,
+                BaseType::Enum(re) => TypeVariant::Enum(re),
+                BaseType::Struct(rs) => TypeVariant::Struct(rs),
+                BaseType::AnyPointer => TypeVariant::AnyPointer,
+                BaseType::Capability => TypeVariant::Capability,
+            }
+        }
+    }
+
+    /// If this type T appears as List(T), then what is the expected
+    /// element size of the list?
+    pub(crate) fn expected_element_size(&self) -> ElementSize {
+        if self.list_count > 0 {
+            ElementSize::Pointer
+        } else {
+            match self.base {
+                BaseType::Void => ElementSize::Void,
+                BaseType::Bool => ElementSize::Bit,
+                BaseType::Int8 | BaseType::UInt8 => ElementSize::Byte,
+                BaseType::Int16 | BaseType::UInt16 | BaseType::Enum(_) => ElementSize::TwoBytes,
+                BaseType::Int32 | BaseType::UInt32 | BaseType::Float32 => ElementSize::FourBytes,
+                BaseType::Int64 | BaseType::UInt64 | BaseType::Float64 => ElementSize::EightBytes,
+                BaseType::Text | BaseType::Data | BaseType::AnyPointer | BaseType::Capability => {
+                    ElementSize::Pointer
+                }
+                BaseType::Struct(_) => ElementSize::InlineComposite,
+            }
+        }
+    }
+
+    /// Is the `Type` a pointer type?
+    pub fn is_pointer_type(&self) -> bool {
+        if self.list_count > 0 {
+            true
+        } else {
+            matches!(
+                self.base,
+                BaseType::Text
+                    | BaseType::Data
+                    | BaseType::AnyPointer
+                    | BaseType::Struct(_)
+                    | BaseType::Capability
+            )
+        }
+    }
+}
+
+#[derive(Copy, Clone, PartialEq, Eq)]
+/// A `Type` unfolded one level. Suitable for pattern matching. Can be trivially
+/// converted to `Type` via the `From`/`Into` traits.
+pub enum TypeVariant {
+    Void,
+    Bool,
+    Int8,
+    Int16,
+    Int32,
+    Int64,
+    UInt8,
+    UInt16,
+    UInt32,
+    UInt64,
+    Float32,
+    Float64,
+    Text,
+    Data,
+    Struct(RawBrandedStructSchema),
+    AnyPointer,
+    Capability,
+    Enum(RawEnumSchema),
+    List(Type),
+}
+
+impl From<TypeVariant> for Type {
+    fn from(tv: TypeVariant) -> Type {
+        match tv {
+            TypeVariant::Void => Type::new_base(BaseType::Void),
+            TypeVariant::Bool => Type::new_base(BaseType::Bool),
+            TypeVariant::Int8 => Type::new_base(BaseType::Int8),
+            TypeVariant::Int16 => Type::new_base(BaseType::Int16),
+            TypeVariant::Int32 => Type::new_base(BaseType::Int32),
+            TypeVariant::Int64 => Type::new_base(BaseType::Int64),
+            TypeVariant::UInt8 => Type::new_base(BaseType::UInt8),
+            TypeVariant::UInt16 => Type::new_base(BaseType::UInt16),
+            TypeVariant::UInt32 => Type::new_base(BaseType::UInt32),
+            TypeVariant::UInt64 => Type::new_base(BaseType::UInt64),
+            TypeVariant::Float32 => Type::new_base(BaseType::Float32),
+            TypeVariant::Float64 => Type::new_base(BaseType::Float64),
+            TypeVariant::Text => Type::new_base(BaseType::Text),
+            TypeVariant::Data => Type::new_base(BaseType::Data),
+            TypeVariant::Struct(rbs) => Type::new_base(BaseType::Struct(rbs)),
+            TypeVariant::AnyPointer => Type::new_base(BaseType::AnyPointer),
+            TypeVariant::Capability => Type::new_base(BaseType::Capability),
+            TypeVariant::Enum(es) => Type::new_base(BaseType::Enum(es)),
+            TypeVariant::List(list) => Type::list_of(list),
+        }
+    }
+}
+
+/// A Cap'n Proto type, excluding `List`.
+#[derive(Copy, Clone, PartialEq, Eq, Debug)]
+enum BaseType {
+    Void,
+    Bool,
+    Int8,
+    Int16,
+    Int32,
+    Int64,
+    UInt8,
+    UInt16,
+    UInt32,
+    UInt64,
+    Float32,
+    Float64,
+    Text,
+    Data,
+    Struct(RawBrandedStructSchema),
+    AnyPointer,
+    Capability,
+    Enum(RawEnumSchema),
+}
+
+macro_rules! primitive_introspect(
+    ($t:ty, $v:ident) => (
+        impl Introspect for $t {
+            fn introspect() -> Type { Type::new_base(BaseType::$v) }
+        }
+    )
+);
+
+primitive_introspect!((), Void);
+primitive_introspect!(bool, Bool);
+primitive_introspect!(i8, Int8);
+primitive_introspect!(i16, Int16);
+primitive_introspect!(i32, Int32);
+primitive_introspect!(i64, Int64);
+primitive_introspect!(u8, UInt8);
+primitive_introspect!(u16, UInt16);
+primitive_introspect!(u32, UInt32);
+primitive_introspect!(u64, UInt64);
+primitive_introspect!(f32, Float32);
+primitive_introspect!(f64, Float64);
+
+/// Type information that gets included in the generated code for every
+/// user-defined Cap'n Proto struct.
+#[derive(Copy, Clone)]
+pub struct RawStructSchema {
+    /// The Node (as defined in schema.capnp), as a single segment message.
+    pub encoded_node: &'static [crate::Word],
+
+    /// Indices (not ordinals) of fields that don't have a discriminant value.
+    pub nonunion_members: &'static [u16],
+
+    /// Map from discriminant value to field index.
+    pub members_by_discriminant: &'static [u16],
+    //
+    // TODO: members_by_name, allowing fast field lookup by name.
+}
+
+/// A RawStructSchema with branding information, i.e. resolution of type parameters.
+/// To use one of this, you will usually want to convert it to a `schema::StructSchema`,
+/// which can be done via `into()`.
+#[derive(Copy, Clone)]
+pub struct RawBrandedStructSchema {
+    /// The unbranded base schema.
+    pub generic: &'static RawStructSchema,
+
+    /// Map from field index (not ordinal) to Type.
+    pub field_types: fn(u16) -> Type,
+
+    /// Map from (maybe field index, annotation index) to the Type
+    /// of the value held by that annotation.
+    pub annotation_types: fn(Option<u16>, u32) -> Type,
+}
+
+impl core::cmp::PartialEq for RawBrandedStructSchema {
+    fn eq(&self, other: &Self) -> bool {
+        core::ptr::eq(self.generic, other.generic) && self.field_types == other.field_types
+        // don't need to compare annotation_types.
+        // that field is equal iff field_types is.
+    }
+}
+
+impl core::cmp::Eq for RawBrandedStructSchema {}
+
+impl core::fmt::Debug for RawBrandedStructSchema {
+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {
+        write!(
+            f,
+            "RawBrandedStructSchema({:?}, {:?})",
+            self.generic as *const _, self.field_types as *const fn(u16) -> Type
+        )
+    }
+}
+
+/// Type information that gets included in the generated code for every
+/// user-defined Cap'n Proto enum.
+/// To use one of this, you will usually want to convert it to a `schema::EnumSchema`,
+/// which can be done via `into()`.
+#[derive(Clone, Copy)]
+pub struct RawEnumSchema {
+    /// The Node (as defined in schema.capnp), as a single segment message.
+    pub encoded_node: &'static [crate::Word],
+
+    /// Map from (maybe enumerant index, annotation index) to the Type
+    /// of the value held by that annotation.
+    pub annotation_types: fn(Option<u16>, u32) -> Type,
+}
+
+impl core::cmp::PartialEq for RawEnumSchema {
+    fn eq(&self, other: &Self) -> bool {
+        ::core::ptr::eq(self.encoded_node, other.encoded_node)
+    }
+}
+
+impl core::cmp::Eq for RawEnumSchema {}
+
+impl core::fmt::Debug for RawEnumSchema {
+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {
+        write!(f, "RawEnumSchema({:?})", self.encoded_node as *const _)
+    }
+}
diff --git a/rust/capnp/io.rs b/rust/capnp/io.rs
new file mode 100644
index 000000000000..59d149b37c26
--- /dev/null
+++ b/rust/capnp/io.rs
@@ -0,0 +1,202 @@
+//! Custom I/O traits that roughly mirror `std::io::{Read, BufRead, Write}`.
+//! This extra layer of indirection enables support of no-std environments.
+
+use crate::{Error, ErrorKind, Result};
+
+/// A rough approximation of std::io::Read.
+pub trait Read {
+    /// Attempts to read some bytes into `buf` and returns the number of bytes read.
+    /// A return value of Ok(0) means that the end of the stream was reached.
+    ///
+    /// Unlike with std::io::Read, implementations are expected to handle EINTR
+    /// (i.e. std::io::ErrorKind::Interrupted) internally, by looping until either success
+    /// is achieved or some other error is hit.
+    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
+
+    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {
+        while !buf.is_empty() {
+            match self.read(buf)? {
+                0 => break,
+                n => {
+                    let tmp = buf;
+                    buf = &mut tmp[n..];
+                }
+            }
+        }
+        if !buf.is_empty() {
+            Err(Error::from_kind(ErrorKind::FailedToFillTheWholeBuffer))
+        } else {
+            Ok(())
+        }
+    }
+}
+
+/// A rough approximation of std::io::BufRead.
+pub trait BufRead: Read {
+    fn fill_buf(&mut self) -> Result<&[u8]>;
+    fn consume(&mut self, amt: usize);
+}
+
+/// A rough approximation of std::io::Write.
+pub trait Write {
+    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
+}
+
+/// Blanket impls for when `std` is enabled.
+#[cfg(feature = "std")]
+mod std_impls {
+    use crate::io::{BufRead, Read, Write};
+    use crate::Result;
+
+    impl<R> Read for R
+    where
+        R: std::io::Read,
+    {
+        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
+            loop {
+                match std::io::Read::read(self, buf) {
+                    Ok(n) => return Ok(n),
+                    Err(e) if e.kind() == std::io::ErrorKind::Interrupted => {}
+                    Err(e) => return Err(e.into()),
+                }
+            }
+        }
+    }
+
+    impl<R> BufRead for R
+    where
+        R: std::io::BufRead,
+    {
+        fn fill_buf(&mut self) -> Result<&[u8]> {
+            Ok(std::io::BufRead::fill_buf(self)?)
+        }
+        fn consume(&mut self, amt: usize) {
+            std::io::BufRead::consume(self, amt)
+        }
+    }
+
+    impl<W> Write for W
+    where
+        W: std::io::Write,
+    {
+        fn write_all(&mut self, buf: &[u8]) -> Result<()> {
+            std::io::Write::write_all(self, buf)?;
+            Ok(())
+        }
+    }
+}
+
+/// Blanket impls for when `embedded-io` is enabled and `std` is not.
+#[cfg(all(feature = "embedded-io", not(feature = "std")))]
+mod embedded_io_impls {
+    use crate::io::{BufRead, Read, Write};
+    use crate::Result;
+    use embedded_io::Error;
+
+    impl<W: embedded_io::Write> Write for W {
+        fn write_all(&mut self, buf: &[u8]) -> Result<()> {
+            embedded_io::Write::write_all(self, buf).map_err(|e| match e {
+                embedded_io::WriteAllError::WriteZero => {
+                    crate::Error::from_kind(crate::ErrorKind::Failed)
+                }
+                embedded_io::WriteAllError::Other(e) => crate::Error::from_kind(e.kind().into()),
+            })?;
+            Ok(())
+        }
+    }
+
+    impl<R: embedded_io::Read> Read for R {
+        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
+            embedded_io::Read::read(self, buf).map_err(|e| crate::Error::from_kind(e.kind().into()))
+        }
+    }
+
+    impl<R: embedded_io::BufRead + embedded_io::Read> BufRead for R {
+        fn fill_buf(&mut self) -> Result<&[u8]> {
+            embedded_io::BufRead::fill_buf(self)
+                .map_err(|e| crate::Error::from_kind(e.kind().into()))
+        }
+
+        fn consume(&mut self, amt: usize) {
+            embedded_io::BufRead::consume(self, amt)
+        }
+    }
+}
+
+/// Fallback impls, for when neither `std` nor `embedded-io` is enabled.
+#[cfg(not(any(feature = "std", feature = "embedded-io")))]
+mod no_std_impls {
+    use crate::io::{BufRead, Read, Write};
+    use crate::{Error, ErrorKind, Result};
+
+    impl<'a> Write for &'a mut [u8] {
+        fn write_all(&mut self, buf: &[u8]) -> Result<()> {
+            if buf.len() > self.len() {
+                return Err(Error::from_kind(ErrorKind::BufferNotLargeEnough));
+            }
+            let amt = buf.len();
+            let (a, b) = core::mem::take(self).split_at_mut(amt);
+            a.copy_from_slice(buf);
+            *self = b;
+            Ok(())
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    impl Write for alloc::vec::Vec<u8> {
+        fn write_all(&mut self, buf: &[u8]) -> Result<()> {
+            self.extend_from_slice(buf);
+            Ok(())
+        }
+    }
+
+    impl<W: ?Sized> Write for &mut W
+    where
+        W: Write,
+    {
+        fn write_all(&mut self, buf: &[u8]) -> Result<()> {
+            (**self).write_all(buf)
+        }
+    }
+
+    impl<'a> Read for &'a [u8] {
+        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
+            let amt = core::cmp::min(buf.len(), self.len());
+            let (a, b) = self.split_at(amt);
+
+            buf[..amt].copy_from_slice(a);
+            *self = b;
+            Ok(amt)
+        }
+    }
+
+    impl<R: ?Sized> Read for &mut R
+    where
+        R: Read,
+    {
+        fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
+            (**self).read(buf)
+        }
+    }
+
+    impl<'a> BufRead for &'a [u8] {
+        fn fill_buf(&mut self) -> Result<&[u8]> {
+            Ok(*self)
+        }
+        fn consume(&mut self, amt: usize) {
+            *self = &self[amt..]
+        }
+    }
+
+    impl<R: ?Sized> BufRead for &mut R
+    where
+        R: BufRead,
+    {
+        fn fill_buf(&mut self) -> Result<&[u8]> {
+            (**self).fill_buf()
+        }
+        fn consume(&mut self, amt: usize) {
+            (**self).consume(amt)
+        }
+    }
+}
diff --git a/rust/capnp/lib.rs b/rust/capnp/lib.rs
new file mode 100644
index 000000000000..daafc23c19d5
--- /dev/null
+++ b/rust/capnp/lib.rs
@@ -0,0 +1,651 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! # Cap'n Proto Runtime Library
+//!
+//! This crate contains basic facilities for reading and writing
+//! [Cap'n Proto](https://capnproto.org) messages in Rust. It is intended to
+//! be used in conjunction with code generated by the
+//! [capnpc-rust](https://crates.io/crates/capnpc) crate.
+
+#![cfg_attr(feature = "rpc_try", feature(try_trait_v2))]
+#![cfg_attr(not(feature = "std"), no_std)]
+
+#[cfg(feature = "alloc")]
+#[macro_use]
+extern crate alloc;
+
+/// Code generated from
+/// [schema.capnp](https://github.com/capnproto/capnproto/blob/master/c%2B%2B/src/capnp/schema.capnp).
+pub mod schema_capnp;
+
+pub mod any_pointer;
+pub mod any_pointer_list;
+pub mod capability;
+pub mod capability_list;
+pub mod constant;
+pub mod data;
+pub mod data_list;
+pub mod dynamic_list;
+pub mod dynamic_struct;
+pub mod dynamic_value;
+pub mod enum_list;
+pub mod introspect;
+pub mod io;
+pub mod list_list;
+pub mod message;
+pub mod primitive_list;
+pub mod private;
+pub mod raw;
+pub mod schema;
+pub mod serialize;
+pub mod serialize_packed;
+pub(crate) mod stringify;
+pub mod struct_list;
+pub mod text;
+pub mod text_list;
+pub mod traits;
+
+#[cfg(feature = "alloc")]
+use alloc::string::String;
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
+
+///
+/// 8 bytes, aligned to an 8-byte boundary.
+///
+/// Internally, capnproto-rust allocates message buffers using this type,
+/// to guarantee alignment.
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+#[repr(C, align(8))]
+pub struct Word {
+    raw_content: [u8; 8],
+}
+
+///
+/// Constructs a word with the given bytes.
+///
+#[allow(clippy::too_many_arguments)]
+pub const fn word(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8) -> Word {
+    Word {
+        raw_content: [b0, b1, b2, b3, b4, b5, b6, b7],
+    }
+}
+
+impl Word {
+    /// Allocates a vec of `length` words, all set to zero.
+    #[cfg(feature = "alloc")]
+    pub fn allocate_zeroed_vec(length: usize) -> Vec<Self> {
+        vec![word(0, 0, 0, 0, 0, 0, 0, 0); length]
+    }
+
+    pub fn words_to_bytes(words: &[Self]) -> &[u8] {
+        unsafe { core::slice::from_raw_parts(words.as_ptr() as *const u8, words.len() * 8) }
+    }
+
+    pub fn words_to_bytes_mut(words: &mut [Self]) -> &mut [u8] {
+        unsafe { core::slice::from_raw_parts_mut(words.as_mut_ptr() as *mut u8, words.len() * 8) }
+    }
+}
+
+#[cfg(any(feature = "quickcheck", test))]
+impl quickcheck::Arbitrary for Word {
+    fn arbitrary(g: &mut quickcheck::Gen) -> Self {
+        crate::word(
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+            quickcheck::Arbitrary::arbitrary(g),
+        )
+    }
+}
+
+/// Size of a message. Every generated struct has a method `.total_size()` that returns this.
+#[derive(Clone, Copy, Debug, PartialEq)]
+pub struct MessageSize {
+    pub word_count: u64,
+
+    /// Size of the capability table.
+    pub cap_count: u32,
+}
+
+impl core::ops::AddAssign for MessageSize {
+    fn add_assign(&mut self, rhs: Self) {
+        self.word_count += rhs.word_count;
+        self.cap_count += rhs.cap_count;
+    }
+}
+
+/// An enum value or union discriminant that was not found among those defined in a schema.
+#[derive(PartialEq, Eq, Clone, Copy, Debug)]
+pub struct NotInSchema(pub u16);
+
+impl ::core::fmt::Display for NotInSchema {
+    fn fmt(
+        &self,
+        fmt: &mut ::core::fmt::Formatter,
+    ) -> ::core::result::Result<(), ::core::fmt::Error> {
+        write!(
+            fmt,
+            "Enum value or union discriminant {} was not present in the schema.",
+            self.0
+        )
+    }
+}
+
+#[cfg(feature = "std")]
+impl ::std::error::Error for NotInSchema {
+    fn description(&self) -> &str {
+        "Enum value or union discriminant was not present in schema."
+    }
+}
+
+/// Because messages are lazily validated, the return type of any method that reads a pointer field
+/// must be wrapped in a Result.
+pub type Result<T> = ::core::result::Result<T, Error>;
+
+/// Describes an arbitrary error that prevented an operation from completing.
+#[derive(Debug, Clone)]
+pub struct Error {
+    /// The general kind of the error. Code that decides how to respond to an error
+    /// should read only this field in making its decision.
+    pub kind: ErrorKind,
+
+    /// Extra context about error
+    #[cfg(feature = "alloc")]
+    pub extra: String,
+}
+
+/// The general nature of an error. The purpose of this enum is not to describe the error itself,
+/// but rather to describe how the client might want to respond to the error.
+#[derive(Debug, Clone, Copy, PartialEq, Eq)]
+#[non_exhaustive]
+pub enum ErrorKind {
+    /// Something went wrong
+    Failed,
+
+    /// The call failed because of a temporary lack of resources. This could be space resources
+    /// (out of memory, out of disk space) or time resources (request queue overflow, operation
+    /// timed out).
+    ///
+    /// The operation might work if tried again, but it should NOT be repeated immediately as this
+    /// may simply exacerbate the problem.
+    Overloaded,
+
+    /// The call required communication over a connection that has been lost. The callee will need
+    /// to re-establish connections and try again.
+    Disconnected,
+
+    /// The requested method is not implemented. The caller may wish to revert to a fallback
+    /// approach based on other methods.
+    Unimplemented,
+
+    /// Buffer is not large enough
+    BufferNotLargeEnough,
+
+    /// Cannot create a canonical message with a capability
+    CannotCreateACanonicalMessageWithACapability,
+
+    /// Cannot set AnyPointer field to a primitive value
+    CannotSetAnyPointerFieldToAPrimitiveValue,
+
+    /// Don't know how to handle non-STRUCT inline composite.
+    CantHandleNonStructInlineComposite,
+
+    /// Empty buffer
+    EmptyBuffer,
+
+    /// Empty slice
+    EmptySlice,
+
+    /// Enum value or union discriminant {} was not present in schema
+    EnumValueOrUnionDiscriminantNotPresent(NotInSchema),
+
+    /// Called get_writable_{data|text}_pointer() but existing list pointer is not byte-sized.
+    ExistingListPointerIsNotByteSized,
+
+    /// Existing list value is incompatible with expected type.
+    ExistingListValueIsIncompatibleWithExpectedType,
+
+    /// Called get_writable_{data|text|list|struct_list}_pointer() but existing pointer is not a list.
+    ExistingPointerIsNotAList,
+
+    /// Expected a list or blob.
+    ExpectedAListOrBlob,
+
+    /// Expected a pointer list, but got a list of data-only structs
+    ExpectedAPointerListButGotAListOfDataOnlyStructs,
+
+    /// Expected a primitive list, but got a list of pointer-only structs
+    ExpectedAPrimitiveListButGotAListOfPointerOnlyStructs,
+
+    /// failed to fill the whole buffer
+    FailedToFillTheWholeBuffer,
+
+    /// field and default mismatch
+    FieldAndDefaultMismatch,
+
+    /// field not found
+    FieldNotFound,
+
+    /// Found bit list where struct list was expected; upgrading boolean lists to struct lists is no longer supported
+    FoundBitListWhereStructListWasExpected,
+
+    /// Found struct list where bit list was expected.
+    FoundStructListWhereBitListWasExpected,
+
+    /// Cannot represent 4 byte length as `usize`. This may indicate that you are running on 8 or 16 bit platform or message is too large.
+    FourByteLengthTooBigForUSize,
+
+    /// Cannot represent 4 byte segment length as usize. This may indicate that you are running on 8 or 16 bit platform or segment is too large
+    FourByteSegmentLengthTooBigForUSize,
+
+    /// group field but type is not Struct
+    GroupFieldButTypeIsNotStruct,
+
+    /// init() is only valid for struct and AnyPointer fields
+    InitIsOnlyValidForStructAndAnyPointerFields,
+
+    /// initn() is only valid for list, text, or data fields
+    InitnIsOnlyValidForListTextOrDataFields,
+
+    /// InlineComposite list with non-STRUCT elements not supported.
+    InlineCompositeListWithNonStructElementsNotSupported,
+
+    /// InlineComposite list's elements overrun its word count.
+    InlineCompositeListsElementsOverrunItsWordCount,
+
+    /// InlineComposite lists of non-STRUCT type are not supported.
+    InlineCompositeListsOfNonStructTypeAreNotSupported,
+
+    /// Too many or too few segments {segment_count}
+    InvalidNumberOfSegments(usize),
+
+    /// Invalid segment id {id}
+    InvalidSegmentId(u32),
+
+    /// List(AnyPointer) not supported.
+    ListAnyPointerNotSupported,
+
+    /// List(Capability) not supported
+    ListCapabilityNotSupported,
+
+    /// Malformed double-far pointer.
+    MalformedDoubleFarPointer,
+
+    /// Message contains invalid capability pointer.
+    MessageContainsInvalidCapabilityPointer,
+
+    /// Message contains list pointer of non-bytes where data was expected.
+    MessageContainsListPointerOfNonBytesWhereDataWasExpected,
+
+    /// Message contains list pointer of non-bytes where text was expected.
+    MessageContainsListPointerOfNonBytesWhereTextWasExpected,
+
+    /// Message contains list with incompatible element type.
+    MessageContainsListWithIncompatibleElementType,
+
+    /// Message contains non-capability pointer where capability pointer was expected.
+    MessageContainsNonCapabilityPointerWhereCapabilityPointerWasExpected,
+
+    /// Message contains non-struct pointer where struct pointer was expected.
+    MessageContainsNonStructPointerWhereStructPointerWasExpected,
+
+    /// Message contains non-list pointer where data was expected.
+    MessageContainsNonListPointerWhereDataWasExpected,
+
+    /// Message contains non-list pointer where list pointer was expected
+    MessageContainsNonListPointerWhereListPointerWasExpected,
+
+    /// Message contains non-list pointer where text was expected.
+    MessageContainsNonListPointerWhereTextWasExpected,
+
+    /// Message contains null capability pointer.
+    MessageContainsNullCapabilityPointer,
+
+    /// Message contains out-of-bounds pointer,
+    MessageContainsOutOfBoundsPointer,
+
+    /// Message contains text that is not NUL-terminated
+    MessageContainsTextThatIsNotNULTerminated,
+
+    /// Message ends prematurely. Header claimed {header} words, but message only has {body} words,
+    MessageEndsPrematurely(usize, usize),
+
+    /// Message is too deeply nested.
+    MessageIsTooDeeplyNested,
+
+    /// Message is too deeply-nested or contains cycles.
+    MessageIsTooDeeplyNestedOrContainsCycles,
+
+    /// Message was not aligned by 8 bytes boundary. Either ensure that message is properly aligned or compile `capnp` crate with \"unaligned\" feature enabled.
+    MessageNotAlignedBy8BytesBoundary,
+
+    /// Message's size cannot be represented in usize
+    MessageSizeOverflow,
+
+    /// Message is too large
+    MessageTooLarge(usize),
+
+    /// Nesting limit exceeded
+    NestingLimitExceeded,
+
+    /// Not a struct
+    NotAStruct,
+
+    /// Only one of the section pointers is pointing to ourself
+    OnlyOneOfTheSectionPointersIsPointingToOurself,
+
+    /// Packed input did not end cleanly on a segment boundary.
+    PackedInputDidNotEndCleanlyOnASegmentBoundary,
+
+    /// Premature end of file
+    PrematureEndOfFile,
+
+    /// Premature end of packed input.
+    PrematureEndOfPackedInput,
+
+    /// Read limit exceeded
+    ReadLimitExceeded,
+
+    /// setting dynamic capabilities is unsupported
+    SettingDynamicCapabilitiesIsUnsupported,
+
+    /// Struct reader had bitwidth other than 1
+    StructReaderHadBitwidthOtherThan1,
+
+    /// Text blob missing NUL terminator.
+    TextBlobMissingNULTerminator,
+
+    /// Text contains non-utf8 data
+    TextContainsNonUtf8Data(core::str::Utf8Error),
+
+    /// Tried to read from null arena
+    TriedToReadFromNullArena,
+
+    /// type mismatch
+    TypeMismatch,
+
+    /// Detected unaligned segment. You must either ensure all of your segments are 8-byte aligned,
+    /// or you must enable the "unaligned" feature in the capnp crate
+    UnalignedSegment,
+
+    /// Unexpected far pointer
+    UnexepectedFarPointer,
+
+    /// Unknown pointer type.
+    UnknownPointerType,
+}
+
+impl Error {
+    /// Writes to the `extra` field. Does nothing if the "alloc" feature is not enabled.
+    /// This is intended to be used with the `write!()` macro from core.
+    pub fn write_fmt(&mut self, fmt: core::fmt::Arguments<'_>) {
+        #[cfg(feature = "alloc")]
+        {
+            use core::fmt::Write;
+            let _ = self.extra.write_fmt(fmt);
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn failed(description: String) -> Self {
+        Self {
+            extra: description,
+            kind: ErrorKind::Failed,
+        }
+    }
+
+    pub fn from_kind(kind: ErrorKind) -> Self {
+        #[cfg(not(feature = "alloc"))]
+        return Self { kind };
+        #[cfg(feature = "alloc")]
+        return Self {
+            kind,
+            extra: String::new(),
+        };
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn overloaded(description: String) -> Self {
+        Self {
+            extra: description,
+            kind: ErrorKind::Overloaded,
+        }
+    }
+    #[cfg(feature = "alloc")]
+    pub fn disconnected(description: String) -> Self {
+        Self {
+            extra: description,
+            kind: ErrorKind::Disconnected,
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn unimplemented(description: String) -> Self {
+        Self {
+            extra: description,
+            kind: ErrorKind::Unimplemented,
+        }
+    }
+}
+
+#[cfg(feature = "std")]
+impl core::convert::From<::std::io::Error> for Error {
+    fn from(err: ::std::io::Error) -> Self {
+        use std::io;
+        let kind = match err.kind() {
+            io::ErrorKind::TimedOut => ErrorKind::Overloaded,
+            io::ErrorKind::BrokenPipe
+            | io::ErrorKind::ConnectionRefused
+            | io::ErrorKind::ConnectionReset
+            | io::ErrorKind::ConnectionAborted
+            | io::ErrorKind::NotConnected => ErrorKind::Disconnected,
+            _ => ErrorKind::Failed,
+        };
+        #[cfg(feature = "alloc")]
+        return Self {
+            kind,
+            extra: format!("{err}"),
+        };
+        #[cfg(not(feature = "alloc"))]
+        return Self { kind };
+    }
+}
+
+#[cfg(feature = "embedded-io")]
+impl From<embedded_io::ErrorKind> for ErrorKind {
+    fn from(value: embedded_io::ErrorKind) -> Self {
+        match value {
+            embedded_io::ErrorKind::Other => Self::Failed,
+            embedded_io::ErrorKind::NotFound => Self::Failed,
+            embedded_io::ErrorKind::PermissionDenied => Self::Failed,
+            embedded_io::ErrorKind::ConnectionRefused => Self::Failed,
+            embedded_io::ErrorKind::ConnectionReset => Self::Failed,
+            embedded_io::ErrorKind::ConnectionAborted => Self::Failed,
+            embedded_io::ErrorKind::NotConnected => Self::Failed,
+            embedded_io::ErrorKind::AddrInUse => Self::Failed,
+            embedded_io::ErrorKind::AddrNotAvailable => Self::Failed,
+            embedded_io::ErrorKind::BrokenPipe => Self::Failed,
+            embedded_io::ErrorKind::AlreadyExists => Self::Failed,
+            embedded_io::ErrorKind::InvalidInput => Self::Failed,
+            embedded_io::ErrorKind::InvalidData => Self::Failed,
+            embedded_io::ErrorKind::TimedOut => Self::Failed,
+            embedded_io::ErrorKind::Interrupted => Self::Failed,
+            embedded_io::ErrorKind::Unsupported => Self::Failed,
+            embedded_io::ErrorKind::OutOfMemory => Self::Failed,
+            _ => Self::Failed,
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl core::convert::From<alloc::string::FromUtf8Error> for Error {
+    fn from(err: alloc::string::FromUtf8Error) -> Self {
+        Self::failed(format!("{err}"))
+    }
+}
+
+impl core::convert::From<core::str::Utf8Error> for Error {
+    fn from(err: core::str::Utf8Error) -> Self {
+        Self::from_kind(ErrorKind::TextContainsNonUtf8Data(err))
+    }
+}
+
+impl core::convert::From<NotInSchema> for Error {
+    fn from(e: NotInSchema) -> Self {
+        Self::from_kind(ErrorKind::EnumValueOrUnionDiscriminantNotPresent(e))
+    }
+}
+
+impl core::fmt::Display for ErrorKind {
+    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {
+        match self {
+            Self::Failed => write!(fmt, "Failed"),
+            Self::Overloaded => write!(fmt, "Overloaded"),
+            Self::Disconnected => write!(fmt, "Disconnected"),
+            Self::Unimplemented => write!(fmt, "Unimplemented"),
+            Self::BufferNotLargeEnough => write!(fmt, "buffer is not large enough"),
+            Self::ExistingListPointerIsNotByteSized => write!(fmt, "Called get_writable_{{data|text}}_pointer() but existing list pointer is not byte-sized."),
+            Self::ExistingPointerIsNotAList => write!(fmt, "Called get_writable_{{data|text|list|struct_list}}_pointer() but existing pointer is not a list."),
+            Self::CannotCreateACanonicalMessageWithACapability => write!(fmt, "Cannot create a canonical message with a capability"),
+            Self::FourByteLengthTooBigForUSize => write!(fmt, "Cannot represent 4 byte length as `usize`. This may indicate that you are running on 8 or 16 bit platform or message is too large."),
+            Self::FourByteSegmentLengthTooBigForUSize => write!(fmt, "Cannot represent 4 byte segment length as usize. This may indicate that you are running on 8 or 16 bit platform or segment is too large"),
+            Self::CannotSetAnyPointerFieldToAPrimitiveValue => write!(fmt, "cannot set AnyPointer field to a primitive value"),
+            Self::CantHandleNonStructInlineComposite => write!(fmt, "Don't know how to handle non-STRUCT inline composite."),
+            Self::EmptyBuffer => write!(fmt, "empty buffer"),
+            Self::EmptySlice => write!(fmt, "empty slice"),
+            Self::EnumValueOrUnionDiscriminantNotPresent(val) => write!(fmt, "Enum value or union discriminant {val} was not present in schema"),
+            Self::ExistingListValueIsIncompatibleWithExpectedType => write!(fmt, "Existing list value is incompatible with expected type."),
+            Self::ExpectedAListOrBlob => write!(fmt, "Expected a list or blob."),
+            Self::ExpectedAPointerListButGotAListOfDataOnlyStructs => write!(fmt, "Expected a pointer list, but got a list of data-only structs"),
+            Self::ExpectedAPrimitiveListButGotAListOfPointerOnlyStructs => write!(fmt, "Expected a primitive list, but got a list of pointer-only structs"),
+            Self::FailedToFillTheWholeBuffer => write!(fmt, "failed to fill the whole buffer"),
+            Self::FieldAndDefaultMismatch => write!(fmt, "field and default mismatch"),
+            Self::FieldNotFound => write!(fmt, "field not found"),
+            Self::FoundBitListWhereStructListWasExpected => write!(fmt, "Found bit list where struct list was expected; upgrading boolean lists to struct lists is no longer supported."),
+            Self::FoundStructListWhereBitListWasExpected => write!(fmt, "Found struct list where bit list was expected."),
+            Self::GroupFieldButTypeIsNotStruct => write!(fmt, "group field but type is not Struct"),
+            Self::InitIsOnlyValidForStructAndAnyPointerFields => write!(fmt, "init() is only valid for struct and AnyPointer fields"),
+            Self::InitnIsOnlyValidForListTextOrDataFields => write!(fmt, "initn() is only valid for list, text, or data fields"),
+            Self::InlineCompositeListWithNonStructElementsNotSupported => write!(fmt, "InlineComposite list with non-STRUCT elements not supported."),
+            Self::InlineCompositeListsElementsOverrunItsWordCount => write!(fmt, "InlineComposite list's elements overrun its word count."),
+            Self::InlineCompositeListsOfNonStructTypeAreNotSupported => write!(fmt, "InlineComposite lists of non-STRUCT type are not supported."),
+            Self::InvalidNumberOfSegments(segment_count) => write!(fmt, "Too many or too few segments {segment_count}"),
+            Self::InvalidSegmentId(id) => write!(fmt, "Invalid segment id {id}"),
+            Self::ListAnyPointerNotSupported => write!(fmt, "List(AnyPointer) not supported."),
+            Self::ListCapabilityNotSupported => write!(fmt, "List(Capability) not supported"),
+            Self::MalformedDoubleFarPointer => write!(fmt, "Malformed double-far pointer."),
+            Self::MessageContainsInvalidCapabilityPointer => write!(fmt, "Message contained invalid capability pointer."),
+            Self::MessageContainsListPointerOfNonBytesWhereDataWasExpected => write!(fmt, "Message contains list pointer of non-bytes where data was expected."),
+            Self::MessageContainsListPointerOfNonBytesWhereTextWasExpected => write!(fmt, "Message contains list pointer of non-bytes where text was expected."),
+            Self::MessageContainsListWithIncompatibleElementType => write!(fmt, "Message contains list with incompatible element type."),
+            Self::MessageContainsNonCapabilityPointerWhereCapabilityPointerWasExpected => write!(fmt, "Message contains non-capability pointer where capability pointer was expected."),
+            Self::MessageContainsNonListPointerWhereDataWasExpected => write!(fmt, "Message contains non-list pointer where data was expected."),
+            Self::MessageContainsNonListPointerWhereListPointerWasExpected => write!(fmt, "Message contains non-list pointer where list pointer was expected"),
+            Self::MessageContainsNonListPointerWhereTextWasExpected => write!(fmt, "Message contains non-list pointer where text was expected."),
+            Self::MessageContainsNonStructPointerWhereStructPointerWasExpected => write!(fmt, "Message contains non-struct pointer where struct pointer was expected."),
+            Self::MessageContainsNullCapabilityPointer => write!(fmt, "Message contains null capability pointer."),
+            Self::MessageContainsOutOfBoundsPointer => write!(fmt, "Message contains out-of-bounds pointer"),
+            Self::MessageContainsTextThatIsNotNULTerminated => write!(fmt, "Message contains text that is not NUL-terminated"),
+            Self::MessageEndsPrematurely(header, body) => write!(fmt, "Message ends prematurely. Header claimed {header} words, but message only has {body} words"),
+            Self::MessageIsTooDeeplyNested => write!(fmt, "Message is too deeply nested."),
+            Self::MessageIsTooDeeplyNestedOrContainsCycles => write!(fmt, "Message is too deeply-nested or contains cycles."),
+            Self::MessageSizeOverflow => write!(fmt, "Message's size cannot be represented in usize"),
+            Self::MessageTooLarge(val) => write!(fmt, "Message is too large: {val}"),
+            Self::MessageNotAlignedBy8BytesBoundary => write!(fmt, "Message was not aligned by 8 bytes boundary. Either ensure that message is properly aligned or compile `capnp` crate with \"unaligned\" feature enabled."),
+            Self::NestingLimitExceeded => write!(fmt, "nesting limit exceeded"),
+            Self::NotAStruct => write!(fmt, "not a struct"),
+            Self::OnlyOneOfTheSectionPointersIsPointingToOurself => write!(fmt, "Only one of the section pointers is pointing to ourself"),
+            Self::PackedInputDidNotEndCleanlyOnASegmentBoundary => write!(fmt, "Packed input did not end cleanly on a segment boundary."),
+            Self::PrematureEndOfFile => write!(fmt, "Premature end of file"),
+            Self::PrematureEndOfPackedInput => write!(fmt, "Premature end of packed input."),
+            Self::ReadLimitExceeded => write!(fmt, "Read limit exceeded"),
+            Self::SettingDynamicCapabilitiesIsUnsupported => write!(fmt, "setting dynamic capabilities is unsupported"),
+            Self::StructReaderHadBitwidthOtherThan1 => write!(fmt, "struct reader had bitwidth other than 1"),
+            Self::TextBlobMissingNULTerminator => write!(fmt, "Text blob missing NUL terminator."),
+            Self::TextContainsNonUtf8Data(e) => write!(fmt, "Text contains non-utf8 data: {e}"),
+            Self::TriedToReadFromNullArena => write!(fmt, "Tried to read from null arena"),
+            Self::TypeMismatch => write!(fmt, "type mismatch"),
+            Self::UnalignedSegment => write!(fmt, "Detected unaligned segment. You must either ensure all of your segments are 8-byte aligned, or you must enable the \"unaligned\" feature in the capnp crate"),
+            Self::UnexepectedFarPointer => write!(fmt, "Unexpected far pointer"),
+            Self::UnknownPointerType => write!(fmt, "Unknown pointer type."),
+        }
+    }
+}
+
+impl core::fmt::Display for Error {
+    fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {
+        #[cfg(feature = "alloc")]
+        let result = if self.extra.is_empty() {
+            write!(fmt, "{}", self.kind)
+        } else {
+            write!(fmt, "{}: {}", self.kind, self.extra)
+        };
+        #[cfg(not(feature = "alloc"))]
+        let result = write!(fmt, "{}", self.kind);
+        result
+    }
+}
+
+#[cfg(feature = "std")]
+impl ::std::error::Error for Error {
+    #[cfg(feature = "alloc")]
+    fn description(&self) -> &str {
+        &self.extra
+    }
+    fn cause(&self) -> Option<&dyn (::std::error::Error)> {
+        None
+    }
+}
+
+/// Helper struct that allows `MessageBuilder::get_segments_for_output()` to avoid heap allocations
+/// in the single-segment case.
+#[cfg(feature = "alloc")]
+pub enum OutputSegments<'a> {
+    SingleSegment([&'a [u8]; 1]),
+    MultiSegment(Vec<&'a [u8]>),
+}
+
+#[cfg(feature = "alloc")]
+impl<'a> core::ops::Deref for OutputSegments<'a> {
+    type Target = [&'a [u8]];
+    fn deref(&self) -> &[&'a [u8]] {
+        match self {
+            OutputSegments::SingleSegment(s) => s,
+            OutputSegments::MultiSegment(v) => v,
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<'s> message::ReaderSegments for OutputSegments<'s> {
+    fn get_segment(&self, id: u32) -> Option<&[u8]> {
+        match self {
+            OutputSegments::SingleSegment(s) => s.get(id as usize).copied(),
+            OutputSegments::MultiSegment(v) => v.get(id as usize).copied(),
+        }
+    }
+}
diff --git a/rust/capnp/list_list.rs b/rust/capnp/list_list.rs
new file mode 100644
index 000000000000..7c31560958d3
--- /dev/null
+++ b/rust/capnp/list_list.rs
@@ -0,0 +1,296 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of lists.
+
+use crate::introspect;
+use crate::private::layout::{ListBuilder, ListReader, Pointer, PointerBuilder, PointerReader};
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Clone, Copy)]
+pub struct Owned<T>
+where
+    T: crate::traits::Owned,
+{
+    marker: ::core::marker::PhantomData<T>,
+}
+
+impl<T> introspect::Introspect for Owned<T>
+where
+    T: introspect::Introspect + crate::traits::Owned,
+{
+    fn introspect() -> introspect::Type {
+        introspect::Type::list_of(T::introspect())
+    }
+}
+
+impl<T> crate::traits::Owned for Owned<T>
+where
+    T: crate::traits::Owned,
+{
+    type Reader<'a> = Reader<'a, T>;
+    type Builder<'a> = Builder<'a, T>;
+}
+
+pub struct Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    marker: ::core::marker::PhantomData<T::Reader<'a>>,
+    reader: ListReader<'a>,
+}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a, T>, Result<T::Reader<'a>>> {
+        ListIter::new(self, self.len())
+    }
+}
+
+impl<'a, T> Clone for Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    fn clone(&self) -> Reader<'a, T> {
+        *self
+    }
+}
+
+impl<'a, T> Copy for Reader<'a, T> where T: crate::traits::Owned {}
+
+impl<'a, T> IndexMove<u32, Result<T::Reader<'a>>> for Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    fn index_move(&self, index: u32) -> Result<T::Reader<'a>> {
+        self.get(index)
+    }
+}
+
+impl<'a, T> FromPointerReader<'a> for Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a, T>> {
+        Ok(Reader {
+            reader: reader.get_list(Pointer, default)?,
+            marker: ::core::marker::PhantomData,
+        })
+    }
+}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> Result<T::Reader<'a>> {
+        assert!(index < self.len());
+        FromPointerReader::get_from_pointer(&self.reader.get_pointer_element(index), None)
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<T::Reader<'a>>> {
+        if index < self.len() {
+            Some(FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_element(index),
+                None,
+            ))
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> crate::traits::IntoInternalListReader<'a> for Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    marker: ::core::marker::PhantomData<T>,
+    builder: ListBuilder<'a>,
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a, T> {
+        Reader {
+            reader: self.builder.into_reader(),
+            marker: ::core::marker::PhantomData,
+        }
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    pub fn init(self, index: u32, size: u32) -> T::Builder<'a> {
+        FromPointerBuilder::init_pointer(self.builder.get_pointer_element(index), size)
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    pub fn reborrow(&mut self) -> Builder<'_, T> {
+        Builder {
+            builder: self.builder.reborrow(),
+            marker: ::core::marker::PhantomData,
+        }
+    }
+}
+
+impl<'a, T> FromPointerBuilder<'a> for Builder<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a, T> {
+        Builder {
+            marker: ::core::marker::PhantomData,
+            builder: builder.init_list(Pointer, size),
+        }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a, T>> {
+        Ok(Builder {
+            marker: ::core::marker::PhantomData,
+            builder: builder.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> Result<T::Builder<'a>> {
+        assert!(index < self.len());
+        FromPointerBuilder::get_from_pointer(self.builder.get_pointer_element(index), None)
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<T::Builder<'a>>> {
+        if index < self.len() {
+            Some(FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_element(index),
+                None,
+            ))
+        } else {
+            None
+        }
+    }
+
+    pub fn set<'b>(&mut self, index: u32, value: T::Reader<'a>) -> Result<()>
+    where
+        T::Reader<'a>: crate::traits::IntoInternalListReader<'b>,
+    {
+        use crate::traits::IntoInternalListReader;
+        assert!(index < self.len());
+        self.builder
+            .reborrow()
+            .get_pointer_element(index)
+            .set_list(&value.into_internal_list_reader(), false)
+    }
+}
+
+impl<'a, T> crate::traits::SetPointerBuilder for Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a, T>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
+
+impl<'a, T> ::core::iter::IntoIterator for Reader<'a, T>
+where
+    T: crate::traits::Owned,
+{
+    type Item = Result<T::Reader<'a>>;
+    type IntoIter = ListIter<Reader<'a, T>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a, T: crate::traits::Owned> From<Reader<'a, T>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a, T>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader::new(
+            t.reader,
+            T::introspect(),
+        ))
+    }
+}
+
+impl<'a, T: crate::traits::Owned> From<Builder<'a, T>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a, T>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder::new(
+            t.builder,
+            T::introspect(),
+        ))
+    }
+}
diff --git a/rust/capnp/message.rs b/rust/capnp/message.rs
new file mode 100644
index 000000000000..fe40e0a7c313
--- /dev/null
+++ b/rust/capnp/message.rs
@@ -0,0 +1,878 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Untyped root container for a Cap'n Proto value.
+//!
+//! ## Notes about type specialization
+//! This module provides [TypedReader] and [TypedBuilder] structs which are strongly-typed variants
+//! of [Reader] and [Builder].
+//!
+//! Code autogenerated by capnpc will have an individual module for each of structures and each of
+//! modules will have `Owned` struct which implements [Owned] trait.
+//!
+//! Example from a real auto-generated file:
+//!
+//! ```ignore
+//! pub mod simple_struct {
+//!     #[derive(Copy, Clone)]
+//!     pub struct Owned(());
+//!     impl <'a> ::capnp::traits::Owned<'a> for Owned { type Reader = Reader<'a>; type Builder = Builder<'a>; }
+//!     ....
+//! }
+//! ```
+//!
+//! [TypedReader] and [TypedBuilder] accept generic type parameter `T`. This parameter must be
+//! a corresponding `Owned` type which was auto-generated inside the corresponding module.
+//!
+//! For example, for auto-generated module `crate::test_data::simple_struct` you'd supply
+//! `crate::test_data::simple_struct::Owned` type into [TypedReader]/[TypedBuilder]
+//!
+//! ```ignore
+//! include!(concat!(env!("OUT_DIR"), "/simple_struct_capnp.rs"));
+//!
+//! use capnp::message::{self, TypedBuilder, TypedReader};
+//!
+//! fn main() {
+//!     let mut builder = TypedBuilder::<simple_struct::Owned>::new_default();
+//!     let mut builder_root = builder.init_root();
+//!     builder_root.set_x(10);
+//!     builder_root.set_y(20);
+//!
+//!     let mut buffer = vec![];
+//!     capnp::serialize_packed::write_message(&mut buffer, builder.borrow_inner()).unwrap();
+//!
+//!     let reader = capnp::serialize_packed::read_message(buffer.as_slice(), ReaderOptions::new()).unwrap();
+//!     let typed_reader = TypedReader::<_, simple_struct::Owned>::new(reader);
+//!
+//!     let reader_root = typed_reader.get().unwrap();
+//!     assert_eq!(reader_root.get_x(), 10);
+//!     assert_eq!(reader_root.get_x(), 20);
+//! }
+//!
+//! ```
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
+use core::convert::From;
+
+use crate::any_pointer;
+#[cfg(feature = "alloc")]
+use crate::private::arena::{BuilderArena, BuilderArenaImpl};
+use crate::private::arena::{ReaderArena, ReaderArenaImpl};
+use crate::private::layout;
+use crate::private::units::BYTES_PER_WORD;
+#[cfg(feature = "alloc")]
+use crate::traits::{FromPointerBuilder, SetPointerBuilder};
+use crate::traits::{FromPointerReader, Owned};
+#[cfg(feature = "alloc")]
+use crate::OutputSegments;
+use crate::Result;
+
+/// Options controlling how data is read.
+#[derive(Clone, Copy, Debug)]
+pub struct ReaderOptions {
+    /// Limits how many total (8-byte) words of data are allowed to be traversed. Traversal is counted
+    /// when a new struct or list builder is obtained, e.g. from a get() accessor. This means that
+    /// calling the getter for the same sub-struct multiple times will cause it to be double-counted.
+    /// Once the traversal limit is reached, an error will be reported.
+    ///
+    /// This limit exists for security reasons. It is possible for an attacker to construct a message
+    /// in which multiple pointers point at the same location. This is technically invalid, but hard
+    /// to detect. Using such a message, an attacker could cause a message which is small on the wire
+    /// to appear much larger when actually traversed, possibly exhausting server resources leading to
+    /// denial-of-service.
+    ///
+    /// It makes sense to set a traversal limit that is much larger than the underlying message.
+    /// Together with sensible coding practices (e.g. trying to avoid calling sub-object getters
+    /// multiple times, which is expensive anyway), this should provide adequate protection without
+    /// inconvenience.
+    ///
+    /// A traversal limit of `None` means that no limit is enforced.
+    pub traversal_limit_in_words: Option<usize>,
+
+    /// Limits how deeply nested a message structure can be, e.g. structs containing other structs or
+    /// lists of structs.
+    ///
+    /// Like the traversal limit, this limit exists for security reasons. Since it is common to use
+    /// recursive code to traverse recursive data structures, an attacker could easily cause a stack
+    /// overflow by sending a very-depply-nested (or even cyclic) message, without the message even
+    /// being very large. The default limit of 64 is probably low enough to prevent any chance of
+    /// stack overflow, yet high enough that it is never a problem in practice.
+    pub nesting_limit: i32,
+}
+
+pub const DEFAULT_READER_OPTIONS: ReaderOptions = ReaderOptions {
+    traversal_limit_in_words: Some(8 * 1024 * 1024),
+    nesting_limit: 64,
+};
+
+impl Default for ReaderOptions {
+    fn default() -> Self {
+        DEFAULT_READER_OPTIONS
+    }
+}
+
+impl ReaderOptions {
+    pub fn new() -> Self {
+        DEFAULT_READER_OPTIONS
+    }
+
+    pub fn nesting_limit(&mut self, value: i32) -> &mut Self {
+        self.nesting_limit = value;
+        self
+    }
+
+    pub fn traversal_limit_in_words(&mut self, value: Option<usize>) -> &mut Self {
+        self.traversal_limit_in_words = value;
+        self
+    }
+}
+
+/// An object that manages the buffers underlying a Cap'n Proto message reader.
+pub trait ReaderSegments {
+    /// Gets the segment with index `idx`. Returns `None` if `idx` is out of range.
+    ///
+    /// The segment must be 8-byte aligned or the "unaligned" feature must
+    /// be enabled in the capnp crate. (Otherwise reading the segment will return an error.)
+    ///
+    /// The returned slice is required to point to memory that remains valid until the ReaderSegments
+    /// object is dropped. In safe Rust, it should not be possible to violate this requirement.
+    fn get_segment(&self, idx: u32) -> Option<&[u8]>;
+
+    /// Gets the number of segments.
+    fn len(&self) -> usize {
+        for i in 0.. {
+            if self.get_segment(i as u32).is_none() {
+                return i;
+            }
+        }
+        unreachable!()
+    }
+
+    fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+}
+
+impl<S> ReaderSegments for &S
+where
+    S: ReaderSegments,
+{
+    fn get_segment(&self, idx: u32) -> Option<&[u8]> {
+        (**self).get_segment(idx)
+    }
+
+    fn len(&self) -> usize {
+        (**self).len()
+    }
+}
+
+/// An array of segments.
+pub struct SegmentArray<'a> {
+    segments: &'a [&'a [u8]],
+}
+
+impl<'a> SegmentArray<'a> {
+    pub fn new(segments: &'a [&'a [u8]]) -> SegmentArray<'a> {
+        SegmentArray { segments }
+    }
+}
+
+impl<'b> ReaderSegments for SegmentArray<'b> {
+    fn get_segment(&self, id: u32) -> Option<&[u8]> {
+        self.segments.get(id as usize).copied()
+    }
+
+    fn len(&self) -> usize {
+        self.segments.len()
+    }
+}
+
+impl<'b> ReaderSegments for [&'b [u8]] {
+    fn get_segment(&self, id: u32) -> Option<&[u8]> {
+        self.get(id as usize).copied()
+    }
+
+    fn len(&self) -> usize {
+        self.len()
+    }
+}
+
+/// A container used to read a message.
+pub struct Reader<S>
+where
+    S: ReaderSegments,
+{
+    arena: ReaderArenaImpl<S>,
+}
+
+impl<S> Reader<S>
+where
+    S: ReaderSegments,
+{
+    pub fn new(segments: S, options: ReaderOptions) -> Self {
+        Self {
+            arena: ReaderArenaImpl::new(segments, options),
+        }
+    }
+
+    fn get_root_internal(&self) -> Result<any_pointer::Reader<'_>> {
+        let (segment_start, _seg_len) = self.arena.get_segment(0)?;
+        let pointer_reader = layout::PointerReader::get_root(
+            &self.arena,
+            0,
+            segment_start,
+            self.arena.nesting_limit(),
+        )?;
+        Ok(any_pointer::Reader::new(pointer_reader))
+    }
+
+    /// Gets the root of the message, interpreting it as the given type.
+    pub fn get_root<'a, T: FromPointerReader<'a>>(&'a self) -> Result<T> {
+        self.get_root_internal()?.get_as()
+    }
+
+    pub fn into_segments(self) -> S {
+        self.arena.into_segments()
+    }
+
+    /// Checks whether the message is [canonical](https://capnproto.org/encoding.html#canonicalization).
+    pub fn is_canonical(&self) -> Result<bool> {
+        let (segment_start, seg_len) = self.arena.get_segment(0)?;
+
+        if self.arena.get_segment(1).is_ok() {
+            // TODO(cleanup, apibump): should there be a nicer way to ask the arena how many
+            // segments there are?
+
+            // There is more than one segment, so the message cannot be canonical.
+            return Ok(false);
+        }
+
+        let pointer_reader = layout::PointerReader::get_root(
+            &self.arena,
+            0,
+            segment_start,
+            self.arena.nesting_limit(),
+        )?;
+        let read_head = ::core::cell::Cell::new(unsafe { segment_start.add(BYTES_PER_WORD) });
+        let root_is_canonical = pointer_reader.is_canonical(&read_head)?;
+        let all_words_consumed = (read_head.get() as usize - segment_start as usize)
+            / BYTES_PER_WORD
+            == seg_len as usize;
+        Ok(root_is_canonical && all_words_consumed)
+    }
+
+    /// Gets the [canonical](https://capnproto.org/encoding.html#canonicalization) form
+    /// of this message. Works by copying the message twice. For a canonicalization
+    /// method that only requires one copy, see `message::Builder::set_root_canonical()`.
+    #[cfg(feature = "alloc")]
+    pub fn canonicalize(&self) -> Result<Vec<crate::Word>> {
+        let root = self.get_root_internal()?;
+        let size = root.target_size()?.word_count + 1;
+        let mut message = Builder::new(HeapAllocator::new().first_segment_words(size as u32));
+        message.set_root_canonical(root)?;
+        let output_segments = message.get_segments_for_output();
+        assert_eq!(1, output_segments.len());
+        let output = output_segments[0];
+        assert!((output.len() / BYTES_PER_WORD) as u64 <= size);
+        let mut result = crate::Word::allocate_zeroed_vec(output.len() / BYTES_PER_WORD);
+        crate::Word::words_to_bytes_mut(&mut result[..]).copy_from_slice(output);
+        Ok(result)
+    }
+
+    pub fn into_typed<T: Owned>(self) -> TypedReader<S, T> {
+        TypedReader::new(self)
+    }
+}
+
+/// A message reader whose value is known to be of type `T`.
+/// Please see [module documentation](self) for more info about reader type specialization.
+pub struct TypedReader<S, T>
+where
+    S: ReaderSegments,
+    T: Owned,
+{
+    marker: ::core::marker::PhantomData<T>,
+    message: Reader<S>,
+}
+
+impl<S, T> TypedReader<S, T>
+where
+    S: ReaderSegments,
+    T: Owned,
+{
+    pub fn new(message: Reader<S>) -> Self {
+        Self {
+            marker: ::core::marker::PhantomData,
+            message,
+        }
+    }
+
+    pub fn get(&self) -> Result<T::Reader<'_>> {
+        self.message.get_root()
+    }
+
+    pub fn into_inner(self) -> Reader<S> {
+        self.message
+    }
+}
+
+impl<S, T> From<Reader<S>> for TypedReader<S, T>
+where
+    S: ReaderSegments,
+    T: Owned,
+{
+    fn from(message: Reader<S>) -> Self {
+        Self::new(message)
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A, T> From<Builder<A>> for TypedReader<Builder<A>, T>
+where
+    A: Allocator,
+    T: Owned,
+{
+    fn from(message: Builder<A>) -> Self {
+        let reader = message.into_reader();
+        reader.into_typed()
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A, T> From<TypedBuilder<T, A>> for TypedReader<Builder<A>, T>
+where
+    A: Allocator,
+    T: Owned,
+{
+    fn from(builder: TypedBuilder<T, A>) -> Self {
+        builder.into_reader()
+    }
+}
+
+/// An object that allocates memory for a Cap'n Proto message as it is being built.
+/// Users of capnproto-rust who wish to provide memory in non-standard ways should
+/// implement this trait. Objects implementing this trait are intended to be wrapped
+/// by `capnp::private::BuilderArena`, which handles calling the methods at the appropriate
+/// times, including calling `deallocate_segment()` on drop.
+///
+/// # Safety
+/// Implementions must ensure all of the following:
+///   1. The memory returned by `allocate_segment` is initialized to all zeroes.
+///   2. The memory returned by `allocate_segment` is valid until `deallocate_segment()`
+///      is called on it.
+///   3. The allocated memory does not overlap with other allocated memory.
+///   4. The allocated memory is 8-byte aligned (or the "unaligned" feature is enabled
+///      for the capnp crate).
+pub unsafe trait Allocator {
+    /// Allocates zeroed memory for a new segment, returning a pointer to the start of the segment
+    /// and a u32 indicating the length of the segment in words. The allocated segment must be
+    /// at least `minimum_size` words long (`minimum_size * 8` bytes long). Allocator implementations
+    /// commonly allocate much more than the minimum, to reduce the total number of segments needed.
+    /// A reasonable strategy is to allocate the maximum of `minimum_size` and twice the size of the
+    /// previous segment.
+    fn allocate_segment(&mut self, minimum_size: u32) -> (*mut u8, u32);
+
+    /// Indicates that a segment, previously allocated via allocate_segment(), is no longer in use.
+    /// `word_size` is the length of the segment in words, as returned from `allocate_segment()`.
+    /// `words_used` is always less than or equal to `word_size`, and indicates how many
+    /// words (contiguous from the start of the segment) were possibly written with non-zero values.
+    ///
+    /// # Safety
+    /// Callers must only call this method on a pointer that has previously been been returned
+    /// from `allocate_segment()`, and only once on each such segment. `word_size` must
+    /// equal the word size returned from `allocate_segment()`, and `words_used` must be at
+    /// most `word_size`.
+    unsafe fn deallocate_segment(&mut self, ptr: *mut u8, word_size: u32, words_used: u32);
+}
+
+/// A container used to build a message.
+#[cfg(feature = "alloc")]
+pub struct Builder<A>
+where
+    A: Allocator,
+{
+    arena: BuilderArenaImpl<A>,
+}
+
+#[cfg(feature = "alloc")]
+unsafe impl<A> Send for Builder<A> where A: Send + Allocator {}
+
+#[cfg(feature = "alloc")]
+fn _assert_kinds() {
+    fn _assert_send<T: Send>() {}
+    fn _assert_reader<S: ReaderSegments + Send>() {
+        _assert_send::<Reader<S>>();
+    }
+    fn _assert_builder<A: Allocator + Send>() {
+        _assert_send::<Builder<A>>();
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A> Builder<A>
+where
+    A: Allocator,
+{
+    pub fn new(allocator: A) -> Self {
+        Self {
+            arena: BuilderArenaImpl::new(allocator),
+        }
+    }
+
+    fn get_root_internal(&mut self) -> any_pointer::Builder<'_> {
+        if self.arena.is_empty() {
+            self.arena
+                .allocate_segment(1)
+                .expect("allocate root pointer");
+            self.arena.allocate(0, 1).expect("allocate root pointer");
+        }
+        let (seg_start, _seg_len) = self.arena.get_segment_mut(0);
+        let location: *mut u8 = seg_start;
+        let Self { arena } = self;
+
+        any_pointer::Builder::new(layout::PointerBuilder::get_root(arena, 0, location))
+    }
+
+    /// Initializes the root as a value of the given type.
+    pub fn init_root<'a, T: FromPointerBuilder<'a>>(&'a mut self) -> T {
+        let root = self.get_root_internal();
+        root.init_as()
+    }
+
+    /// Initializes the root as a value of the given list type, with the given length.
+    pub fn initn_root<'a, T: FromPointerBuilder<'a>>(&'a mut self, length: u32) -> T {
+        let root = self.get_root_internal();
+        root.initn_as(length)
+    }
+
+    /// Gets the root, interpreting it as the given type.
+    pub fn get_root<'a, T: FromPointerBuilder<'a>>(&'a mut self) -> Result<T> {
+        let root = self.get_root_internal();
+        root.get_as()
+    }
+
+    pub fn get_root_as_reader<'a, T: FromPointerReader<'a>>(&'a self) -> Result<T> {
+        if self.arena.is_empty() {
+            any_pointer::Reader::new(layout::PointerReader::new_default()).get_as()
+        } else {
+            let (segment_start, _segment_len) = self.arena.get_segment(0)?;
+            let pointer_reader = layout::PointerReader::get_root(
+                self.arena.as_reader(),
+                0,
+                segment_start,
+                0x7fffffff,
+            )?;
+            let root = any_pointer::Reader::new(pointer_reader);
+            root.get_as()
+        }
+    }
+
+    /// Sets the root to a deep copy of the given value.
+    pub fn set_root<From: SetPointerBuilder>(&mut self, value: From) -> Result<()> {
+        let mut root = self.get_root_internal();
+        root.set_as(value)
+    }
+
+    /// Sets the root to a canonicalized version of `value`. If this was the first action taken
+    /// on this `Builder`, then a subsequent call to `get_segments_for_output()` should return
+    /// a single segment, containing the full canonicalized message.
+    pub fn set_root_canonical<From: SetPointerBuilder>(&mut self, value: From) -> Result<()> {
+        if self.arena.is_empty() {
+            self.arena
+                .allocate_segment(1)
+                .expect("allocate root pointer");
+            self.arena.allocate(0, 1).expect("allocate root pointer");
+        }
+        let (seg_start, _seg_len) = self.arena.get_segment_mut(0);
+        let pointer = layout::PointerBuilder::get_root(&mut self.arena, 0, seg_start);
+        SetPointerBuilder::set_pointer_builder(pointer, value, true)?;
+        assert_eq!(self.get_segments_for_output().len(), 1);
+        Ok(())
+    }
+
+    pub fn get_segments_for_output(&self) -> OutputSegments {
+        self.arena.get_segments_for_output()
+    }
+
+    pub fn into_reader(self) -> Reader<Self> {
+        Reader::new(
+            self,
+            ReaderOptions {
+                traversal_limit_in_words: None,
+                nesting_limit: i32::max_value(),
+            },
+        )
+    }
+
+    pub fn into_typed<T: Owned>(self) -> TypedBuilder<T, A> {
+        TypedBuilder::new(self)
+    }
+
+    /// Retrieves the underlying `Allocator`, deallocating all currently-allocated
+    /// segments.
+    pub fn into_allocator(self) -> A {
+        self.arena.into_allocator()
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A> ReaderSegments for Builder<A>
+where
+    A: Allocator,
+{
+    fn get_segment(&self, id: u32) -> Option<&[u8]> {
+        self.get_segments_for_output().get(id as usize).copied()
+    }
+
+    fn len(&self) -> usize {
+        self.get_segments_for_output().len()
+    }
+}
+
+/// Stongly typed variant of the [Builder]
+///
+/// Generic type parameters:
+/// - `T` - type of the capnp message which this builder is specialized on. Please see
+///   [module documentation](self) for more info about builder type specialization.
+/// - `A` - type of allocator
+#[cfg(feature = "alloc")]
+pub struct TypedBuilder<T, A = HeapAllocator>
+where
+    T: Owned,
+    A: Allocator,
+{
+    marker: ::core::marker::PhantomData<T>,
+    message: Builder<A>,
+}
+
+#[cfg(feature = "alloc")]
+impl<T> TypedBuilder<T, HeapAllocator>
+where
+    T: Owned,
+{
+    pub fn new_default() -> Self {
+        Self::new(Builder::new_default())
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<T, A> TypedBuilder<T, A>
+where
+    T: Owned,
+    A: Allocator,
+{
+    pub fn new(message: Builder<A>) -> Self {
+        Self {
+            marker: ::core::marker::PhantomData,
+            message,
+        }
+    }
+
+    pub fn init_root(&mut self) -> T::Builder<'_> {
+        self.message.init_root()
+    }
+
+    pub fn initn_root(&mut self, length: u32) -> T::Builder<'_> {
+        self.message.initn_root(length)
+    }
+
+    pub fn get_root(&mut self) -> Result<T::Builder<'_>> {
+        self.message.get_root()
+    }
+
+    pub fn get_root_as_reader(&self) -> Result<T::Reader<'_>> {
+        self.message.get_root_as_reader()
+    }
+
+    pub fn set_root(&mut self, value: T::Reader<'_>) -> Result<()> {
+        self.message.set_root(value)
+    }
+
+    pub fn into_inner(self) -> Builder<A> {
+        self.message
+    }
+
+    pub fn borrow_inner(&self) -> &Builder<A> {
+        &self.message
+    }
+
+    pub fn borrow_inner_mut(&mut self) -> &mut Builder<A> {
+        &mut self.message
+    }
+
+    pub fn into_reader(self) -> TypedReader<Builder<A>, T> {
+        TypedReader::new(self.message.into_reader())
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<T, A> From<Builder<A>> for TypedBuilder<T, A>
+where
+    T: Owned,
+    A: Allocator,
+{
+    fn from(builder: Builder<A>) -> Self {
+        Self::new(builder)
+    }
+}
+
+/// Standard segment allocator. Allocates each segment via `alloc::alloc::alloc_zeroed()`.
+#[derive(Debug)]
+#[cfg(feature = "alloc")]
+pub struct HeapAllocator {
+    // Minimum number of words in the next allocation.
+    next_size: u32,
+
+    // How to update next_size after an allocation.
+    allocation_strategy: AllocationStrategy,
+
+    // Maximum number of words to allocate.
+    max_segment_words: u32,
+}
+
+#[derive(Clone, Copy, Debug)]
+pub enum AllocationStrategy {
+    /// Allocates the same number of words for each segment, to the extent possible.
+    /// This strategy is primarily useful for testing cross-segment pointers.
+    FixedSize,
+
+    /// Increases segment size by a multiplicative factor for each subsequent segment.
+    GrowHeuristically,
+}
+
+pub const SUGGESTED_FIRST_SEGMENT_WORDS: u32 = 1024;
+pub const SUGGESTED_ALLOCATION_STRATEGY: AllocationStrategy = AllocationStrategy::GrowHeuristically;
+
+#[cfg(feature = "alloc")]
+impl Default for HeapAllocator {
+    fn default() -> Self {
+        Self {
+            next_size: SUGGESTED_FIRST_SEGMENT_WORDS,
+            allocation_strategy: SUGGESTED_ALLOCATION_STRATEGY,
+            max_segment_words: 1 << 29,
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl HeapAllocator {
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    /// Sets the size of the initial segment in words, where 1 word = 8 bytes.
+    pub fn first_segment_words(mut self, value: u32) -> Self {
+        assert!(value <= self.max_segment_words);
+        self.next_size = value;
+        self
+    }
+
+    /// Sets the allocation strategy for segments after the first one.
+    pub fn allocation_strategy(mut self, value: AllocationStrategy) -> Self {
+        self.allocation_strategy = value;
+        self
+    }
+
+    /// Sets the maximum number of words allowed in a single allocation.
+    pub fn max_segment_words(mut self, value: u32) -> Self {
+        assert!(self.next_size <= value);
+        self.max_segment_words = value;
+        self
+    }
+}
+
+#[cfg(feature = "alloc")]
+unsafe impl Allocator for HeapAllocator {
+    fn allocate_segment(&mut self, minimum_size: u32) -> (*mut u8, u32) {
+        let size = core::cmp::max(minimum_size, self.next_size);
+        let layout =
+            alloc::alloc::Layout::from_size_align(size as usize * BYTES_PER_WORD, 8).unwrap();
+        let ptr = unsafe { alloc::alloc::alloc_zeroed(layout) };
+        if ptr.is_null() {
+            alloc::alloc::handle_alloc_error(layout);
+        }
+        match self.allocation_strategy {
+            AllocationStrategy::GrowHeuristically => {
+                if size < self.max_segment_words - self.next_size {
+                    self.next_size += size;
+                } else {
+                    self.next_size = self.max_segment_words;
+                }
+            }
+            AllocationStrategy::FixedSize => {}
+        }
+        (ptr, size)
+    }
+
+    unsafe fn deallocate_segment(&mut self, ptr: *mut u8, word_size: u32, _words_used: u32) {
+        unsafe {
+            alloc::alloc::dealloc(
+                ptr,
+                alloc::alloc::Layout::from_size_align(word_size as usize * BYTES_PER_WORD, 8)
+                    .unwrap(),
+            );
+        }
+        self.next_size = SUGGESTED_FIRST_SEGMENT_WORDS;
+    }
+}
+
+#[cfg(feature = "alloc")]
+#[test]
+fn test_allocate_max() {
+    let allocation_size = 1 << 24;
+    let mut allocator = HeapAllocator::new()
+        .max_segment_words((1 << 25) - 1)
+        .first_segment_words(allocation_size);
+
+    let (a1, s1) = allocator.allocate_segment(allocation_size);
+    let (a2, s2) = allocator.allocate_segment(allocation_size);
+    let (a3, s3) = allocator.allocate_segment(allocation_size);
+
+    assert_eq!(s1, allocation_size);
+
+    // Allocation size tops out at max_segment_words.
+    assert_eq!(s2, allocator.max_segment_words);
+    assert_eq!(s3, allocator.max_segment_words);
+
+    unsafe {
+        allocator.deallocate_segment(a1, s1, 0);
+        allocator.deallocate_segment(a2, s2, 0);
+        allocator.deallocate_segment(a3, s3, 0);
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl Builder<HeapAllocator> {
+    /// Constructs a new `message::Builder<HeapAllocator>` whose first segment has length
+    /// `SUGGESTED_FIRST_SEGMENT_WORDS`.
+    pub fn new_default() -> Self {
+        Self::new(HeapAllocator::new())
+    }
+}
+
+/// An Allocator whose first segment is a backed by a user-provided buffer.
+///
+/// Recall that an `Allocator` implementation must ensure that allocated segments are
+/// initially *zeroed*. `ScratchSpaceHeapAllocator` ensures that is the case by zeroing
+/// the entire buffer upon initial construction, and then zeroing any *potentially used*
+/// part of the buffer upon `deallocate_segment()`.
+///
+/// You can reuse a `ScratchSpaceHeapAllocator` by calling `message::Builder::into_allocator()`,
+/// or by initally passing it to `message::Builder::new()` as a `&mut ScratchSpaceHeapAllocator`.
+/// Such reuse can save significant amounts of zeroing.
+#[cfg(feature = "alloc")]
+pub struct ScratchSpaceHeapAllocator<'a> {
+    scratch_space: &'a mut [u8],
+    scratch_space_allocated: bool,
+    allocator: HeapAllocator,
+}
+
+#[cfg(feature = "alloc")]
+impl<'a> ScratchSpaceHeapAllocator<'a> {
+    /// Writes zeroes into the entire buffer and constructs a new allocator from it.
+    ///
+    /// If the buffer is large, this operation could be relatively expensive. If you want to reuse
+    /// the same scratch space in a later message, you should reuse the entire
+    /// `ScratchSpaceHeapAllocator`, to avoid paying this full cost again.
+    pub fn new(scratch_space: &'a mut [u8]) -> ScratchSpaceHeapAllocator<'a> {
+        #[cfg(not(feature = "unaligned"))]
+        {
+            if scratch_space.as_ptr() as usize % BYTES_PER_WORD != 0 {
+                panic!(
+                    "Scratch space must be 8-byte aligned, or you must enable the \"unaligned\" \
+                        feature in the capnp crate"
+                );
+            }
+        }
+
+        // We need to ensure that the buffer is zeroed.
+        for b in &mut scratch_space[..] {
+            *b = 0;
+        }
+        ScratchSpaceHeapAllocator {
+            scratch_space,
+            scratch_space_allocated: false,
+            allocator: HeapAllocator::new(),
+        }
+    }
+
+    /// Sets the size of the second segment in words, where 1 word = 8 bytes.
+    /// (The first segment is the scratch space passed to `ScratchSpaceHeapAllocator::new()`.
+    pub fn second_segment_words(self, value: u32) -> ScratchSpaceHeapAllocator<'a> {
+        ScratchSpaceHeapAllocator {
+            allocator: self.allocator.first_segment_words(value),
+            ..self
+        }
+    }
+
+    /// Sets the allocation strategy for segments after the second one.
+    pub fn allocation_strategy(self, value: AllocationStrategy) -> ScratchSpaceHeapAllocator<'a> {
+        ScratchSpaceHeapAllocator {
+            allocator: self.allocator.allocation_strategy(value),
+            ..self
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+unsafe impl<'a> Allocator for ScratchSpaceHeapAllocator<'a> {
+    fn allocate_segment(&mut self, minimum_size: u32) -> (*mut u8, u32) {
+        if (minimum_size as usize) < (self.scratch_space.len() / BYTES_PER_WORD)
+            && !self.scratch_space_allocated
+        {
+            self.scratch_space_allocated = true;
+            (
+                self.scratch_space.as_mut_ptr(),
+                (self.scratch_space.len() / BYTES_PER_WORD) as u32,
+            )
+        } else {
+            self.allocator.allocate_segment(minimum_size)
+        }
+    }
+
+    unsafe fn deallocate_segment(&mut self, ptr: *mut u8, word_size: u32, words_used: u32) {
+        if ptr == self.scratch_space.as_mut_ptr() {
+            // Rezero the slice to allow reuse of the allocator. We only need to write
+            // words that we know might contain nonzero values.
+            unsafe {
+                core::ptr::write_bytes(ptr, 0u8, (words_used as usize) * BYTES_PER_WORD);
+            }
+            self.scratch_space_allocated = false;
+        } else {
+            self.allocator
+                .deallocate_segment(ptr, word_size, words_used);
+        }
+    }
+}
+
+#[cfg(feature = "alloc")]
+unsafe impl<'a, A> Allocator for &'a mut A
+where
+    A: Allocator,
+{
+    fn allocate_segment(&mut self, minimum_size: u32) -> (*mut u8, u32) {
+        (*self).allocate_segment(minimum_size)
+    }
+
+    unsafe fn deallocate_segment(&mut self, ptr: *mut u8, word_size: u32, words_used: u32) {
+        (*self).deallocate_segment(ptr, word_size, words_used)
+    }
+}
diff --git a/rust/capnp/primitive_list.rs b/rust/capnp/primitive_list.rs
new file mode 100644
index 000000000000..4ea31a7b50eb
--- /dev/null
+++ b/rust/capnp/primitive_list.rs
@@ -0,0 +1,279 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of primitives.
+
+use core::marker;
+
+use crate::introspect;
+use crate::private::layout::{
+    data_bits_per_element, ListBuilder, ListReader, PointerBuilder, PointerReader, PrimitiveElement,
+};
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Clone, Copy)]
+pub struct Owned<T> {
+    marker: marker::PhantomData<T>,
+}
+
+impl<T> introspect::Introspect for Owned<T>
+where
+    T: introspect::Introspect,
+{
+    fn introspect() -> introspect::Type {
+        introspect::Type::list_of(T::introspect())
+    }
+}
+
+impl<T> crate::traits::Owned for Owned<T>
+where
+    T: PrimitiveElement + introspect::Introspect,
+{
+    type Reader<'a> = Reader<'a, T>;
+    type Builder<'a> = Builder<'a, T>;
+}
+
+#[derive(Clone, Copy)]
+pub struct Reader<'a, T>
+where
+    T: PrimitiveElement,
+{
+    marker: marker::PhantomData<T>,
+    reader: ListReader<'a>,
+}
+
+impl<'a, T: PrimitiveElement> Reader<'a, T> {
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a, T>, T> {
+        let l = self.len();
+        ListIter::new(self, l)
+    }
+}
+
+impl<'a, T: PrimitiveElement> FromPointerReader<'a> for Reader<'a, T> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a, T>> {
+        Ok(Reader {
+            reader: reader.get_list(T::element_size(), default)?,
+            marker: marker::PhantomData,
+        })
+    }
+}
+
+impl<'a, T: PrimitiveElement> IndexMove<u32, T> for Reader<'a, T> {
+    fn index_move(&self, index: u32) -> T {
+        self.get(index)
+    }
+}
+
+impl<'a, T: PrimitiveElement> Reader<'a, T> {
+    /// Gets the `T` at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(&self, index: u32) -> T {
+        assert!(index < self.len());
+        PrimitiveElement::get(&self.reader, index)
+    }
+
+    /// Gets the `T` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(&self, index: u32) -> Option<T> {
+        if index < self.len() {
+            Some(PrimitiveElement::get(&self.reader, index))
+        } else {
+            None
+        }
+    }
+
+    #[cfg(target_endian = "little")]
+    /// Returns something if the slice is as expected in memory.
+    pub fn as_slice(&self) -> Option<&[T]> {
+        if self.reader.get_element_size() == T::element_size() {
+            let bytes = self.reader.into_raw_bytes();
+            Some(unsafe {
+                use core::slice;
+                slice::from_raw_parts(
+                    bytes.as_ptr() as *mut T,
+                    8 * bytes.len() / (data_bits_per_element(T::element_size())) as usize,
+                )
+            })
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> crate::traits::IntoInternalListReader<'a> for Reader<'a, T>
+where
+    T: PrimitiveElement,
+{
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a, T>
+where
+    T: PrimitiveElement,
+{
+    marker: marker::PhantomData<T>,
+    builder: ListBuilder<'a>,
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: PrimitiveElement,
+{
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a, T> {
+        Reader {
+            marker: marker::PhantomData,
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    pub fn set(&mut self, index: u32, value: T) {
+        assert!(index < self.len());
+        PrimitiveElement::set(&self.builder, index, value);
+    }
+
+    #[cfg(target_endian = "little")]
+    pub fn as_slice(&mut self) -> Option<&mut [T]> {
+        if self.builder.get_element_size() == T::element_size() {
+            let bytes = self.builder.into_raw_bytes();
+            Some(unsafe {
+                core::slice::from_raw_parts_mut(
+                    bytes.as_mut_ptr() as *mut T,
+                    8 * bytes.len() / (data_bits_per_element(T::element_size())) as usize,
+                )
+            })
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T: PrimitiveElement> FromPointerBuilder<'a> for Builder<'a, T> {
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a, T> {
+        Builder {
+            builder: builder.init_list(T::element_size(), size),
+            marker: marker::PhantomData,
+        }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a, T>> {
+        Ok(Builder {
+            builder: builder.get_list(T::element_size(), default)?,
+            marker: marker::PhantomData,
+        })
+    }
+}
+
+impl<'a, T: PrimitiveElement> Builder<'a, T> {
+    /// Gets the `T` at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(&self, index: u32) -> T {
+        assert!(index < self.len());
+        PrimitiveElement::get_from_builder(&self.builder, index)
+    }
+
+    /// Gets the `T` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(&self, index: u32) -> Option<T> {
+        if index < self.len() {
+            Some(PrimitiveElement::get_from_builder(&self.builder, index))
+        } else {
+            None
+        }
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_, T> {
+        Builder {
+            marker: marker::PhantomData,
+            builder: self.builder.reborrow(),
+        }
+    }
+}
+
+impl<'a, T> crate::traits::SetPointerBuilder for Reader<'a, T>
+where
+    T: PrimitiveElement,
+{
+    fn set_pointer_builder<'b>(
+        mut pointer: PointerBuilder<'b>,
+        value: Reader<'a, T>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
+
+impl<'a, T> ::core::iter::IntoIterator for Reader<'a, T>
+where
+    T: PrimitiveElement,
+{
+    type Item = T;
+    type IntoIter = ListIter<Reader<'a, T>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a, T: PrimitiveElement + crate::introspect::Introspect> From<Reader<'a, T>>
+    for crate::dynamic_value::Reader<'a>
+{
+    fn from(t: Reader<'a, T>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader::new(
+            t.reader,
+            T::introspect(),
+        ))
+    }
+}
+
+impl<'a, T: PrimitiveElement + crate::introspect::Introspect> From<Builder<'a, T>>
+    for crate::dynamic_value::Builder<'a>
+{
+    fn from(t: Builder<'a, T>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder::new(
+            t.builder,
+            T::introspect(),
+        ))
+    }
+}
diff --git a/rust/capnp/private/arena.rs b/rust/capnp/private/arena.rs
new file mode 100644
index 000000000000..46626c1f0ce3
--- /dev/null
+++ b/rust/capnp/private/arena.rs
@@ -0,0 +1,417 @@
+// Copyright (c) 2013-2017 Sandstorm Development Group, Inc. and contributors
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
+#[cfg(feature = "alloc")]
+use core::slice;
+use core::u64;
+
+use crate::message;
+#[cfg(feature = "alloc")]
+use crate::message::Allocator;
+use crate::message::ReaderSegments;
+use crate::private::read_limiter::ReadLimiter;
+use crate::private::units::*;
+#[cfg(feature = "alloc")]
+use crate::OutputSegments;
+use crate::{Error, ErrorKind, Result};
+
+pub type SegmentId = u32;
+
+pub trait ReaderArena {
+    // return pointer to start of segment, and number of words in that segment
+    fn get_segment(&self, id: u32) -> Result<(*const u8, u32)>;
+
+    unsafe fn check_offset(
+        &self,
+        segment_id: u32,
+        start: *const u8,
+        offset_in_words: i32,
+    ) -> Result<*const u8>;
+    fn contains_interval(&self, segment_id: u32, start: *const u8, size: usize) -> Result<()>;
+    fn amplified_read(&self, virtual_amount: u64) -> Result<()>;
+
+    fn nesting_limit(&self) -> i32;
+
+    // TODO(apibump): Consider putting extract_cap(), inject_cap(), drop_cap() here
+    //   and on message::Reader. Then we could get rid of Imbue and ImbueMut, and
+    //   layout::StructReader, layout::ListReader, etc. could drop their `cap_table` fields.
+}
+
+pub struct ReaderArenaImpl<S> {
+    segments: S,
+    read_limiter: ReadLimiter,
+    nesting_limit: i32,
+}
+
+#[cfg(feature = "sync_reader")]
+fn _assert_sync() {
+    fn _assert_sync<T: Sync>() {}
+    fn _assert_reader<S: ReaderSegments + Sync>() {
+        _assert_sync::<ReaderArenaImpl<S>>();
+    }
+}
+
+impl<S> ReaderArenaImpl<S>
+where
+    S: ReaderSegments,
+{
+    pub fn new(segments: S, options: message::ReaderOptions) -> Self {
+        let limiter = ReadLimiter::new(options.traversal_limit_in_words);
+        Self {
+            segments,
+            read_limiter: limiter,
+            nesting_limit: options.nesting_limit,
+        }
+    }
+
+    pub fn into_segments(self) -> S {
+        self.segments
+    }
+}
+
+impl<S> ReaderArena for ReaderArenaImpl<S>
+where
+    S: ReaderSegments,
+{
+    fn get_segment(&self, id: u32) -> Result<(*const u8, u32)> {
+        match self.segments.get_segment(id) {
+            Some(seg) => {
+                #[cfg(not(feature = "unaligned"))]
+                {
+                    if seg.as_ptr() as usize % BYTES_PER_WORD != 0 {
+                        return Err(Error::from_kind(ErrorKind::UnalignedSegment));
+                    }
+                }
+
+                Ok((seg.as_ptr(), (seg.len() / BYTES_PER_WORD) as u32))
+            }
+            None => Err(Error::from_kind(ErrorKind::InvalidSegmentId(id))),
+        }
+    }
+
+    unsafe fn check_offset(
+        &self,
+        segment_id: u32,
+        start: *const u8,
+        offset_in_words: i32,
+    ) -> Result<*const u8> {
+        let (segment_start, segment_len) = self.get_segment(segment_id)?;
+        let this_start: usize = segment_start as usize;
+        let this_size: usize = segment_len as usize * BYTES_PER_WORD;
+        let offset: i64 = i64::from(offset_in_words) * BYTES_PER_WORD as i64;
+        let start_idx = start as usize;
+        if start_idx < this_start || ((start_idx - this_start) as i64 + offset) as usize > this_size
+        {
+            Err(Error::from_kind(
+                ErrorKind::MessageContainsOutOfBoundsPointer,
+            ))
+        } else {
+            unsafe { Ok(start.offset(offset as isize)) }
+        }
+    }
+
+    fn contains_interval(&self, id: u32, start: *const u8, size_in_words: usize) -> Result<()> {
+        let (segment_start, segment_len) = self.get_segment(id)?;
+        let this_start: usize = segment_start as usize;
+        let this_size: usize = segment_len as usize * BYTES_PER_WORD;
+        let start = start as usize;
+        let size = size_in_words * BYTES_PER_WORD;
+
+        if !(start >= this_start && start - this_start + size <= this_size) {
+            Err(Error::from_kind(
+                ErrorKind::MessageContainsOutOfBoundsPointer,
+            ))
+        } else {
+            self.read_limiter.can_read(size_in_words)
+        }
+    }
+
+    fn amplified_read(&self, virtual_amount: u64) -> Result<()> {
+        self.read_limiter.can_read(virtual_amount as usize)
+    }
+
+    fn nesting_limit(&self) -> i32 {
+        self.nesting_limit
+    }
+}
+
+pub trait BuilderArena: ReaderArena {
+    fn allocate(&mut self, segment_id: u32, amount: WordCount32) -> Option<u32>;
+    fn allocate_anywhere(&mut self, amount: u32) -> (SegmentId, u32);
+    fn get_segment_mut(&mut self, id: u32) -> (*mut u8, u32);
+
+    fn as_reader(&self) -> &dyn ReaderArena;
+}
+
+/// A wrapper around a memory segment used in building a message.
+#[cfg(feature = "alloc")]
+struct BuilderSegment {
+    /// Pointer to the start of the segment.
+    ptr: *mut u8,
+
+    /// Total number of words the segment could potentially use. That is, all
+    /// bytes from `ptr` to `ptr + (capacity * 8)` may be used in the segment.
+    capacity: u32,
+
+    /// Number of words already used in the segment.
+    allocated: u32,
+}
+
+#[cfg(feature = "alloc")]
+pub struct BuilderArenaImplInner<A>
+where
+    A: Allocator,
+{
+    allocator: Option<A>, // None if has already be deallocated.
+
+    // TODO(perf): Try using smallvec to avoid heap allocations in the single-segment case?
+    segments: Vec<BuilderSegment>,
+}
+
+#[cfg(feature = "alloc")]
+pub struct BuilderArenaImpl<A>
+where
+    A: Allocator,
+{
+    inner: BuilderArenaImplInner<A>,
+}
+
+#[cfg(feature = "alloc")]
+impl<A> BuilderArenaImpl<A>
+where
+    A: Allocator,
+{
+    pub fn new(allocator: A) -> Self {
+        Self {
+            inner: BuilderArenaImplInner {
+                allocator: Some(allocator),
+                segments: Vec::new(),
+            },
+        }
+    }
+
+    /// Allocates a new segment with capacity for at least `minimum_size` words.
+    pub fn allocate_segment(&mut self, minimum_size: u32) -> Result<()> {
+        self.inner.allocate_segment(minimum_size)
+    }
+
+    pub fn get_segments_for_output(&self) -> OutputSegments {
+        let reff = &self.inner;
+        if reff.segments.len() == 1 {
+            let seg = &reff.segments[0];
+
+            // The user must mutably borrow the `message::Builder` to be able to modify segment memory.
+            // No such borrow will be possible while `self` is still immutably borrowed from this method,
+            // so returning this slice is safe.
+            let slice = unsafe {
+                slice::from_raw_parts(seg.ptr as *const _, seg.allocated as usize * BYTES_PER_WORD)
+            };
+            OutputSegments::SingleSegment([slice])
+        } else {
+            let mut v = Vec::with_capacity(reff.segments.len());
+            for seg in &reff.segments {
+                // See safety argument in above branch.
+                let slice = unsafe {
+                    slice::from_raw_parts(
+                        seg.ptr as *const _,
+                        seg.allocated as usize * BYTES_PER_WORD,
+                    )
+                };
+                v.push(slice);
+            }
+            OutputSegments::MultiSegment(v)
+        }
+    }
+
+    pub fn len(&self) -> usize {
+        self.inner.segments.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    /// Retrieves the underlying `Allocator`, deallocating all currently-allocated
+    /// segments.
+    pub fn into_allocator(mut self) -> A {
+        self.inner.deallocate_all();
+        self.inner.allocator.take().unwrap()
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A> ReaderArena for BuilderArenaImpl<A>
+where
+    A: Allocator,
+{
+    fn get_segment(&self, id: u32) -> Result<(*const u8, u32)> {
+        let seg = &self.inner.segments[id as usize];
+        Ok((seg.ptr, seg.allocated))
+    }
+
+    unsafe fn check_offset(
+        &self,
+        _segment_id: u32,
+        start: *const u8,
+        offset_in_words: i32,
+    ) -> Result<*const u8> {
+        unsafe { Ok(start.offset((i64::from(offset_in_words) * BYTES_PER_WORD as i64) as isize)) }
+    }
+
+    fn contains_interval(&self, _id: u32, _start: *const u8, _size: usize) -> Result<()> {
+        Ok(())
+    }
+
+    fn amplified_read(&self, _virtual_amount: u64) -> Result<()> {
+        Ok(())
+    }
+
+    fn nesting_limit(&self) -> i32 {
+        0x7fffffff
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A> BuilderArenaImplInner<A>
+where
+    A: Allocator,
+{
+    /// Allocates a new segment with capacity for at least `minimum_size` words.
+    fn allocate_segment(&mut self, minimum_size: WordCount32) -> Result<()> {
+        let seg = match &mut self.allocator {
+            Some(a) => a.allocate_segment(minimum_size),
+            None => unreachable!(),
+        };
+        self.segments.push(BuilderSegment {
+            ptr: seg.0,
+            capacity: seg.1,
+            allocated: 0,
+        });
+        Ok(())
+    }
+
+    fn allocate(&mut self, segment_id: u32, amount: WordCount32) -> Option<u32> {
+        let seg = &mut self.segments[segment_id as usize];
+        if amount > seg.capacity - seg.allocated {
+            None
+        } else {
+            let result = seg.allocated;
+            seg.allocated += amount;
+            Some(result)
+        }
+    }
+
+    fn allocate_anywhere(&mut self, amount: u32) -> (SegmentId, u32) {
+        // first try the existing segments, then try allocating a new segment.
+        let allocated_len = self.segments.len() as u32;
+        for segment_id in 0..allocated_len {
+            if let Some(idx) = self.allocate(segment_id, amount) {
+                return (segment_id, idx);
+            }
+        }
+
+        // Need to allocate a new segment.
+
+        self.allocate_segment(amount).expect("allocate new segment");
+        (
+            allocated_len,
+            self.allocate(allocated_len, amount)
+                .expect("use freshly-allocated segment"),
+        )
+    }
+
+    fn deallocate_all(&mut self) {
+        if let Some(a) = &mut self.allocator {
+            for seg in &self.segments {
+                unsafe {
+                    a.deallocate_segment(seg.ptr, seg.capacity, seg.allocated);
+                }
+            }
+        }
+    }
+
+    fn get_segment_mut(&mut self, id: u32) -> (*mut u8, u32) {
+        let seg = &self.segments[id as usize];
+        (seg.ptr, seg.capacity)
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A> BuilderArena for BuilderArenaImpl<A>
+where
+    A: Allocator,
+{
+    fn allocate(&mut self, segment_id: u32, amount: WordCount32) -> Option<u32> {
+        self.inner.allocate(segment_id, amount)
+    }
+
+    fn allocate_anywhere(&mut self, amount: u32) -> (SegmentId, u32) {
+        self.inner.allocate_anywhere(amount)
+    }
+
+    fn get_segment_mut(&mut self, id: u32) -> (*mut u8, u32) {
+        self.inner.get_segment_mut(id)
+    }
+
+    fn as_reader(&self) -> &dyn ReaderArena {
+        self
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<A> Drop for BuilderArenaImplInner<A>
+where
+    A: Allocator,
+{
+    fn drop(&mut self) {
+        self.deallocate_all()
+    }
+}
+
+pub struct NullArena;
+
+impl ReaderArena for NullArena {
+    fn get_segment(&self, _id: u32) -> Result<(*const u8, u32)> {
+        Err(Error::from_kind(ErrorKind::TriedToReadFromNullArena))
+    }
+
+    unsafe fn check_offset(
+        &self,
+        _segment_id: u32,
+        start: *const u8,
+        offset_in_words: i32,
+    ) -> Result<*const u8> {
+        unsafe { Ok(start.add(offset_in_words as usize * BYTES_PER_WORD)) }
+    }
+
+    fn contains_interval(&self, _id: u32, _start: *const u8, _size: usize) -> Result<()> {
+        Ok(())
+    }
+
+    fn amplified_read(&self, _virtual_amount: u64) -> Result<()> {
+        Ok(())
+    }
+
+    fn nesting_limit(&self) -> i32 {
+        0x7fffffff
+    }
+}
diff --git a/rust/capnp/private/capability.rs b/rust/capnp/private/capability.rs
new file mode 100644
index 000000000000..ba725fb60535
--- /dev/null
+++ b/rust/capnp/private/capability.rs
@@ -0,0 +1,155 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#![cfg(feature = "alloc")]
+use alloc::boxed::Box;
+use alloc::vec::Vec;
+
+use crate::any_pointer;
+use crate::capability::{Params, Promise, RemotePromise, Request, Results};
+use crate::MessageSize;
+
+pub trait ResponseHook {
+    fn get(&self) -> crate::Result<any_pointer::Reader<'_>>;
+}
+
+pub trait RequestHook {
+    fn get(&mut self) -> any_pointer::Builder<'_>;
+    fn get_brand(&self) -> usize;
+    fn send(self: Box<Self>) -> RemotePromise<any_pointer::Owned>;
+    fn tail_send(
+        self: Box<Self>,
+    ) -> Option<(
+        u32,
+        crate::capability::Promise<(), crate::Error>,
+        Box<dyn PipelineHook>,
+    )>;
+}
+
+pub trait ClientHook {
+    fn add_ref(&self) -> Box<dyn ClientHook>;
+    fn new_call(
+        &self,
+        interface_id: u64,
+        method_id: u16,
+        size_hint: Option<MessageSize>,
+    ) -> Request<any_pointer::Owned, any_pointer::Owned>;
+
+    fn call(
+        &self,
+        interface_id: u64,
+        method_id: u16,
+        params: Box<dyn ParamsHook>,
+        results: Box<dyn ResultsHook>,
+    ) -> crate::capability::Promise<(), crate::Error>;
+
+    /// If this capability is associated with an rpc connection, then this method
+    /// returns an identifier for that connection.
+    fn get_brand(&self) -> usize;
+
+    /// Returns a (locally) unique identifier for this capabilitiy.
+    fn get_ptr(&self) -> usize;
+
+    /// If this ClientHook is a promise that has already resolved, returns the inner, resolved version
+    /// of the capability.  The caller may permanently replace this client with the resolved one if
+    /// desired.  Returns null if the client isn't a promise or hasn't resolved yet -- use
+    /// `whenMoreResolved()` to distinguish between them.
+    fn get_resolved(&self) -> Option<Box<dyn ClientHook>>;
+
+    /// If this client is a settled reference (not a promise), return nullptr.  Otherwise, return a
+    /// promise that eventually resolves to a new client that is closer to being the final, settled
+    /// client (i.e. the value eventually returned by `getResolved()`).  Calling this repeatedly
+    /// should eventually produce a settled client.
+    fn when_more_resolved(
+        &self,
+    ) -> Option<crate::capability::Promise<Box<dyn ClientHook>, crate::Error>>;
+
+    /// Repeatedly calls whenMoreResolved() until it returns nullptr.
+    fn when_resolved(&self) -> Promise<(), crate::Error>;
+}
+
+impl Clone for Box<dyn ClientHook> {
+    fn clone(&self) -> Self {
+        self.add_ref()
+    }
+}
+
+pub trait ResultsHook {
+    fn get(&mut self) -> crate::Result<any_pointer::Builder<'_>>;
+    fn allow_cancellation(&self);
+    fn tail_call(self: Box<Self>, request: Box<dyn RequestHook>) -> Promise<(), crate::Error>;
+    fn direct_tail_call(
+        self: Box<Self>,
+        request: Box<dyn RequestHook>,
+    ) -> (
+        crate::capability::Promise<(), crate::Error>,
+        Box<dyn PipelineHook>,
+    );
+}
+
+pub trait ParamsHook {
+    fn get(&self) -> crate::Result<crate::any_pointer::Reader<'_>>;
+}
+
+// Where should this live?
+pub fn internal_get_typed_params<T>(typeless: Params<any_pointer::Owned>) -> Params<T> {
+    Params {
+        hook: typeless.hook,
+        marker: ::core::marker::PhantomData,
+    }
+}
+
+pub fn internal_get_typed_results<T>(typeless: Results<any_pointer::Owned>) -> Results<T> {
+    Results {
+        hook: typeless.hook,
+        marker: ::core::marker::PhantomData,
+    }
+}
+
+pub fn internal_get_untyped_results<T>(typeful: Results<T>) -> Results<any_pointer::Owned> {
+    Results {
+        hook: typeful.hook,
+        marker: ::core::marker::PhantomData,
+    }
+}
+
+pub trait PipelineHook {
+    fn add_ref(&self) -> Box<dyn PipelineHook>;
+    fn get_pipelined_cap(&self, ops: &[PipelineOp]) -> Box<dyn ClientHook>;
+
+    /// Version of get_pipelined_cap() passing the array by move. May avoid a copy in some cases.
+    /// Default implementation just calls the other version.
+    fn get_pipelined_cap_move(&self, ops: Vec<PipelineOp>) -> Box<dyn ClientHook> {
+        self.get_pipelined_cap(&ops)
+    }
+}
+
+impl Clone for Box<dyn PipelineHook> {
+    fn clone(&self) -> Self {
+        self.add_ref()
+    }
+}
+
+#[derive(Clone, Copy)]
+pub enum PipelineOp {
+    Noop,
+    GetPointerField(u16),
+}
diff --git a/rust/capnp/private/layout.rs b/rust/capnp/private/layout.rs
new file mode 100644
index 000000000000..02ecb6e7bfb5
--- /dev/null
+++ b/rust/capnp/private/layout.rs
@@ -0,0 +1,4210 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#[cfg(feature = "alloc")]
+use alloc::{boxed::Box, vec::Vec};
+use core::cell::Cell;
+use core::mem;
+use core::ptr;
+
+use crate::data;
+use crate::private::arena::{BuilderArena, NullArena, ReaderArena, SegmentId};
+#[cfg(feature = "alloc")]
+use crate::private::capability::ClientHook;
+use crate::private::mask::Mask;
+use crate::private::primitive::{Primitive, WireValue};
+use crate::private::units::*;
+use crate::private::zero;
+use crate::text;
+use crate::{Error, ErrorKind, MessageSize, Result};
+
+pub use self::ElementSize::{
+    Bit, Byte, EightBytes, FourBytes, InlineComposite, Pointer, TwoBytes, Void,
+};
+
+#[repr(u8)]
+#[derive(Clone, Copy, Debug, PartialEq)]
+pub enum ElementSize {
+    Void = 0,
+    Bit = 1,
+    Byte = 2,
+    TwoBytes = 3,
+    FourBytes = 4,
+    EightBytes = 5,
+    Pointer = 6,
+    InlineComposite = 7,
+}
+
+impl ElementSize {
+    fn from(val: u8) -> Self {
+        match val {
+            0 => Self::Void,
+            1 => Self::Bit,
+            2 => Self::Byte,
+            3 => Self::TwoBytes,
+            4 => Self::FourBytes,
+            5 => Self::EightBytes,
+            6 => Self::Pointer,
+            7 => Self::InlineComposite,
+            _ => panic!("illegal element size: {val}"),
+        }
+    }
+}
+
+pub fn data_bits_per_element(size: ElementSize) -> BitCount32 {
+    match size {
+        Void => 0,
+        Bit => 1,
+        Byte => 8,
+        TwoBytes => 16,
+        FourBytes => 32,
+        EightBytes => 64,
+        Pointer => 0,
+        InlineComposite => 0,
+    }
+}
+
+pub fn pointers_per_element(size: ElementSize) -> WirePointerCount32 {
+    match size {
+        Pointer => 1,
+        _ => 0,
+    }
+}
+
+#[derive(Clone, Copy, Debug)]
+pub struct StructSize {
+    pub data: WordCount16,
+    pub pointers: WirePointerCount16,
+}
+
+impl StructSize {
+    pub fn total(&self) -> WordCount32 {
+        u32::from(self.data) + u32::from(self.pointers) * WORDS_PER_POINTER as WordCount32
+    }
+}
+
+#[repr(u8)]
+#[derive(Clone, Copy, PartialEq)]
+pub enum WirePointerKind {
+    Struct = 0,
+    List = 1,
+    Far = 2,
+    Other = 3,
+}
+
+pub enum PointerType {
+    Null,
+    Struct,
+    List,
+    Capability,
+}
+
+impl WirePointerKind {
+    fn from(val: u8) -> Self {
+        match val {
+            0 => Self::Struct,
+            1 => Self::List,
+            2 => Self::Far,
+            3 => Self::Other,
+            _ => panic!("illegal element size: {val}"),
+        }
+    }
+}
+
+#[repr(C)]
+pub struct WirePointer {
+    offset_and_kind: WireValue<u32>,
+    upper32bits: WireValue<u32>,
+}
+
+#[test]
+#[cfg(feature = "unaligned")]
+fn wire_pointer_align() {
+    // We cast *u8 to *WirePointer, so we need to make sure its alignment allows that.
+    assert_eq!(core::mem::align_of::<WirePointer>(), 1);
+}
+
+impl WirePointer {
+    #[inline]
+    pub fn kind(&self) -> WirePointerKind {
+        WirePointerKind::from(self.offset_and_kind.get() as u8 & 3)
+    }
+
+    #[inline]
+    pub fn is_positional(&self) -> bool {
+        (self.offset_and_kind.get() & 2) == 0 // match Struct and List but not Far and Other.
+    }
+
+    #[inline]
+    pub fn is_capability(&self) -> bool {
+        self.offset_and_kind.get() == WirePointerKind::Other as u32
+    }
+
+    #[inline]
+    pub unsafe fn target(ptr: *const Self) -> *const u8 {
+        let this_addr: *const u8 = ptr as *const _;
+        unsafe { this_addr.offset(8 * (1 + (((*ptr).offset_and_kind.get() as i32) >> 2)) as isize) }
+    }
+
+    // At one point, we had `&self` here instead of `ptr: *const Self`, but miri
+    // flagged that as running afoul of "stacked borrow" rules.
+    #[inline]
+    fn target_from_segment(
+        ptr: *const Self,
+        arena: &dyn ReaderArena,
+        segment_id: u32,
+    ) -> Result<*const u8> {
+        let this_addr: *const u8 = ptr as *const _;
+        unsafe {
+            let offset = 1 + (((*ptr).offset_and_kind.get() as i32) >> 2);
+            arena.check_offset(segment_id, this_addr, offset)
+        }
+    }
+
+    // At one point, we had `&mut self` here instead of `ptr: *mut Self`, but miri
+    // flagged that as running afoul of "stacked borrow" rules.
+    #[inline]
+    fn mut_target(ptr: *mut Self) -> *mut u8 {
+        let this_addr: *mut u8 = ptr as *mut _;
+        unsafe {
+            this_addr.wrapping_offset(
+                BYTES_PER_WORD as isize
+                    * (1 + (((*ptr).offset_and_kind.get() as i32) >> 2)) as isize,
+            )
+        }
+    }
+
+    #[inline]
+    pub fn set_kind_and_target(&mut self, kind: WirePointerKind, target: *mut u8) {
+        let this_addr: isize = self as *const _ as isize;
+        let target_addr: isize = target as *const _ as isize;
+        self.offset_and_kind.set(
+            ((((target_addr - this_addr) / BYTES_PER_WORD as isize) as i32 - 1) << 2) as u32
+                | (kind as u32),
+        )
+    }
+
+    #[inline]
+    pub fn set_kind_with_zero_offset(&mut self, kind: WirePointerKind) {
+        self.offset_and_kind.set(kind as u32)
+    }
+
+    #[inline]
+    pub fn set_kind_and_target_for_empty_struct(&mut self) {
+        //# This pointer points at an empty struct. Assuming the
+        //# WirePointer itself is in-bounds, we can set the target to
+        //# point either at the WirePointer itself or immediately after
+        //# it. The latter would cause the WirePointer to be "null"
+        //# (since for an empty struct the upper 32 bits are going to
+        //# be zero). So we set an offset of -1, as if the struct were
+        //# allocated immediately before this pointer, to distinguish
+        //# it from null.
+
+        self.offset_and_kind.set(0xfffffffc);
+    }
+
+    #[inline]
+    pub fn inline_composite_list_element_count(&self) -> ElementCount32 {
+        self.offset_and_kind.get() >> 2
+    }
+
+    #[inline]
+    pub fn set_kind_and_inline_composite_list_element_count(
+        &mut self,
+        kind: WirePointerKind,
+        element_count: ElementCount32,
+    ) {
+        self.offset_and_kind
+            .set((element_count << 2) | (kind as u32))
+    }
+
+    #[inline]
+    pub fn far_position_in_segment(&self) -> WordCount32 {
+        self.offset_and_kind.get() >> 3
+    }
+
+    #[inline]
+    pub fn is_double_far(&self) -> bool {
+        ((self.offset_and_kind.get() >> 2) & 1) != 0
+    }
+
+    #[inline]
+    pub fn set_far(&mut self, is_double_far: bool, pos: WordCount32) {
+        self.offset_and_kind
+            .set((pos << 3) | (u32::from(is_double_far) << 2) | WirePointerKind::Far as u32);
+    }
+
+    #[inline]
+    pub fn set_cap(&mut self, index: u32) {
+        self.offset_and_kind.set(WirePointerKind::Other as u32);
+        self.upper32bits.set(index);
+    }
+
+    #[inline]
+    pub fn struct_data_size(&self) -> WordCount16 {
+        self.upper32bits.get() as WordCount16
+    }
+
+    #[inline]
+    pub fn struct_ptr_count(&self) -> WordCount16 {
+        (self.upper32bits.get() >> 16) as WordCount16
+    }
+
+    #[inline]
+    pub fn struct_word_size(&self) -> WordCount32 {
+        u32::from(self.struct_data_size())
+            + u32::from(self.struct_ptr_count()) * WORDS_PER_POINTER as u32
+    }
+
+    #[inline]
+    pub fn set_struct_size(&mut self, size: StructSize) {
+        self.upper32bits
+            .set(u32::from(size.data) | (u32::from(size.pointers) << 16))
+    }
+
+    #[inline]
+    pub fn set_struct_size_from_pieces(&mut self, ds: WordCount16, rc: WirePointerCount16) {
+        self.set_struct_size(StructSize {
+            data: ds,
+            pointers: rc,
+        })
+    }
+
+    #[inline]
+    pub fn list_element_size(&self) -> ElementSize {
+        ElementSize::from(self.upper32bits.get() as u8 & 7)
+    }
+
+    #[inline]
+    pub fn list_element_count(&self) -> ElementCount32 {
+        self.upper32bits.get() >> 3
+    }
+
+    #[inline]
+    pub fn list_inline_composite_word_count(&self) -> WordCount32 {
+        self.list_element_count()
+    }
+
+    #[inline]
+    pub fn set_list_size_and_count(&mut self, es: ElementSize, ec: ElementCount32) {
+        assert!(ec < (1 << 29), "Lists are limited to 2**29 elements");
+        self.upper32bits.set((ec << 3) | (es as u32));
+    }
+
+    #[inline]
+    pub fn set_list_inline_composite(&mut self, wc: WordCount32) {
+        assert!(
+            wc < (1 << 29),
+            "Inline composite lists are limited to 2**29 words"
+        );
+        self.upper32bits.set((wc << 3) | (InlineComposite as u32));
+    }
+
+    #[inline]
+    pub fn far_segment_id(&self) -> SegmentId {
+        self.upper32bits.get() as SegmentId
+    }
+
+    #[inline]
+    pub fn set_far_segment_id(&mut self, si: SegmentId) {
+        self.upper32bits.set(si)
+    }
+
+    #[inline]
+    pub fn cap_index(&self) -> u32 {
+        self.upper32bits.get()
+    }
+
+    #[inline]
+    pub fn set_cap_index(&mut self, index: u32) {
+        self.upper32bits.set(index)
+    }
+
+    #[inline]
+    pub fn is_null(&self) -> bool {
+        self.offset_and_kind.get() == 0 && self.upper32bits.get() == 0
+    }
+}
+
+mod wire_helpers {
+    #[cfg(feature = "alloc")]
+    use alloc::boxed::Box;
+    use core::{ptr, slice};
+
+    use crate::data;
+    use crate::private::arena::*;
+    #[cfg(feature = "alloc")]
+    use crate::private::capability::ClientHook;
+    use crate::private::layout::ElementSize::*;
+    use crate::private::layout::{data_bits_per_element, pointers_per_element};
+    use crate::private::layout::{CapTableBuilder, CapTableReader};
+    use crate::private::layout::{
+        ElementSize, ListBuilder, ListReader, StructBuilder, StructReader, StructSize, WirePointer,
+        WirePointerKind,
+    };
+    use crate::private::units::*;
+    use crate::text;
+    use crate::{Error, ErrorKind, MessageSize, Result};
+
+    pub struct SegmentAnd<T> {
+        #[allow(dead_code)]
+        segment_id: u32,
+        pub value: T,
+    }
+
+    #[inline]
+    pub fn round_bytes_up_to_words(bytes: ByteCount32) -> WordCount32 {
+        //# This code assumes 64-bit words.
+        (bytes + 7) / BYTES_PER_WORD as u32
+    }
+
+    //# The maximum object size is 4GB - 1 byte. If measured in bits,
+    //# this would overflow a 32-bit counter, so we need to accept
+    //# BitCount64. However, 32 bits is enough for the returned
+    //# ByteCounts and WordCounts.
+    #[inline]
+    pub fn round_bits_up_to_words(bits: BitCount64) -> WordCount32 {
+        //# This code assumes 64-bit words.
+        ((bits + 63) / (BITS_PER_WORD as u64)) as WordCount32
+    }
+
+    #[allow(dead_code)]
+    #[inline]
+    pub fn round_bits_up_to_bytes(bits: BitCount64) -> ByteCount32 {
+        ((bits + 7) / (BITS_PER_BYTE as u64)) as ByteCount32
+    }
+
+    #[inline]
+    pub fn bounds_check(
+        arena: &dyn ReaderArena,
+        segment_id: u32,
+        start: *const u8,
+        size_in_words: usize,
+        _kind: WirePointerKind,
+    ) -> Result<()> {
+        arena.contains_interval(segment_id, start, size_in_words)
+    }
+
+    #[inline]
+    pub fn amplified_read(arena: &dyn ReaderArena, virtual_amount: u64) -> Result<()> {
+        arena.amplified_read(virtual_amount)
+    }
+
+    #[inline]
+    pub unsafe fn allocate(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        amount: WordCount32,
+        kind: WirePointerKind,
+    ) -> (*mut u8, *mut WirePointer, u32) {
+        let is_null = (*reff).is_null();
+        if !is_null {
+            zero_object(arena, segment_id, reff)
+        }
+
+        if amount == 0 && kind == WirePointerKind::Struct {
+            (*reff).set_kind_and_target_for_empty_struct();
+            return (reff as *mut _, reff, segment_id);
+        }
+
+        match arena.allocate(segment_id, amount) {
+            None => {
+                //# Need to allocate in a different segment. We'll need to
+                //# allocate an extra pointer worth of space to act as
+                //# the landing pad for a far pointer.
+
+                let amount_plus_ref = amount + POINTER_SIZE_IN_WORDS as u32;
+                let (segment_id, word_idx) = arena.allocate_anywhere(amount_plus_ref);
+                let (seg_start, _seg_len) = arena.get_segment_mut(segment_id);
+                let ptr = seg_start.offset(word_idx as isize * BYTES_PER_WORD as isize);
+
+                //# Set up the original pointer to be a far pointer to
+                //# the new segment.
+                (*reff).set_far(false, word_idx);
+                (*reff).set_far_segment_id(segment_id);
+
+                //# Initialize the landing pad to indicate that the
+                //# data immediately follows the pad.
+                let reff = ptr as *mut WirePointer;
+
+                let ptr1 = ptr.add(BYTES_PER_WORD);
+                (*reff).set_kind_and_target(kind, ptr1);
+                (ptr1, reff, segment_id)
+            }
+            Some(idx) => {
+                let (seg_start, _seg_len) = arena.get_segment_mut(segment_id);
+                let ptr = (seg_start).offset(idx as isize * BYTES_PER_WORD as isize);
+                (*reff).set_kind_and_target(kind, ptr);
+                (ptr, reff, segment_id)
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn follow_builder_fars(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        ref_target: *mut u8,
+        segment_id: u32,
+    ) -> Result<(*mut u8, *mut WirePointer, u32)> {
+        // If `ref` is a far pointer, follow it. On return, `ref` will have been updated to point at
+        // a WirePointer that contains the type information about the target object, and a pointer
+        // to the object contents is returned. The caller must NOT use `ref->target()` as this may
+        // or may not actually return a valid pointer. `segment` is also updated to point at the
+        // segment which actually contains the object.
+        //
+        // If `ref` is not a far pointer, this simply returns `ref_target`. Usually, `ref_target`
+        // should be the same as `ref->target()`, but may not be in cases where `ref` is only a tag.
+
+        if (*reff).kind() == WirePointerKind::Far {
+            let segment_id = (*reff).far_segment_id();
+            let (seg_start, _seg_len) = arena.get_segment_mut(segment_id);
+            let pad: *mut WirePointer =
+                (seg_start as *mut WirePointer).offset((*reff).far_position_in_segment() as isize);
+            if !(*reff).is_double_far() {
+                Ok((WirePointer::mut_target(pad), pad, segment_id))
+            } else {
+                //# Landing pad is another far pointer. It is followed by a
+                //# tag describing the pointed-to object.
+                let reff = pad.offset(1);
+
+                let segment_id = (*pad).far_segment_id();
+                let (segment_start, _segment_len) = arena.get_segment_mut(segment_id);
+                let ptr = segment_start
+                    .offset((*pad).far_position_in_segment() as isize * BYTES_PER_WORD as isize);
+                Ok((ptr, reff, segment_id))
+            }
+        } else {
+            Ok((ref_target, reff, segment_id))
+        }
+    }
+
+    /// Follows a WirePointer to get a triple containing:
+    ///   - the pointed-to object
+    ///   - the resolved WirePointer, whose kind is something other than WirePointerKind::Far
+    ///   - the segment on which the pointed-to object lives
+    #[inline]
+    pub unsafe fn follow_fars(
+        arena: &dyn ReaderArena,
+        reff: *const WirePointer,
+        segment_id: u32,
+    ) -> Result<(*const u8, *const WirePointer, u32)> {
+        if (*reff).kind() == WirePointerKind::Far {
+            let far_segment_id = (*reff).far_segment_id();
+
+            let (seg_start, _seg_len) = arena.get_segment(far_segment_id)?;
+            let ptr = seg_start
+                .offset((*reff).far_position_in_segment() as isize * BYTES_PER_WORD as isize);
+
+            let pad_words: usize = if (*reff).is_double_far() { 2 } else { 1 };
+            bounds_check(arena, far_segment_id, ptr, pad_words, WirePointerKind::Far)?;
+
+            let pad: *const WirePointer = ptr as *const _;
+
+            if !(*reff).is_double_far() {
+                Ok((
+                    WirePointer::target_from_segment(pad, arena, far_segment_id)?,
+                    pad,
+                    far_segment_id,
+                ))
+            } else {
+                // Landing pad is another far pointer. It is followed by a tag describing the
+                // pointed-to object.
+
+                let tag = pad.offset(1);
+                let double_far_segment_id = (*pad).far_segment_id();
+                let (segment_start, _segment_len) = arena.get_segment(double_far_segment_id)?;
+                let ptr = segment_start
+                    .offset((*pad).far_position_in_segment() as isize * BYTES_PER_WORD as isize);
+                Ok((ptr, tag, double_far_segment_id))
+            }
+        } else {
+            Ok((
+                WirePointer::target_from_segment(reff, arena, segment_id)?,
+                reff,
+                segment_id,
+            ))
+        }
+    }
+
+    pub unsafe fn zero_object(
+        arena: &mut dyn BuilderArena,
+        segment_id: u32,
+        reff: *mut WirePointer,
+    ) {
+        //# Zero out the pointed-to object. Use when the pointer is
+        //# about to be overwritten making the target object no longer
+        //# reachable.
+
+        match (*reff).kind() {
+            WirePointerKind::Struct | WirePointerKind::List | WirePointerKind::Other => {
+                zero_object_helper(arena, segment_id, reff, WirePointer::mut_target(reff))
+            }
+            WirePointerKind::Far => {
+                let segment_id = (*reff).far_segment_id();
+                let (seg_start, _seg_len) = arena.get_segment_mut(segment_id);
+                let pad: *mut WirePointer = (seg_start as *mut WirePointer)
+                    .offset((*reff).far_position_in_segment() as isize);
+
+                if (*reff).is_double_far() {
+                    let segment_id = (*pad).far_segment_id();
+
+                    let (seg_start, _seg_len) = arena.get_segment_mut(segment_id);
+                    let ptr = seg_start.offset(
+                        (*pad).far_position_in_segment() as isize * BYTES_PER_WORD as isize,
+                    );
+                    zero_object_helper(arena, segment_id, pad.offset(1), ptr);
+
+                    ptr::write_bytes(pad, 0u8, 2);
+                } else {
+                    zero_object(arena, segment_id, pad);
+                    ptr::write_bytes(pad, 0u8, 1);
+                }
+            }
+        }
+    }
+
+    pub unsafe fn zero_object_helper(
+        arena: &mut dyn BuilderArena,
+        segment_id: u32,
+        tag: *mut WirePointer,
+        ptr: *mut u8,
+    ) {
+        match (*tag).kind() {
+            WirePointerKind::Other => {
+                panic!("Don't know how to handle OTHER")
+            }
+            WirePointerKind::Struct => {
+                let pointer_section: *mut WirePointer = ptr
+                    .offset((*tag).struct_data_size() as isize * BYTES_PER_WORD as isize)
+                    as *mut _;
+
+                let count = (*tag).struct_ptr_count() as isize;
+                for i in 0..count {
+                    zero_object(arena, segment_id, pointer_section.offset(i));
+                }
+                ptr::write_bytes(
+                    ptr,
+                    0u8,
+                    (*tag).struct_word_size() as usize * BYTES_PER_WORD,
+                );
+            }
+            WirePointerKind::List => match (*tag).list_element_size() {
+                Void => {}
+                Bit | Byte | TwoBytes | FourBytes | EightBytes => ptr::write_bytes(
+                    ptr,
+                    0u8,
+                    BYTES_PER_WORD
+                        * round_bits_up_to_words(
+                            u64::from((*tag).list_element_count())
+                                * u64::from(data_bits_per_element((*tag).list_element_size())),
+                        ) as usize,
+                ),
+                Pointer => {
+                    let count = (*tag).list_element_count() as usize;
+                    for i in 0..count as isize {
+                        zero_object(
+                            arena,
+                            segment_id,
+                            ptr.offset(i * BYTES_PER_WORD as isize) as *mut _,
+                        );
+                    }
+                    ptr::write_bytes(ptr, 0u8, count * BYTES_PER_WORD);
+                }
+                InlineComposite => {
+                    let element_tag: *mut WirePointer = ptr as *mut _;
+
+                    assert!(
+                        (*element_tag).kind() == WirePointerKind::Struct,
+                        "Don't know how to handle non-STRUCT inline composite"
+                    );
+
+                    let data_size = (*element_tag).struct_data_size();
+                    let pointer_count = (*element_tag).struct_ptr_count();
+                    let mut pos = ptr.add(BYTES_PER_WORD);
+                    let count = (*element_tag).inline_composite_list_element_count();
+                    if pointer_count > 0 {
+                        for _ in 0..count {
+                            pos = pos.offset(data_size as isize * BYTES_PER_WORD as isize);
+                            for _ in 0..pointer_count {
+                                zero_object(arena, segment_id, pos as *mut WirePointer);
+                                pos = pos.add(BYTES_PER_WORD);
+                            }
+                        }
+                    }
+                    ptr::write_bytes(
+                        ptr,
+                        0u8,
+                        BYTES_PER_WORD * ((*element_tag).struct_word_size() * count + 1) as usize,
+                    );
+                }
+            },
+            WirePointerKind::Far => {
+                panic!("Unexpected FAR pointer")
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn zero_pointer_and_fars(
+        arena: &mut dyn BuilderArena,
+        _segment_id: u32,
+        reff: *mut WirePointer,
+    ) -> Result<()> {
+        // Zero out the pointer itself and, if it is a far pointer, zero the landing pad as well,
+        // but do not zero the object body. Used when upgrading.
+
+        if (*reff).kind() == WirePointerKind::Far {
+            let far_segment_id = (*reff).far_segment_id();
+            let (seg_start, _seg_len) = arena.get_segment_mut(far_segment_id);
+            let pad = seg_start
+                .offset((*reff).far_position_in_segment() as isize * BYTES_PER_WORD as isize);
+            let num_elements = if (*reff).is_double_far() { 2 } else { 1 };
+            ptr::write_bytes(pad, 0, num_elements * BYTES_PER_WORD);
+        }
+        ptr::write_bytes(reff, 0, 1);
+        Ok(())
+    }
+
+    pub unsafe fn total_size(
+        arena: &dyn ReaderArena,
+        segment_id: u32,
+        reff: *const WirePointer,
+        mut nesting_limit: i32,
+    ) -> Result<MessageSize> {
+        let mut result = MessageSize {
+            word_count: 0,
+            cap_count: 0,
+        };
+
+        if (*reff).is_null() {
+            return Ok(result);
+        };
+
+        if nesting_limit <= 0 {
+            return Err(Error::from_kind(ErrorKind::MessageIsTooDeeplyNested));
+        }
+
+        nesting_limit -= 1;
+
+        let (ptr, reff, segment_id) = follow_fars(arena, reff, segment_id)?;
+
+        match (*reff).kind() {
+            WirePointerKind::Struct => {
+                bounds_check(
+                    arena,
+                    segment_id,
+                    ptr,
+                    (*reff).struct_word_size() as usize,
+                    WirePointerKind::Struct,
+                )?;
+                result.word_count += u64::from((*reff).struct_word_size());
+
+                let pointer_section: *const WirePointer = ptr
+                    .offset((*reff).struct_data_size() as isize * BYTES_PER_WORD as isize)
+                    as *const _;
+                let count: isize = (*reff).struct_ptr_count() as isize;
+                for i in 0..count {
+                    result +=
+                        total_size(arena, segment_id, pointer_section.offset(i), nesting_limit)?;
+                }
+            }
+            WirePointerKind::List => {
+                match (*reff).list_element_size() {
+                    Void => {}
+                    Bit | Byte | TwoBytes | FourBytes | EightBytes => {
+                        let total_words = round_bits_up_to_words(
+                            u64::from((*reff).list_element_count())
+                                * u64::from(data_bits_per_element((*reff).list_element_size())),
+                        );
+                        bounds_check(
+                            arena,
+                            segment_id,
+                            ptr,
+                            total_words as usize,
+                            WirePointerKind::List,
+                        )?;
+                        result.word_count += u64::from(total_words);
+                    }
+                    Pointer => {
+                        let count = (*reff).list_element_count();
+                        bounds_check(
+                            arena,
+                            segment_id,
+                            ptr,
+                            count as usize * WORDS_PER_POINTER,
+                            WirePointerKind::List,
+                        )?;
+
+                        result.word_count += u64::from(count) * WORDS_PER_POINTER as u64;
+
+                        for i in 0..count as isize {
+                            result += total_size(
+                                arena,
+                                segment_id,
+                                (ptr as *const WirePointer).offset(i),
+                                nesting_limit,
+                            )?;
+                        }
+                    }
+                    InlineComposite => {
+                        let word_count = (*reff).list_inline_composite_word_count();
+                        bounds_check(
+                            arena,
+                            segment_id,
+                            ptr,
+                            word_count as usize + POINTER_SIZE_IN_WORDS,
+                            WirePointerKind::List,
+                        )?;
+
+                        let element_tag: *const WirePointer = ptr as *const _;
+                        let count = (*element_tag).inline_composite_list_element_count();
+
+                        if (*element_tag).kind() != WirePointerKind::Struct {
+                            return Err(Error::from_kind(
+                                ErrorKind::CantHandleNonStructInlineComposite,
+                            ));
+                        }
+
+                        let actual_size =
+                            u64::from((*element_tag).struct_word_size()) * u64::from(count);
+                        if actual_size > u64::from(word_count) {
+                            return Err(Error::from_kind(
+                                ErrorKind::InlineCompositeListsElementsOverrunItsWordCount,
+                            ));
+                        }
+
+                        // Count the actual size rather than the claimed word count because
+                        // that's what we end up with if we make a copy.
+                        result.word_count += actual_size + POINTER_SIZE_IN_WORDS as u64;
+
+                        let data_size = (*element_tag).struct_data_size();
+                        let pointer_count = (*element_tag).struct_ptr_count();
+
+                        if pointer_count > 0 {
+                            let mut pos = ptr.add(BYTES_PER_WORD);
+                            for _ in 0..count {
+                                pos = pos.offset(data_size as isize * BYTES_PER_WORD as isize);
+
+                                for _ in 0..pointer_count {
+                                    result += total_size(
+                                        arena,
+                                        segment_id,
+                                        pos as *const WirePointer,
+                                        nesting_limit,
+                                    )?;
+                                    pos = pos.add(BYTES_PER_WORD);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            WirePointerKind::Far => {
+                return Err(Error::from_kind(ErrorKind::MalformedDoubleFarPointer));
+            }
+            WirePointerKind::Other => {
+                if (*reff).is_capability() {
+                    result.cap_count += 1;
+                } else {
+                    return Err(Error::from_kind(ErrorKind::UnknownPointerType));
+                }
+            }
+        }
+
+        Ok(result)
+    }
+
+    // Helper for copy_message().
+    unsafe fn copy_struct(
+        arena: &mut dyn BuilderArena,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        dst: *mut u8,
+        src: *const u8,
+        data_size: isize,
+        pointer_count: isize,
+    ) {
+        ptr::copy_nonoverlapping(src, dst, data_size as usize * BYTES_PER_WORD);
+
+        let src_refs: *const WirePointer = (src as *const WirePointer).offset(data_size);
+        let dst_refs: *mut WirePointer = (dst as *mut WirePointer).offset(data_size);
+
+        for ii in 0..pointer_count {
+            copy_message(
+                arena,
+                segment_id,
+                cap_table,
+                dst_refs.offset(ii),
+                src_refs.offset(ii),
+            );
+        }
+    }
+
+    // Copies from a trusted message.
+    // Returns (new_dst_ptr, new_dst, new_segment_id).
+    pub unsafe fn copy_message(
+        arena: &mut dyn BuilderArena,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        dst: *mut WirePointer,
+        src: *const WirePointer,
+    ) -> (*mut u8, *mut WirePointer, u32) {
+        match (*src).kind() {
+            WirePointerKind::Struct => {
+                if (*src).is_null() {
+                    ptr::write_bytes(dst, 0, 1);
+                    (ptr::null_mut(), dst, segment_id)
+                } else {
+                    let src_ptr = WirePointer::target(src);
+                    let (dst_ptr, dst, segment_id) = allocate(
+                        arena,
+                        dst,
+                        segment_id,
+                        (*src).struct_word_size(),
+                        WirePointerKind::Struct,
+                    );
+                    copy_struct(
+                        arena,
+                        segment_id,
+                        cap_table,
+                        dst_ptr,
+                        src_ptr,
+                        (*src).struct_data_size() as isize,
+                        (*src).struct_ptr_count() as isize,
+                    );
+                    (*dst).set_struct_size_from_pieces(
+                        (*src).struct_data_size(),
+                        (*src).struct_ptr_count(),
+                    );
+                    (dst_ptr, dst, segment_id)
+                }
+            }
+            WirePointerKind::List => match (*src).list_element_size() {
+                ElementSize::Void
+                | ElementSize::Bit
+                | ElementSize::Byte
+                | ElementSize::TwoBytes
+                | ElementSize::FourBytes
+                | ElementSize::EightBytes => {
+                    let word_count = round_bits_up_to_words(
+                        u64::from((*src).list_element_count())
+                            * u64::from(data_bits_per_element((*src).list_element_size())),
+                    );
+                    let src_ptr = WirePointer::target(src);
+                    let (dst_ptr, dst, segment_id) =
+                        allocate(arena, dst, segment_id, word_count, WirePointerKind::List);
+                    ptr::copy_nonoverlapping(
+                        src_ptr,
+                        dst_ptr,
+                        word_count as usize * BYTES_PER_WORD,
+                    );
+                    (*dst).set_list_size_and_count(
+                        (*src).list_element_size(),
+                        (*src).list_element_count(),
+                    );
+                    (dst_ptr, dst, segment_id)
+                }
+
+                ElementSize::Pointer => {
+                    let src_refs: *const WirePointer = WirePointer::target(src) as _;
+                    let (dst_refs, dst, segment_id) = allocate(
+                        arena,
+                        dst,
+                        segment_id,
+                        (*src).list_element_count(),
+                        WirePointerKind::List,
+                    );
+                    for ii in 0..((*src).list_element_count() as isize) {
+                        copy_message(
+                            arena,
+                            segment_id,
+                            cap_table,
+                            dst_refs.offset(ii * BYTES_PER_WORD as isize) as *mut WirePointer,
+                            src_refs.offset(ii),
+                        );
+                    }
+                    (*dst)
+                        .set_list_size_and_count(ElementSize::Pointer, (*src).list_element_count());
+                    (dst_refs, dst, segment_id)
+                }
+                ElementSize::InlineComposite => {
+                    let src_ptr = WirePointer::target(src);
+                    let (dst_ptr, dst, segment_id) = allocate(
+                        arena,
+                        dst,
+                        segment_id,
+                        (*src).list_inline_composite_word_count() + 1,
+                        WirePointerKind::List,
+                    );
+
+                    (*dst).set_list_inline_composite((*src).list_inline_composite_word_count());
+
+                    let src_tag: *const WirePointer = src_ptr as _;
+                    ptr::copy_nonoverlapping(src_tag, dst_ptr as *mut WirePointer, 1);
+
+                    let mut src_element = src_ptr.add(BYTES_PER_WORD);
+                    let mut dst_element = dst_ptr.add(BYTES_PER_WORD);
+
+                    if (*src_tag).kind() != WirePointerKind::Struct {
+                        panic!("unsupported INLINE_COMPOSITE list");
+                    }
+                    for _ in 0..(*src_tag).inline_composite_list_element_count() {
+                        copy_struct(
+                            arena,
+                            segment_id,
+                            cap_table,
+                            dst_element,
+                            src_element,
+                            (*src_tag).struct_data_size() as isize,
+                            (*src_tag).struct_ptr_count() as isize,
+                        );
+                        src_element = src_element.offset(
+                            BYTES_PER_WORD as isize * (*src_tag).struct_word_size() as isize,
+                        );
+                        dst_element = dst_element.offset(
+                            BYTES_PER_WORD as isize * (*src_tag).struct_word_size() as isize,
+                        );
+                    }
+                    (dst_ptr, dst, segment_id)
+                }
+            },
+            WirePointerKind::Other => {
+                panic!("Unchecked message contained an OTHER pointer.")
+            }
+            WirePointerKind::Far => {
+                panic!("Unchecked message contained a far pointer.")
+            }
+        }
+    }
+
+    pub unsafe fn transfer_pointer(
+        arena: &mut dyn BuilderArena,
+        dst_segment_id: u32,
+        dst: *mut WirePointer,
+        src_segment_id: u32,
+        src: *mut WirePointer,
+    ) {
+        //# Make *dst point to the same object as *src. Both must
+        //# reside in the same message, but can be in different
+        //# segments. Not always-inline because this is rarely used.
+        //
+        //# Caller MUST zero out the source pointer after calling this,
+        //# to make sure no later code mistakenly thinks the source
+        //# location still owns the object. transferPointer() doesn't
+        //# do this zeroing itself because many callers transfer
+        //# several pointers in a loop then zero out the whole section.
+
+        assert!((*dst).is_null());
+        // We expect the caller to ensure the target is already null so won't leak.
+
+        if (*src).is_null() {
+            ptr::write_bytes(dst, 0, 1);
+        } else if (*src).is_positional() {
+            transfer_pointer_split(
+                arena,
+                dst_segment_id,
+                dst,
+                src_segment_id,
+                src,
+                WirePointer::mut_target(src),
+            );
+        } else {
+            ptr::copy_nonoverlapping(src, dst, 1);
+        }
+    }
+
+    pub unsafe fn transfer_pointer_split(
+        arena: &mut dyn BuilderArena,
+        dst_segment_id: u32,
+        dst: *mut WirePointer,
+        src_segment_id: u32,
+        src_tag: *mut WirePointer,
+        src_ptr: *mut u8,
+    ) {
+        // Like the other transfer_pointer, but splits src into a tag and a
+        // target. Particularly useful for OrphanBuilder.
+
+        if dst_segment_id == src_segment_id {
+            // Same segment, so create a direct pointer.
+
+            if (*src_tag).kind() == WirePointerKind::Struct && (*src_tag).struct_word_size() == 0 {
+                (*dst).set_kind_and_target_for_empty_struct();
+            } else {
+                (*dst).set_kind_and_target((*src_tag).kind(), src_ptr);
+            }
+            // We can just copy the upper 32 bits. (Use memcpy() to comply with aliasing rules.)
+            ptr::copy_nonoverlapping(&(*src_tag).upper32bits, &mut (*dst).upper32bits, 1);
+        } else {
+            // Need to create a far pointer. Try to allocate it in the same segment as the source,
+            // so that it doesn't need to be a double-far.
+
+            match arena.allocate(src_segment_id, 1) {
+                None => {
+                    //# Darn, need a double-far.
+                    let (far_segment_id, word_idx) = arena.allocate_anywhere(2);
+                    let (seg_start, _seg_len) = arena.get_segment_mut(far_segment_id);
+                    let landing_pad: *mut WirePointer =
+                        (seg_start as *mut WirePointer).offset(word_idx as isize);
+
+                    let (src_seg_start, _seg_len) = arena.get_segment_mut(src_segment_id);
+
+                    (*landing_pad).set_far(
+                        false,
+                        ((src_ptr as usize - src_seg_start as usize) / BYTES_PER_WORD) as u32,
+                    );
+                    (*landing_pad).set_far_segment_id(src_segment_id);
+
+                    let landing_pad1 = landing_pad.offset(1);
+                    (*landing_pad1).set_kind_with_zero_offset((*src_tag).kind());
+
+                    ptr::copy_nonoverlapping(
+                        &(*src_tag).upper32bits,
+                        &mut (*landing_pad1).upper32bits,
+                        1,
+                    );
+
+                    (*dst).set_far(true, word_idx);
+                    (*dst).set_far_segment_id(far_segment_id);
+                }
+                Some(landing_pad_word) => {
+                    //# Simple landing pad is just a pointer.
+                    let (seg_start, seg_len) = arena.get_segment_mut(src_segment_id);
+                    assert!(landing_pad_word < seg_len);
+                    let landing_pad: *mut WirePointer =
+                        (seg_start as *mut WirePointer).offset(landing_pad_word as isize);
+                    (*landing_pad).set_kind_and_target((*src_tag).kind(), src_ptr);
+                    ptr::copy_nonoverlapping(
+                        &(*src_tag).upper32bits,
+                        &mut (*landing_pad).upper32bits,
+                        1,
+                    );
+
+                    (*dst).set_far(false, landing_pad_word);
+                    (*dst).set_far_segment_id(src_segment_id);
+                }
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn init_struct_pointer(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        size: StructSize,
+    ) -> StructBuilder<'_> {
+        let (ptr, reff, segment_id) = allocate(
+            arena,
+            reff,
+            segment_id,
+            size.total(),
+            WirePointerKind::Struct,
+        );
+        (*reff).set_struct_size(size);
+
+        StructBuilder {
+            arena,
+            segment_id,
+            cap_table,
+            data: ptr as *mut _,
+            pointers: ptr.offset((size.data as usize) as isize * BYTES_PER_WORD as isize) as *mut _,
+            data_size: u32::from(size.data) * (BITS_PER_WORD as BitCount32),
+            pointer_count: size.pointers,
+        }
+    }
+
+    #[inline]
+    pub unsafe fn get_writable_struct_pointer<'a>(
+        arena: &'a mut dyn BuilderArena,
+        mut reff: *mut WirePointer,
+        mut segment_id: u32,
+        cap_table: CapTableBuilder,
+        size: StructSize,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<StructBuilder<'a>> {
+        let mut ref_target = WirePointer::mut_target(reff);
+
+        if (*reff).is_null() {
+            match default {
+                None => {
+                    return Ok(init_struct_pointer(
+                        arena, reff, segment_id, cap_table, size,
+                    ))
+                }
+                Some(d) if (*(d.as_ptr() as *const WirePointer)).is_null() => {
+                    return Ok(init_struct_pointer(
+                        arena, reff, segment_id, cap_table, size,
+                    ))
+                }
+                Some(d) => {
+                    let (new_ref_target, new_reff, new_segment_id) = copy_message(
+                        arena,
+                        segment_id,
+                        cap_table,
+                        reff,
+                        d.as_ptr() as *const WirePointer,
+                    );
+                    reff = new_reff;
+                    segment_id = new_segment_id;
+                    ref_target = new_ref_target;
+                }
+            }
+        }
+
+        let (old_ptr, old_ref, old_segment_id) =
+            follow_builder_fars(arena, reff, ref_target, segment_id)?;
+        if (*old_ref).kind() != WirePointerKind::Struct {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsNonStructPointerWhereStructPointerWasExpected,
+            ));
+        }
+
+        let old_data_size = (*old_ref).struct_data_size();
+        let old_pointer_count = (*old_ref).struct_ptr_count();
+        let old_pointer_section: *mut WirePointer =
+            old_ptr.offset(old_data_size as isize * BYTES_PER_WORD as isize) as *mut _;
+
+        if old_data_size < size.data || old_pointer_count < size.pointers {
+            //# The space allocated for this struct is too small.
+            //# Unlike with readers, we can't just run with it and do
+            //# bounds checks at access time, because how would we
+            //# handle writes? Instead, we have to copy the struct to a
+            //# new space now.
+
+            let new_data_size = ::core::cmp::max(old_data_size, size.data);
+            let new_pointer_count = ::core::cmp::max(old_pointer_count, size.pointers);
+            let total_size =
+                u32::from(new_data_size) + u32::from(new_pointer_count) * WORDS_PER_POINTER as u32;
+
+            //# Don't let allocate() zero out the object just yet.
+            zero_pointer_and_fars(arena, segment_id, reff)?;
+
+            let (ptr, reff, segment_id) =
+                allocate(arena, reff, segment_id, total_size, WirePointerKind::Struct);
+            (*reff).set_struct_size_from_pieces(new_data_size, new_pointer_count);
+
+            // Copy data section.
+            // Note: copy_nonoverlapping's third argument is an element count, not a byte count.
+            ptr::copy_nonoverlapping(old_ptr, ptr, old_data_size as usize * BYTES_PER_WORD);
+
+            //# Copy pointer section.
+            let new_pointer_section: *mut WirePointer =
+                ptr.offset(new_data_size as isize * BYTES_PER_WORD as isize) as *mut _;
+            for i in 0..old_pointer_count as isize {
+                transfer_pointer(
+                    arena,
+                    segment_id,
+                    new_pointer_section.offset(i),
+                    old_segment_id,
+                    old_pointer_section.offset(i),
+                );
+            }
+
+            ptr::write_bytes(
+                old_ptr,
+                0,
+                (old_data_size as usize + old_pointer_count as usize) * BYTES_PER_WORD,
+            );
+
+            Ok(StructBuilder {
+                arena,
+                segment_id,
+                cap_table,
+                data: ptr as *mut _,
+                pointers: new_pointer_section,
+                data_size: u32::from(new_data_size) * BITS_PER_WORD as u32,
+                pointer_count: new_pointer_count,
+            })
+        } else {
+            Ok(StructBuilder {
+                arena,
+                segment_id: old_segment_id,
+                cap_table,
+                data: old_ptr,
+                pointers: old_pointer_section,
+                data_size: u32::from(old_data_size) * BITS_PER_WORD as u32,
+                pointer_count: old_pointer_count,
+            })
+        }
+    }
+
+    #[inline]
+    pub unsafe fn init_list_pointer(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        element_count: ElementCount32,
+        element_size: ElementSize,
+    ) -> ListBuilder<'_> {
+        assert!(
+            element_size != InlineComposite,
+            "Should have called initStructListPointer() instead"
+        );
+
+        let data_size = data_bits_per_element(element_size);
+        let pointer_count = pointers_per_element(element_size);
+        let step = data_size + pointer_count * BITS_PER_POINTER as u32;
+        let word_count = round_bits_up_to_words(u64::from(element_count) * u64::from(step));
+        let (ptr, reff, segment_id) =
+            allocate(arena, reff, segment_id, word_count, WirePointerKind::List);
+
+        (*reff).set_list_size_and_count(element_size, element_count);
+
+        ListBuilder {
+            arena,
+            segment_id,
+            cap_table,
+            ptr,
+            step,
+            element_count,
+            element_size,
+            struct_data_size: data_size,
+            struct_pointer_count: pointer_count as u16,
+        }
+    }
+
+    #[inline]
+    pub unsafe fn init_struct_list_pointer(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        element_count: ElementCount32,
+        element_size: StructSize,
+    ) -> ListBuilder<'_> {
+        let words_per_element = element_size.total();
+
+        //# Allocate the list, prefixed by a single WirePointer.
+        let word_count: WordCount32 = element_count * words_per_element;
+        let (ptr, reff, segment_id) = allocate(
+            arena,
+            reff,
+            segment_id,
+            POINTER_SIZE_IN_WORDS as u32 + word_count,
+            WirePointerKind::List,
+        );
+        let ptr = ptr as *mut WirePointer;
+
+        //# Initialize the pointer.
+        (*reff).set_list_inline_composite(word_count);
+        (*ptr).set_kind_and_inline_composite_list_element_count(
+            WirePointerKind::Struct,
+            element_count,
+        );
+        (*ptr).set_struct_size(element_size);
+
+        let ptr1 = ptr.add(POINTER_SIZE_IN_WORDS);
+
+        ListBuilder {
+            arena,
+            segment_id,
+            cap_table,
+            ptr: ptr1 as *mut _,
+            step: words_per_element * BITS_PER_WORD as u32,
+            element_count,
+            element_size: ElementSize::InlineComposite,
+            struct_data_size: u32::from(element_size.data) * (BITS_PER_WORD as u32),
+            struct_pointer_count: element_size.pointers,
+        }
+    }
+
+    #[inline]
+    pub unsafe fn get_writable_list_pointer(
+        arena: &mut dyn BuilderArena,
+        mut orig_ref: *mut WirePointer,
+        mut orig_segment_id: u32,
+        cap_table: CapTableBuilder,
+        element_size: ElementSize,
+        default_value: *const u8,
+    ) -> Result<ListBuilder<'_>> {
+        assert!(
+            element_size != InlineComposite,
+            "Use get_writable_struct_list_pointer() for struct lists"
+        );
+
+        let mut orig_ref_target = WirePointer::mut_target(orig_ref);
+
+        if (*orig_ref).is_null() {
+            if default_value.is_null() || (*(default_value as *const WirePointer)).is_null() {
+                return Ok(ListBuilder::new_default(arena));
+            }
+            let (new_orig_ref_target, new_orig_ref, new_orig_segment_id) = copy_message(
+                arena,
+                orig_segment_id,
+                cap_table,
+                orig_ref,
+                default_value as *const WirePointer,
+            );
+            orig_ref_target = new_orig_ref_target;
+            orig_ref = new_orig_ref;
+            orig_segment_id = new_orig_segment_id;
+        }
+
+        // We must verify that the pointer has the right size. Unlike in
+        // get_writable_struct_list_pointer(), we never need to "upgrade" the data, because this
+        // method is called only for non-struct lists, and there is no allowed upgrade path *to* a
+        // non-struct list, only *from* them.
+
+        let (mut ptr, reff, segment_id) =
+            follow_builder_fars(arena, orig_ref, orig_ref_target, orig_segment_id)?;
+
+        if (*reff).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(ErrorKind::ExistingPointerIsNotAList));
+        }
+
+        let old_size = (*reff).list_element_size();
+
+        if old_size == InlineComposite {
+            // The existing element size is InlineComposite, which means that it is at least two
+            // words, which makes it bigger than the expected element size. Since fields can only
+            // grow when upgraded, the existing data must have been written with a newer version of
+            // the protocol. We therefore never need to upgrade the data in this case, but we do
+            // need to validate that it is a valid upgrade from what we expected.
+
+            // Read the tag to get the actual element count.
+            let tag: *const WirePointer = ptr as *const _;
+
+            if (*tag).kind() != WirePointerKind::Struct {
+                return Err(Error::from_kind(
+                    ErrorKind::InlineCompositeListWithNonStructElementsNotSupported,
+                ));
+            }
+
+            ptr = ptr.add(BYTES_PER_WORD);
+
+            let data_size = (*tag).struct_data_size();
+            let pointer_count = (*tag).struct_ptr_count();
+
+            match element_size {
+                Void => {} // Anything is a valid upgrade from Void.
+                Bit => {
+                    return Err(Error::from_kind(
+                        ErrorKind::FoundStructListWhereBitListWasExpected,
+                    ));
+                }
+                Byte | TwoBytes | FourBytes | EightBytes => {
+                    if data_size < 1 {
+                        return Err(Error::from_kind(
+                            ErrorKind::ExistingListValueIsIncompatibleWithExpectedType,
+                        ));
+                    }
+                }
+                Pointer => {
+                    if pointer_count < 1 {
+                        return Err(Error::from_kind(
+                            ErrorKind::ExistingListValueIsIncompatibleWithExpectedType,
+                        ));
+                    }
+                    // Adjust the pointer to point at the reference segment.
+                    ptr = ptr.offset(data_size as isize * BYTES_PER_WORD as isize);
+                }
+                InlineComposite => {
+                    unreachable!()
+                }
+            }
+            // OK, looks valid.
+
+            Ok(ListBuilder {
+                arena,
+                segment_id,
+                cap_table,
+                ptr: ptr as *mut _,
+                element_count: (*tag).inline_composite_list_element_count(),
+                element_size: ElementSize::InlineComposite,
+                step: (*tag).struct_word_size() * BITS_PER_WORD as u32,
+                struct_data_size: u32::from(data_size) * BITS_PER_WORD as u32,
+                struct_pointer_count: pointer_count,
+            })
+        } else {
+            let data_size = data_bits_per_element(old_size);
+            let pointer_count = pointers_per_element(old_size);
+
+            if data_size < data_bits_per_element(element_size)
+                || pointer_count < pointers_per_element(element_size)
+            {
+                return Err(Error::from_kind(
+                    ErrorKind::ExistingListValueIsIncompatibleWithExpectedType,
+                ));
+            }
+
+            let step = data_size + pointer_count * BITS_PER_POINTER as u32;
+
+            Ok(ListBuilder {
+                arena,
+                segment_id,
+                cap_table,
+                ptr: ptr as *mut _,
+                step,
+                element_count: (*reff).list_element_count(),
+                element_size: old_size,
+                struct_data_size: data_size,
+                struct_pointer_count: pointer_count as u16,
+            })
+        }
+    }
+
+    #[inline]
+    pub unsafe fn get_writable_struct_list_pointer(
+        arena: &mut dyn BuilderArena,
+        mut orig_ref: *mut WirePointer,
+        mut orig_segment_id: u32,
+        cap_table: CapTableBuilder,
+        element_size: StructSize,
+        default_value: *const u8,
+    ) -> Result<ListBuilder<'_>> {
+        let mut orig_ref_target = WirePointer::mut_target(orig_ref);
+
+        if (*orig_ref).is_null() {
+            if default_value.is_null() || (*(default_value as *const WirePointer)).is_null() {
+                return Ok(ListBuilder::new_default(arena));
+            }
+            let (new_orig_ref_target, new_orig_ref, new_orig_segment_id) = copy_message(
+                arena,
+                orig_segment_id,
+                cap_table,
+                orig_ref,
+                default_value as *const WirePointer,
+            );
+            orig_ref_target = new_orig_ref_target;
+            orig_ref = new_orig_ref;
+            orig_segment_id = new_orig_segment_id;
+        }
+
+        // We must verify that the pointer has the right size and potentially upgrade it if not.
+
+        let (mut old_ptr, old_ref, old_segment_id) =
+            follow_builder_fars(arena, orig_ref, orig_ref_target, orig_segment_id)?;
+
+        if (*old_ref).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(ErrorKind::ExistingPointerIsNotAList));
+        }
+
+        let old_size = (*old_ref).list_element_size();
+
+        if old_size == InlineComposite {
+            // Existing list is InlineComposite, but we need to verify that the sizes match.
+
+            let old_tag: *const WirePointer = old_ptr as *const _;
+            old_ptr = old_ptr.add(BYTES_PER_WORD);
+            if (*old_tag).kind() != WirePointerKind::Struct {
+                return Err(Error::from_kind(
+                    ErrorKind::InlineCompositeListWithNonStructElementsNotSupported,
+                ));
+            }
+
+            let old_data_size = (*old_tag).struct_data_size();
+            let old_pointer_count = (*old_tag).struct_ptr_count();
+            let old_step =
+                u32::from(old_data_size) + u32::from(old_pointer_count) * WORDS_PER_POINTER as u32;
+            let element_count = (*old_tag).inline_composite_list_element_count();
+
+            if old_data_size >= element_size.data && old_pointer_count >= element_size.pointers {
+                // Old size is at least as large as we need. Ship it.
+                return Ok(ListBuilder {
+                    arena,
+                    segment_id: old_segment_id,
+                    cap_table,
+                    ptr: old_ptr as *mut _,
+                    element_count,
+                    element_size: ElementSize::InlineComposite,
+                    step: old_step * BITS_PER_WORD as u32,
+                    struct_data_size: u32::from(old_data_size) * BITS_PER_WORD as u32,
+                    struct_pointer_count: old_pointer_count,
+                });
+            }
+
+            // The structs in this list are smaller than expected, probably written using an older
+            // version of the protocol. We need to make a copy and expand them.
+
+            let new_data_size = ::core::cmp::max(old_data_size, element_size.data);
+            let new_pointer_count = ::core::cmp::max(old_pointer_count, element_size.pointers);
+            let new_step =
+                u32::from(new_data_size) + u32::from(new_pointer_count) * WORDS_PER_POINTER as u32;
+            let total_size = new_step * element_count;
+
+            // Don't let allocate() zero out the object just yet.
+            zero_pointer_and_fars(arena, orig_segment_id, orig_ref)?;
+
+            let (mut new_ptr, new_ref, new_segment_id) = allocate(
+                arena,
+                orig_ref,
+                orig_segment_id,
+                total_size + POINTER_SIZE_IN_WORDS as u32,
+                WirePointerKind::List,
+            );
+            (*new_ref).set_list_inline_composite(total_size);
+
+            let new_tag: *mut WirePointer = new_ptr as *mut _;
+            (*new_tag).set_kind_and_inline_composite_list_element_count(
+                WirePointerKind::Struct,
+                element_count,
+            );
+            (*new_tag).set_struct_size_from_pieces(new_data_size, new_pointer_count);
+            new_ptr = new_ptr.add(BYTES_PER_WORD);
+
+            let mut src = old_ptr as *mut WirePointer;
+            let mut dst = new_ptr as *mut WirePointer;
+            for _ in 0..element_count {
+                // Copy data section.
+                ptr::copy_nonoverlapping(src, dst, old_data_size as usize);
+
+                // Copy pointer section
+                let new_pointer_section = dst.offset(new_data_size as isize);
+                let old_pointer_section = src.offset(old_data_size as isize);
+                for jj in 0..(old_pointer_count as isize) {
+                    transfer_pointer(
+                        arena,
+                        new_segment_id,
+                        new_pointer_section.offset(jj),
+                        old_segment_id,
+                        old_pointer_section.offset(jj),
+                    );
+                }
+
+                dst = dst.offset(new_step as isize);
+                src = src.offset(old_step as isize);
+            }
+
+            ptr::write_bytes(
+                old_ptr.offset(-(BYTES_PER_WORD as isize)),
+                0,
+                (u64::from(old_step) * u64::from(element_count)) as usize * BYTES_PER_WORD,
+            );
+
+            Ok(ListBuilder {
+                arena,
+                segment_id: new_segment_id,
+                cap_table,
+                ptr: new_ptr,
+                element_count,
+                element_size: ElementSize::InlineComposite,
+                step: new_step * BITS_PER_WORD as u32,
+                struct_data_size: u32::from(new_data_size) * BITS_PER_WORD as u32,
+                struct_pointer_count: new_pointer_count,
+            })
+        } else {
+            // We're upgrading from a non-struct list.
+
+            let old_data_size = data_bits_per_element(old_size);
+            let old_pointer_count = pointers_per_element(old_size);
+            let old_step = old_data_size + old_pointer_count * BITS_PER_POINTER as u32;
+            let element_count = (*old_ref).list_element_count();
+
+            if old_size == ElementSize::Void {
+                // Nothing to copy, just allocate a new list.
+                Ok(init_struct_list_pointer(
+                    arena,
+                    orig_ref,
+                    orig_segment_id,
+                    cap_table,
+                    element_count,
+                    element_size,
+                ))
+            } else {
+                // Upgrade to an inline composite list.
+
+                if old_size == ElementSize::Bit {
+                    return Err(Error::from_kind(
+                        ErrorKind::FoundBitListWhereStructListWasExpected,
+                    ));
+                }
+
+                let mut new_data_size = element_size.data;
+                let mut new_pointer_count = element_size.pointers;
+
+                if old_size == ElementSize::Pointer {
+                    new_pointer_count = ::core::cmp::max(new_pointer_count, 1);
+                } else {
+                    // Old list contains data elements, so we need at least one word of data.
+                    new_data_size = ::core::cmp::max(new_data_size, 1);
+                }
+
+                let new_step = u32::from(new_data_size)
+                    + u32::from(new_pointer_count) * WORDS_PER_POINTER as u32;
+                let total_words = element_count * new_step;
+
+                // Don't let allocate() zero out the object just yet.
+                zero_pointer_and_fars(arena, orig_segment_id, orig_ref)?;
+
+                let (mut new_ptr, new_ref, new_segment_id) = allocate(
+                    arena,
+                    orig_ref,
+                    orig_segment_id,
+                    total_words + POINTER_SIZE_IN_WORDS as u32,
+                    WirePointerKind::List,
+                );
+                (*new_ref).set_list_inline_composite(total_words);
+
+                let tag: *mut WirePointer = new_ptr as *mut _;
+                (*tag).set_kind_and_inline_composite_list_element_count(
+                    WirePointerKind::Struct,
+                    element_count,
+                );
+                (*tag).set_struct_size_from_pieces(new_data_size, new_pointer_count);
+                new_ptr = new_ptr.add(BYTES_PER_WORD);
+
+                if old_size == ElementSize::Pointer {
+                    let mut dst = new_ptr.offset(new_data_size as isize * BYTES_PER_WORD as isize);
+                    let mut src: *mut WirePointer = old_ptr as *mut _;
+                    for _ in 0..element_count {
+                        transfer_pointer(arena, new_segment_id, dst as *mut _, old_segment_id, src);
+                        dst = dst.offset(new_step as isize * BYTES_PER_WORD as isize);
+                        src = src.offset(1);
+                    }
+                } else {
+                    let mut dst = new_ptr;
+                    let mut src: *mut u8 = old_ptr;
+                    let old_byte_step = old_data_size / BITS_PER_BYTE as u32;
+                    for _ in 0..element_count {
+                        ptr::copy_nonoverlapping(src, dst, old_byte_step as usize);
+                        src = src.offset(old_byte_step as isize);
+                        dst = dst.offset(new_step as isize * BYTES_PER_WORD as isize);
+                    }
+                }
+
+                // Zero out old location.
+                ptr::write_bytes(
+                    old_ptr,
+                    0,
+                    round_bits_up_to_bytes(u64::from(old_step) * u64::from(element_count)) as usize,
+                );
+
+                Ok(ListBuilder {
+                    arena,
+                    segment_id: new_segment_id,
+                    cap_table,
+                    ptr: new_ptr,
+                    element_count,
+                    element_size: ElementSize::InlineComposite,
+                    step: new_step * BITS_PER_WORD as u32,
+                    struct_data_size: u32::from(new_data_size) * BITS_PER_WORD as u32,
+                    struct_pointer_count: new_pointer_count,
+                })
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn init_text_pointer(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        size: ByteCount32,
+    ) -> SegmentAnd<text::Builder<'_>> {
+        //# The byte list must include a NUL terminator.
+        let byte_size = size + 1;
+
+        //# Allocate the space.
+        let (ptr, reff, segment_id) = allocate(
+            arena,
+            reff,
+            segment_id,
+            round_bytes_up_to_words(byte_size),
+            WirePointerKind::List,
+        );
+
+        //# Initialize the pointer.
+        (*reff).set_list_size_and_count(Byte, byte_size);
+
+        SegmentAnd {
+            segment_id,
+            value: text::Builder::new(slice::from_raw_parts_mut(ptr, size as usize)),
+        }
+    }
+
+    #[inline]
+    pub unsafe fn set_text_pointer<'a>(
+        arena: &'a mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        value: crate::text::Reader<'_>,
+    ) -> SegmentAnd<text::Builder<'a>> {
+        let value_bytes = value.as_bytes();
+        // TODO make sure the string is not longer than 2 ** 29.
+        let mut allocation = init_text_pointer(arena, reff, segment_id, value_bytes.len() as u32);
+        allocation
+            .value
+            .reborrow()
+            .as_bytes_mut()
+            .copy_from_slice(value_bytes);
+        allocation
+    }
+
+    #[inline]
+    pub unsafe fn get_writable_text_pointer<'a>(
+        arena: &'a mut dyn BuilderArena,
+        mut reff: *mut WirePointer,
+        mut segment_id: u32,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<text::Builder<'a>> {
+        let ref_target = if (*reff).is_null() {
+            match default {
+                None => return Ok(text::Builder::new(&mut [])),
+                Some(d) => {
+                    let (new_ref_target, new_reff, new_segment_id) = copy_message(
+                        arena,
+                        segment_id,
+                        Default::default(),
+                        reff,
+                        d.as_ptr() as *const _,
+                    );
+                    reff = new_reff;
+                    segment_id = new_segment_id;
+                    new_ref_target
+                }
+            }
+        } else {
+            WirePointer::mut_target(reff)
+        };
+
+        let (ptr, reff, _segment_id) = follow_builder_fars(arena, reff, ref_target, segment_id)?;
+
+        if (*reff).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(ErrorKind::ExistingPointerIsNotAList));
+        }
+        if (*reff).list_element_size() != Byte {
+            return Err(Error::from_kind(
+                ErrorKind::ExistingListPointerIsNotByteSized,
+            ));
+        }
+
+        let count = (*reff).list_element_count();
+        if count == 0 || *ptr.offset((count - 1) as isize) != 0 {
+            return Err(Error::from_kind(ErrorKind::TextBlobMissingNULTerminator));
+        }
+
+        // Subtract 1 from the size for the NUL terminator.
+        Ok(text::Builder::with_pos(
+            slice::from_raw_parts_mut(ptr, (count - 1) as usize),
+            (count - 1) as usize,
+        ))
+    }
+
+    #[inline]
+    pub unsafe fn init_data_pointer(
+        arena: &mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        size: ByteCount32,
+    ) -> SegmentAnd<data::Builder<'_>> {
+        //# Allocate the space.
+        let (ptr, reff, segment_id) = allocate(
+            arena,
+            reff,
+            segment_id,
+            round_bytes_up_to_words(size),
+            WirePointerKind::List,
+        );
+
+        //# Initialize the pointer.
+        (*reff).set_list_size_and_count(Byte, size);
+
+        SegmentAnd {
+            segment_id,
+            value: data::builder_from_raw_parts(ptr, size),
+        }
+    }
+
+    #[inline]
+    pub unsafe fn set_data_pointer<'a>(
+        arena: &'a mut dyn BuilderArena,
+        reff: *mut WirePointer,
+        segment_id: u32,
+        value: &[u8],
+    ) -> SegmentAnd<data::Builder<'a>> {
+        let allocation = init_data_pointer(arena, reff, segment_id, value.len() as u32);
+        ptr::copy_nonoverlapping(value.as_ptr(), allocation.value.as_mut_ptr(), value.len());
+        allocation
+    }
+
+    #[inline]
+    pub unsafe fn get_writable_data_pointer<'a>(
+        arena: &'a mut dyn BuilderArena,
+        mut reff: *mut WirePointer,
+        mut segment_id: u32,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<data::Builder<'a>> {
+        let ref_target = if (*reff).is_null() {
+            match default {
+                None => return Ok(&mut []),
+                Some(d) => {
+                    let (new_ref_target, new_reff, new_segment_id) = copy_message(
+                        arena,
+                        segment_id,
+                        Default::default(),
+                        reff,
+                        d.as_ptr() as *const _,
+                    );
+                    reff = new_reff;
+                    segment_id = new_segment_id;
+                    new_ref_target
+                }
+            }
+        } else {
+            WirePointer::mut_target(reff)
+        };
+
+        let (ptr, reff, _segment_id) = follow_builder_fars(arena, reff, ref_target, segment_id)?;
+
+        if (*reff).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(ErrorKind::ExistingPointerIsNotAList));
+        }
+        if (*reff).list_element_size() != Byte {
+            return Err(Error::from_kind(
+                ErrorKind::ExistingListPointerIsNotByteSized,
+            ));
+        }
+
+        Ok(data::builder_from_raw_parts(
+            ptr,
+            (*reff).list_element_count(),
+        ))
+    }
+
+    pub unsafe fn set_struct_pointer(
+        arena: &mut dyn BuilderArena,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        reff: *mut WirePointer,
+        value: StructReader,
+        canonicalize: bool,
+    ) -> Result<SegmentAnd<*mut u8>> {
+        let mut data_size: ByteCount32 = round_bits_up_to_bytes(u64::from(value.data_size));
+        let mut ptr_count = value.pointer_count;
+
+        if canonicalize {
+            // StructReaders should not have bitwidths other than 1, but let's be safe
+            if !(value.data_size == 1 || value.data_size % BITS_PER_BYTE as u32 == 0) {
+                return Err(Error::from_kind(
+                    ErrorKind::StructReaderHadBitwidthOtherThan1,
+                ));
+            }
+
+            if value.data_size == 1 {
+                if !value.get_bool_field(0) {
+                    data_size = 0;
+                }
+            } else {
+                'chop: while data_size != 0 {
+                    let end = data_size;
+                    let mut window = data_size % BYTES_PER_WORD as u32;
+                    if window == 0 {
+                        window = BYTES_PER_WORD as u32;
+                    }
+                    let start = end - window;
+                    let last_word = &value.get_data_section_as_blob()[start as usize..end as usize];
+                    if last_word == [0; 8] {
+                        data_size -= window;
+                    } else {
+                        break 'chop;
+                    }
+                }
+            }
+
+            while ptr_count != 0 && value.get_pointer_field(ptr_count as usize - 1).is_null() {
+                ptr_count -= 1;
+            }
+        }
+
+        let data_words = round_bytes_up_to_words(data_size);
+        let total_size: WordCount32 = data_words + u32::from(ptr_count) * WORDS_PER_POINTER as u32;
+
+        let (ptr, reff, segment_id) =
+            allocate(arena, reff, segment_id, total_size, WirePointerKind::Struct);
+        (*reff).set_struct_size_from_pieces(data_words as u16, ptr_count);
+
+        if value.data_size == 1 {
+            // Data size could be made 0 by truncation
+            if data_size != 0 {
+                *ptr = u8::from(value.get_bool_field(0))
+            }
+        } else {
+            ptr::copy_nonoverlapping::<u8>(value.data, ptr, data_size as usize);
+        }
+
+        let pointer_section: *mut WirePointer =
+            ptr.offset(data_words as isize * BYTES_PER_WORD as isize) as *mut _;
+        for i in 0..ptr_count as isize {
+            copy_pointer(
+                arena,
+                segment_id,
+                cap_table,
+                pointer_section.offset(i),
+                value.arena,
+                value.segment_id,
+                value.cap_table,
+                value.pointers.offset(i),
+                value.nesting_limit,
+                canonicalize,
+            )?;
+        }
+
+        Ok(SegmentAnd {
+            segment_id,
+            value: ptr,
+        })
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn set_capability_pointer(
+        _arena: &mut dyn BuilderArena,
+        _segment_id: u32,
+        mut cap_table: CapTableBuilder,
+        reff: *mut WirePointer,
+        cap: Box<dyn ClientHook>,
+    ) {
+        // TODO if ref is not null, zero object.
+        unsafe {
+            (*reff).set_cap(cap_table.inject_cap(cap) as u32);
+        }
+    }
+
+    pub unsafe fn set_list_pointer(
+        arena: &mut dyn BuilderArena,
+        segment_id: u32,
+        cap_table: CapTableBuilder,
+        reff: *mut WirePointer,
+        value: ListReader,
+        canonicalize: bool,
+    ) -> Result<SegmentAnd<*mut u8>> {
+        let total_size =
+            round_bits_up_to_words(u64::from(value.element_count) * u64::from(value.step));
+
+        if value.element_size != ElementSize::InlineComposite {
+            //# List of non-structs.
+            let (ptr, reff, segment_id) =
+                allocate(arena, reff, segment_id, total_size, WirePointerKind::List);
+
+            if value.struct_pointer_count == 1 {
+                //# List of pointers.
+                (*reff).set_list_size_and_count(Pointer, value.element_count);
+                for i in 0..value.element_count as isize {
+                    copy_pointer(
+                        arena,
+                        segment_id,
+                        cap_table,
+                        (ptr as *mut WirePointer).offset(i),
+                        value.arena,
+                        value.segment_id,
+                        value.cap_table,
+                        (value.ptr as *const WirePointer).offset(i),
+                        value.nesting_limit,
+                        canonicalize,
+                    )?;
+                }
+            } else {
+                //# List of data.
+                let element_size = match value.step {
+                    0 => Void,
+                    1 => Bit,
+                    8 => Byte,
+                    16 => TwoBytes,
+                    32 => FourBytes,
+                    64 => EightBytes,
+                    _ => {
+                        panic!("invalid list step size: {}", value.step)
+                    }
+                };
+
+                (*reff).set_list_size_and_count(element_size, value.element_count);
+
+                // Be careful to avoid coping any bytes past the end of the list.
+                // TODO(perf) Is ptr::copy_nonoverlapping faster if word-aligned?
+                // If so, then perhaps we should only drop to the byte-index level
+                // in the canonicalize=true case.
+                let whole_byte_size =
+                    u64::from(value.element_count) * u64::from(value.step) / BITS_PER_BYTE as u64;
+                ptr::copy_nonoverlapping(value.ptr, ptr, whole_byte_size as usize);
+                let leftover_bits =
+                    u64::from(value.element_count) * u64::from(value.step) % BITS_PER_BYTE as u64;
+                if leftover_bits > 0 {
+                    let mask: u8 = (1 << leftover_bits as u8) - 1;
+
+                    *ptr.offset(whole_byte_size as isize) =
+                        mask & (*value.ptr.offset(whole_byte_size as isize))
+                }
+            }
+
+            Ok(SegmentAnd {
+                segment_id,
+                value: ptr,
+            })
+        } else {
+            //# List of structs.
+
+            let decl_data_size = value.struct_data_size / BITS_PER_WORD as u32;
+            let decl_pointer_count = value.struct_pointer_count;
+
+            let mut data_size = 0;
+            let mut ptr_count = 0;
+            let mut total_size = total_size;
+
+            if canonicalize {
+                for ec in 0..value.element_count {
+                    let se = value.get_struct_element(ec);
+                    let mut local_data_size = decl_data_size;
+                    'data_chop: while local_data_size != 0 {
+                        let end = local_data_size * BYTES_PER_WORD as u32;
+                        let window = BYTES_PER_WORD as u32;
+                        let start = end - window;
+                        let last_word =
+                            &se.get_data_section_as_blob()[start as usize..end as usize];
+                        if last_word != [0; 8] {
+                            break 'data_chop;
+                        } else {
+                            local_data_size -= 1;
+                        }
+                    }
+                    if local_data_size > data_size {
+                        data_size = local_data_size;
+                    }
+                    let mut local_ptr_count = decl_pointer_count;
+                    while local_ptr_count != 0
+                        && se.get_pointer_field(local_ptr_count as usize - 1).is_null()
+                    {
+                        local_ptr_count -= 1;
+                    }
+                    if local_ptr_count > ptr_count {
+                        ptr_count = local_ptr_count;
+                    }
+                }
+                total_size = (data_size + u32::from(ptr_count)) * value.element_count;
+            } else {
+                data_size = decl_data_size;
+                ptr_count = decl_pointer_count;
+            }
+
+            let (ptr, reff, segment_id) = allocate(
+                arena,
+                reff,
+                segment_id,
+                total_size + POINTER_SIZE_IN_WORDS as u32,
+                WirePointerKind::List,
+            );
+            (*reff).set_list_inline_composite(total_size);
+
+            let tag: *mut WirePointer = ptr as *mut _;
+            (*tag).set_kind_and_inline_composite_list_element_count(
+                WirePointerKind::Struct,
+                value.element_count,
+            );
+            (*tag).set_struct_size_from_pieces(data_size as u16, ptr_count);
+            let mut dst = ptr.add(BYTES_PER_WORD);
+
+            let mut src: *const u8 = value.ptr;
+            for _ in 0..value.element_count {
+                ptr::copy_nonoverlapping(src, dst, data_size as usize * BYTES_PER_WORD);
+                dst = dst.offset(data_size as isize * BYTES_PER_WORD as isize);
+                src = src.offset(decl_data_size as isize * BYTES_PER_WORD as isize);
+
+                for _ in 0..ptr_count {
+                    copy_pointer(
+                        arena,
+                        segment_id,
+                        cap_table,
+                        dst as *mut _,
+                        value.arena,
+                        value.segment_id,
+                        value.cap_table,
+                        src as *const WirePointer,
+                        value.nesting_limit,
+                        canonicalize,
+                    )?;
+                    dst = dst.add(BYTES_PER_WORD);
+                    src = src.add(BYTES_PER_WORD);
+                }
+
+                src =
+                    src.offset((decl_pointer_count - ptr_count) as isize * BYTES_PER_WORD as isize);
+            }
+            Ok(SegmentAnd {
+                segment_id,
+                value: ptr,
+            })
+        }
+    }
+
+    pub unsafe fn copy_pointer(
+        dst_arena: &mut dyn BuilderArena,
+        dst_segment_id: u32,
+        dst_cap_table: CapTableBuilder,
+        dst: *mut WirePointer,
+        src_arena: &dyn ReaderArena,
+        src_segment_id: u32,
+        src_cap_table: CapTableReader,
+        src: *const WirePointer,
+        nesting_limit: i32,
+        canonicalize: bool,
+    ) -> Result<SegmentAnd<*mut u8>> {
+        if (*src).is_null() {
+            ptr::write_bytes(dst, 0, 1);
+            return Ok(SegmentAnd {
+                segment_id: dst_segment_id,
+                value: ptr::null_mut(),
+            });
+        }
+
+        let (mut ptr, src, src_segment_id) = follow_fars(src_arena, src, src_segment_id)?;
+
+        match (*src).kind() {
+            WirePointerKind::Struct => {
+                if nesting_limit <= 0 {
+                    return Err(Error::from_kind(
+                        ErrorKind::MessageIsTooDeeplyNestedOrContainsCycles,
+                    ));
+                }
+
+                bounds_check(
+                    src_arena,
+                    src_segment_id,
+                    ptr,
+                    (*src).struct_word_size() as usize,
+                    WirePointerKind::Struct,
+                )?;
+
+                set_struct_pointer(
+                    dst_arena,
+                    dst_segment_id,
+                    dst_cap_table,
+                    dst,
+                    StructReader {
+                        arena: src_arena,
+                        segment_id: src_segment_id,
+                        cap_table: src_cap_table,
+                        data: ptr,
+                        pointers: ptr
+                            .offset((*src).struct_data_size() as isize * BYTES_PER_WORD as isize)
+                            as *const _,
+                        data_size: u32::from((*src).struct_data_size()) * BITS_PER_WORD as u32,
+                        pointer_count: (*src).struct_ptr_count(),
+                        nesting_limit: nesting_limit - 1,
+                    },
+                    canonicalize,
+                )
+            }
+            WirePointerKind::List => {
+                let element_size = (*src).list_element_size();
+                if nesting_limit <= 0 {
+                    return Err(Error::from_kind(
+                        ErrorKind::MessageIsTooDeeplyNestedOrContainsCycles,
+                    ));
+                }
+
+                if element_size == InlineComposite {
+                    let word_count = (*src).list_inline_composite_word_count();
+                    let tag: *const WirePointer = ptr as *const _;
+                    ptr = ptr.add(BYTES_PER_WORD);
+
+                    bounds_check(
+                        src_arena,
+                        src_segment_id,
+                        ptr.offset(-(BYTES_PER_WORD as isize)),
+                        word_count as usize + 1,
+                        WirePointerKind::List,
+                    )?;
+
+                    if (*tag).kind() != WirePointerKind::Struct {
+                        return Err(Error::from_kind(
+                            ErrorKind::InlineCompositeListsOfNonStructTypeAreNotSupported,
+                        ));
+                    }
+
+                    let element_count = (*tag).inline_composite_list_element_count();
+                    let words_per_element = (*tag).struct_word_size();
+
+                    if u64::from(words_per_element) * u64::from(element_count)
+                        > u64::from(word_count)
+                    {
+                        return Err(Error::from_kind(
+                            ErrorKind::InlineCompositeListsElementsOverrunItsWordCount,
+                        ));
+                    }
+
+                    if words_per_element == 0 {
+                        // Watch out for lists of zero-sized structs, which can claim to be
+                        // arbitrarily large without having sent actual data.
+                        amplified_read(src_arena, u64::from(element_count))?;
+                    }
+
+                    set_list_pointer(
+                        dst_arena,
+                        dst_segment_id,
+                        dst_cap_table,
+                        dst,
+                        ListReader {
+                            arena: src_arena,
+                            segment_id: src_segment_id,
+                            cap_table: src_cap_table,
+                            ptr: ptr as *const _,
+                            element_count,
+                            element_size,
+                            step: words_per_element * BITS_PER_WORD as u32,
+                            struct_data_size: u32::from((*tag).struct_data_size())
+                                * BITS_PER_WORD as u32,
+                            struct_pointer_count: (*tag).struct_ptr_count(),
+                            nesting_limit: nesting_limit - 1,
+                        },
+                        canonicalize,
+                    )
+                } else {
+                    let data_size = data_bits_per_element(element_size);
+                    let pointer_count = pointers_per_element(element_size);
+                    let step = data_size + pointer_count * BITS_PER_POINTER as u32;
+                    let element_count = (*src).list_element_count();
+                    let word_count =
+                        round_bits_up_to_words(u64::from(element_count) * u64::from(step));
+
+                    bounds_check(
+                        src_arena,
+                        src_segment_id,
+                        ptr,
+                        word_count as usize,
+                        WirePointerKind::List,
+                    )?;
+
+                    if element_size == Void {
+                        // Watch out for lists of void, which can claim to be arbitrarily large
+                        // without having sent actual data.
+                        amplified_read(src_arena, u64::from(element_count))?;
+                    }
+
+                    set_list_pointer(
+                        dst_arena,
+                        dst_segment_id,
+                        dst_cap_table,
+                        dst,
+                        ListReader {
+                            arena: src_arena,
+                            segment_id: src_segment_id,
+                            cap_table: src_cap_table,
+                            ptr: ptr as *const _,
+                            element_count,
+                            element_size,
+                            step,
+                            struct_data_size: data_size,
+                            struct_pointer_count: pointer_count as u16,
+                            nesting_limit: nesting_limit - 1,
+                        },
+                        canonicalize,
+                    )
+                }
+            }
+            WirePointerKind::Far => Err(Error::from_kind(ErrorKind::MalformedDoubleFarPointer)),
+            WirePointerKind::Other => {
+                if !(*src).is_capability() {
+                    return Err(Error::from_kind(ErrorKind::UnknownPointerType));
+                }
+                if canonicalize {
+                    return Err(Error::from_kind(
+                        ErrorKind::CannotCreateACanonicalMessageWithACapability,
+                    ));
+                }
+                #[cfg(feature = "alloc")]
+                match src_cap_table.extract_cap((*src).cap_index() as usize) {
+                    Some(cap) => {
+                        set_capability_pointer(dst_arena, dst_segment_id, dst_cap_table, dst, cap);
+                        Ok(SegmentAnd {
+                            segment_id: dst_segment_id,
+                            value: ptr::null_mut(),
+                        })
+                    }
+                    None => Err(Error::from_kind(
+                        ErrorKind::MessageContainsInvalidCapabilityPointer,
+                    )),
+                }
+                #[cfg(not(feature = "alloc"))]
+                return Err(Error::from_kind(ErrorKind::UnknownPointerType));
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn read_struct_pointer<'a>(
+        mut arena: &'a dyn ReaderArena,
+        mut segment_id: u32,
+        cap_table: CapTableReader,
+        mut reff: *const WirePointer,
+        default: Option<&'a [crate::Word]>,
+        nesting_limit: i32,
+    ) -> Result<StructReader<'a>> {
+        if (*reff).is_null() {
+            match default {
+                None => return Ok(StructReader::new_default()),
+                Some(d) if (*(d.as_ptr() as *const WirePointer)).is_null() => {
+                    return Ok(StructReader::new_default())
+                }
+                Some(d) => {
+                    reff = d.as_ptr() as *const _;
+                    arena = &super::NULL_ARENA;
+                    segment_id = 0;
+                }
+            }
+        }
+
+        if nesting_limit <= 0 {
+            return Err(Error::from_kind(
+                ErrorKind::MessageIsTooDeeplyNestedOrContainsCycles,
+            ));
+        }
+
+        let (ptr, reff, segment_id) = follow_fars(arena, reff, segment_id)?;
+
+        let data_size_words = (*reff).struct_data_size();
+
+        if (*reff).kind() != WirePointerKind::Struct {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsNonStructPointerWhereStructPointerWasExpected,
+            ));
+        }
+
+        bounds_check(
+            arena,
+            segment_id,
+            ptr,
+            (*reff).struct_word_size() as usize,
+            WirePointerKind::Struct,
+        )?;
+
+        Ok(StructReader {
+            arena,
+            segment_id,
+            cap_table,
+            data: ptr,
+            pointers: ptr.offset(data_size_words as isize * BYTES_PER_WORD as isize) as *const _,
+            data_size: u32::from(data_size_words) * BITS_PER_WORD as BitCount32,
+            pointer_count: (*reff).struct_ptr_count(),
+            nesting_limit: nesting_limit - 1,
+        })
+    }
+
+    #[inline]
+    #[cfg(feature = "alloc")]
+    pub unsafe fn read_capability_pointer(
+        _arena: &dyn ReaderArena,
+        _segment_id: u32,
+        cap_table: CapTableReader,
+        reff: *const WirePointer,
+        _nesting_limit: i32,
+    ) -> Result<Box<dyn ClientHook>> {
+        if (*reff).is_null() {
+            Err(Error::from_kind(
+                ErrorKind::MessageContainsNullCapabilityPointer,
+            ))
+        } else if !(*reff).is_capability() {
+            Err(Error::from_kind(
+                ErrorKind::MessageContainsNonCapabilityPointerWhereCapabilityPointerWasExpected,
+            ))
+        } else {
+            let n = (*reff).cap_index() as usize;
+            match cap_table.extract_cap(n) {
+                Some(client_hook) => Ok(client_hook),
+                None => Err(Error::from_kind(
+                    ErrorKind::MessageContainsInvalidCapabilityPointer,
+                )),
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn read_list_pointer(
+        mut arena: &dyn ReaderArena,
+        mut segment_id: u32,
+        cap_table: CapTableReader,
+        mut reff: *const WirePointer,
+        default_value: *const u8,
+        expected_element_size: Option<ElementSize>,
+        nesting_limit: i32,
+    ) -> Result<ListReader<'_>> {
+        if (*reff).is_null() {
+            if default_value.is_null() || (*(default_value as *const WirePointer)).is_null() {
+                return Ok(ListReader::new_default());
+            }
+            reff = default_value as *const _;
+            arena = &super::NULL_ARENA;
+            segment_id = 0;
+        }
+
+        if nesting_limit <= 0 {
+            return Err(Error::from_kind(ErrorKind::NestingLimitExceeded));
+        }
+        let (mut ptr, reff, segment_id) = follow_fars(arena, reff, segment_id)?;
+
+        if (*reff).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsNonListPointerWhereListPointerWasExpected,
+            ));
+        }
+
+        let element_size = (*reff).list_element_size();
+        match element_size {
+            InlineComposite => {
+                let word_count = (*reff).list_inline_composite_word_count();
+
+                let tag: *const WirePointer = ptr as *const WirePointer;
+
+                ptr = ptr.add(BYTES_PER_WORD);
+
+                bounds_check(
+                    arena,
+                    segment_id,
+                    ptr.offset(-(BYTES_PER_WORD as isize)),
+                    word_count as usize + 1,
+                    WirePointerKind::List,
+                )?;
+
+                if (*tag).kind() != WirePointerKind::Struct {
+                    return Err(Error::from_kind(
+                        ErrorKind::InlineCompositeListsOfNonStructTypeAreNotSupported,
+                    ));
+                }
+
+                let size = (*tag).inline_composite_list_element_count();
+                let data_size = (*tag).struct_data_size();
+                let ptr_count = (*tag).struct_ptr_count();
+                let words_per_element = (*tag).struct_word_size();
+
+                if u64::from(size) * u64::from(words_per_element) > u64::from(word_count) {
+                    return Err(Error::from_kind(
+                        ErrorKind::InlineCompositeListsElementsOverrunItsWordCount,
+                    ));
+                }
+
+                if words_per_element == 0 {
+                    // Watch out for lists of zero-sized structs, which can claim to be
+                    // arbitrarily large without having sent actual data.
+                    amplified_read(arena, u64::from(size))?;
+                }
+
+                // If a struct list was not expected, then presumably a non-struct list was upgraded
+                // to a struct list. We need to manipulate the pointer to point at the first field
+                // of the struct. Together with the `step` field, this will allow the struct list to
+                // be accessed as if it were a primitive list without branching.
+
+                // Check whether the size is compatible.
+                match expected_element_size {
+                    None | Some(Void | InlineComposite) => (),
+                    Some(Bit) => {
+                        return Err(Error::from_kind(
+                            ErrorKind::FoundStructListWhereBitListWasExpected,
+                        ));
+                    }
+                    Some(Byte | TwoBytes | FourBytes | EightBytes) => {
+                        if data_size == 0 {
+                            return Err(Error::from_kind(
+                                ErrorKind::ExpectedAPrimitiveListButGotAListOfPointerOnlyStructs,
+                            ));
+                        }
+                    }
+                    Some(Pointer) => {
+                        if ptr_count == 0 {
+                            return Err(Error::from_kind(
+                                ErrorKind::ExpectedAPointerListButGotAListOfDataOnlyStructs,
+                            ));
+                        }
+                    }
+                }
+
+                Ok(ListReader {
+                    arena,
+                    segment_id,
+                    cap_table,
+                    ptr: ptr as *const _,
+                    element_count: size,
+                    element_size,
+                    step: words_per_element * BITS_PER_WORD as u32,
+                    struct_data_size: u32::from(data_size) * (BITS_PER_WORD as u32),
+                    struct_pointer_count: ptr_count,
+                    nesting_limit: nesting_limit - 1,
+                })
+            }
+            _ => {
+                // This is a primitive or pointer list, but all such lists can also be interpreted
+                // as struct lists. We need to compute the data size and pointer count for such
+                // structs.
+                let data_size = data_bits_per_element((*reff).list_element_size());
+                let pointer_count = pointers_per_element((*reff).list_element_size());
+                let element_count = (*reff).list_element_count();
+                let step = data_size + pointer_count * BITS_PER_POINTER as u32;
+
+                let word_count = round_bits_up_to_words(u64::from(element_count) * u64::from(step));
+                bounds_check(
+                    arena,
+                    segment_id,
+                    ptr,
+                    word_count as usize,
+                    WirePointerKind::List,
+                )?;
+
+                if element_size == Void {
+                    // Watch out for lists of void, which can claim to be arbitrarily large
+                    // without having sent actual data.
+                    amplified_read(arena, u64::from(element_count))?;
+                }
+
+                if let Some(expected_element_size) = expected_element_size {
+                    if element_size == ElementSize::Bit && expected_element_size != ElementSize::Bit
+                    {
+                        return Err(Error::from_kind(
+                            ErrorKind::FoundBitListWhereStructListWasExpected,
+                        ));
+                    }
+
+                    // Verify that the elements are at least as large as the expected type. Note that if
+                    // we expected InlineComposite, the expected sizes here will be zero, because bounds
+                    // checking will be performed at field access time. So this check here is for the
+                    // case where we expected a list of some primitive or pointer type.
+
+                    let expected_data_bits_per_element =
+                        data_bits_per_element(expected_element_size);
+                    let expected_pointers_per_element = pointers_per_element(expected_element_size);
+
+                    if expected_data_bits_per_element > data_size
+                        || expected_pointers_per_element > pointer_count
+                    {
+                        return Err(Error::from_kind(
+                            ErrorKind::MessageContainsListWithIncompatibleElementType,
+                        ));
+                    }
+                }
+
+                Ok(ListReader {
+                    arena,
+                    segment_id,
+                    cap_table,
+                    ptr: ptr as *const _,
+                    element_count,
+                    element_size,
+                    step,
+                    struct_data_size: data_size,
+                    struct_pointer_count: pointer_count as u16,
+                    nesting_limit: nesting_limit - 1,
+                })
+            }
+        }
+    }
+
+    #[inline]
+    pub unsafe fn read_text_pointer<'a>(
+        mut arena: &'a dyn ReaderArena,
+        mut segment_id: u32,
+        mut reff: *const WirePointer,
+        default: Option<&[crate::Word]>,
+    ) -> Result<text::Reader<'a>> {
+        if (*reff).is_null() {
+            match default {
+                None => return Ok("".into()),
+                Some(d) => {
+                    reff = d.as_ptr() as *const WirePointer;
+                    arena = &super::NULL_ARENA;
+                    segment_id = 0;
+                }
+            }
+        }
+
+        let (ptr, reff, segment_id) = follow_fars(arena, reff, segment_id)?;
+        let size = (*reff).list_element_count();
+
+        if (*reff).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsNonListPointerWhereTextWasExpected,
+            ));
+        }
+
+        if (*reff).list_element_size() != Byte {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsListPointerOfNonBytesWhereTextWasExpected,
+            ));
+        }
+
+        bounds_check(
+            arena,
+            segment_id,
+            ptr,
+            round_bytes_up_to_words(size) as usize,
+            WirePointerKind::List,
+        )?;
+
+        if size == 0 {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsTextThatIsNotNULTerminated,
+            ));
+        }
+
+        let str_ptr = ptr;
+
+        if (*str_ptr.offset((size - 1) as isize)) != 0u8 {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsTextThatIsNotNULTerminated,
+            ));
+        }
+
+        Ok(text::Reader(slice::from_raw_parts(
+            str_ptr,
+            size as usize - 1,
+        )))
+    }
+
+    #[inline]
+    pub unsafe fn read_data_pointer<'a>(
+        mut arena: &'a dyn ReaderArena,
+        mut segment_id: u32,
+        mut reff: *const WirePointer,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<data::Reader<'a>> {
+        if (*reff).is_null() {
+            match default {
+                None => return Ok(&[]),
+                Some(d) => {
+                    reff = d.as_ptr() as *const WirePointer;
+                    arena = &super::NULL_ARENA;
+                    segment_id = 0;
+                }
+            }
+        }
+
+        let (ptr, reff, segment_id) = follow_fars(arena, reff, segment_id)?;
+
+        let size: u32 = (*reff).list_element_count();
+
+        if (*reff).kind() != WirePointerKind::List {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsNonListPointerWhereDataWasExpected,
+            ));
+        }
+
+        if (*reff).list_element_size() != Byte {
+            return Err(Error::from_kind(
+                ErrorKind::MessageContainsListPointerOfNonBytesWhereDataWasExpected,
+            ));
+        }
+
+        bounds_check(
+            arena,
+            segment_id,
+            ptr,
+            round_bytes_up_to_words(size) as usize,
+            WirePointerKind::List,
+        )?;
+
+        Ok(data::reader_from_raw_parts(ptr as *const _, size))
+    }
+}
+
+static ZERO: u64 = 0;
+fn zero_pointer() -> *const WirePointer {
+    &ZERO as *const _ as *const _
+}
+
+static NULL_ARENA: NullArena = NullArena;
+
+#[cfg(feature = "alloc")]
+pub type CapTable = Vec<Option<Box<dyn ClientHook>>>;
+
+#[cfg(not(feature = "alloc"))]
+pub struct CapTable;
+
+#[derive(Copy, Clone)]
+pub enum CapTableReader {
+    // At one point, we had a `Dummy` variant here, but that ended up
+    // making values of this type take 16 bytes of memory. Now we instead
+    // represent a null CapTableReader with `Plain(ptr::null())`.
+    Plain(*const CapTable),
+}
+
+impl Default for CapTableReader {
+    fn default() -> Self {
+        CapTableReader::Plain(ptr::null())
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl CapTableReader {
+    pub fn extract_cap(&self, index: usize) -> Option<Box<dyn ClientHook>> {
+        match *self {
+            Self::Plain(hooks) => {
+                if hooks.is_null() {
+                    return None;
+                }
+                let hooks: &Vec<Option<Box<dyn ClientHook>>> = unsafe { &*hooks };
+                if index >= hooks.len() {
+                    None
+                } else {
+                    hooks[index].as_ref().map(|hook| hook.add_ref())
+                }
+            }
+        }
+    }
+}
+
+#[derive(Copy, Clone)]
+pub enum CapTableBuilder {
+    // At one point, we had a `Dummy` variant here, but that ended up
+    // making values of this type take 16 bytes of memory. Now we instead
+    // represent a null CapTableBuilder with `Plain(ptr::null_mut())`.
+    Plain(*mut CapTable),
+}
+
+impl Default for CapTableBuilder {
+    fn default() -> Self {
+        CapTableBuilder::Plain(ptr::null_mut())
+    }
+}
+
+impl CapTableBuilder {
+    pub fn into_reader(self) -> CapTableReader {
+        match self {
+            Self::Plain(hooks) => CapTableReader::Plain(hooks),
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn extract_cap(&self, index: usize) -> Option<Box<dyn ClientHook>> {
+        match *self {
+            Self::Plain(hooks) => {
+                if hooks.is_null() {
+                    return None;
+                }
+                let hooks: &Vec<Option<Box<dyn ClientHook>>> = unsafe { &*hooks };
+                if index >= hooks.len() {
+                    None
+                } else {
+                    hooks[index].as_ref().map(|hook| hook.add_ref())
+                }
+            }
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn inject_cap(&mut self, cap: Box<dyn ClientHook>) -> usize {
+        match *self {
+            Self::Plain(hooks) => {
+                if hooks.is_null() {
+                    panic!(
+                        "Called inject_cap() on a null capability table. You need \
+                            to call imbue_mut() on this message before adding capabilities."
+                    );
+                }
+                let hooks: &mut Vec<Option<Box<dyn ClientHook>>> = unsafe { &mut *hooks };
+                hooks.push(Some(cap));
+                hooks.len() - 1
+            }
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn drop_cap(&mut self, index: usize) {
+        match *self {
+            Self::Plain(hooks) => {
+                if hooks.is_null() {
+                    panic!(
+                        "Called drop_cap() on a null capability table. You need \
+                            to call imbue_mut() on this message before adding capabilities."
+                    );
+                }
+                let hooks: &mut Vec<Option<Box<dyn ClientHook>>> = unsafe { &mut *hooks };
+                if index < hooks.len() {
+                    hooks[index] = None;
+                }
+            }
+        }
+    }
+}
+
+#[derive(Clone, Copy)]
+pub struct PointerReader<'a> {
+    arena: &'a dyn ReaderArena,
+    cap_table: CapTableReader,
+    pointer: *const WirePointer,
+    segment_id: u32,
+    nesting_limit: i32,
+}
+
+impl<'a> PointerReader<'a> {
+    pub fn new_default<'b>() -> PointerReader<'b> {
+        PointerReader {
+            arena: &NULL_ARENA,
+            segment_id: 0,
+            cap_table: Default::default(),
+            pointer: ptr::null(),
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn get_root(
+        arena: &'a dyn ReaderArena,
+        segment_id: u32,
+        location: *const u8,
+        nesting_limit: i32,
+    ) -> Result<Self> {
+        wire_helpers::bounds_check(
+            arena,
+            segment_id,
+            location as *const _,
+            POINTER_SIZE_IN_WORDS,
+            WirePointerKind::Struct,
+        )?;
+
+        Ok(PointerReader {
+            arena,
+            segment_id,
+            cap_table: Default::default(),
+            pointer: location as *const _,
+            nesting_limit,
+        })
+    }
+
+    pub fn reborrow(&self) -> PointerReader<'_> {
+        PointerReader {
+            arena: self.arena,
+            ..*self
+        }
+    }
+
+    pub unsafe fn get_root_unchecked<'b>(location: *const u8) -> PointerReader<'b> {
+        PointerReader {
+            arena: &NULL_ARENA,
+            segment_id: 0,
+            cap_table: Default::default(),
+            pointer: location as *const _,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn imbue(&mut self, cap_table: CapTableReader) {
+        self.cap_table = cap_table;
+    }
+
+    #[inline]
+    pub fn is_null(&self) -> bool {
+        self.pointer.is_null() || unsafe { (*self.pointer).is_null() }
+    }
+
+    pub fn total_size(&self) -> Result<MessageSize> {
+        if self.pointer.is_null() {
+            Ok(MessageSize {
+                word_count: 0,
+                cap_count: 0,
+            })
+        } else {
+            unsafe {
+                wire_helpers::total_size(
+                    self.arena,
+                    self.segment_id,
+                    self.pointer,
+                    self.nesting_limit,
+                )
+            }
+        }
+    }
+
+    pub fn get_struct(self, default: Option<&'a [crate::Word]>) -> Result<StructReader<'a>> {
+        let reff: *const WirePointer = if self.pointer.is_null() {
+            zero_pointer()
+        } else {
+            self.pointer
+        };
+        unsafe {
+            wire_helpers::read_struct_pointer(
+                self.arena,
+                self.segment_id,
+                self.cap_table,
+                reff,
+                default,
+                self.nesting_limit,
+            )
+        }
+    }
+
+    pub fn get_list(
+        self,
+        expected_element_size: ElementSize,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<ListReader<'a>> {
+        let default_value: *const u8 = match default {
+            None => core::ptr::null(),
+            Some(d) => d.as_ptr() as *const u8,
+        };
+        let reff = if self.pointer.is_null() {
+            zero_pointer()
+        } else {
+            self.pointer
+        };
+        unsafe {
+            wire_helpers::read_list_pointer(
+                self.arena,
+                self.segment_id,
+                self.cap_table,
+                reff,
+                default_value,
+                Some(expected_element_size),
+                self.nesting_limit,
+            )
+        }
+    }
+
+    fn get_list_any_size(self, default_value: *const u8) -> Result<ListReader<'a>> {
+        let reff = if self.pointer.is_null() {
+            zero_pointer()
+        } else {
+            self.pointer
+        };
+        unsafe {
+            wire_helpers::read_list_pointer(
+                self.arena,
+                self.segment_id,
+                self.cap_table,
+                reff,
+                default_value,
+                None,
+                self.nesting_limit,
+            )
+        }
+    }
+
+    pub fn get_text(self, default: Option<&[crate::Word]>) -> Result<text::Reader<'a>> {
+        let reff = if self.pointer.is_null() {
+            zero_pointer()
+        } else {
+            self.pointer
+        };
+        unsafe { wire_helpers::read_text_pointer(self.arena, self.segment_id, reff, default) }
+    }
+
+    pub fn get_data(&self, default: Option<&'a [crate::Word]>) -> Result<data::Reader<'a>> {
+        let reff = if self.pointer.is_null() {
+            zero_pointer()
+        } else {
+            self.pointer
+        };
+        unsafe { wire_helpers::read_data_pointer(self.arena, self.segment_id, reff, default) }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn get_capability(&self) -> Result<Box<dyn ClientHook>> {
+        let reff: *const WirePointer = if self.pointer.is_null() {
+            zero_pointer()
+        } else {
+            self.pointer
+        };
+        unsafe {
+            wire_helpers::read_capability_pointer(
+                self.arena,
+                self.segment_id,
+                self.cap_table,
+                reff,
+                self.nesting_limit,
+            )
+        }
+    }
+
+    pub fn get_pointer_type(&self) -> Result<PointerType> {
+        if self.is_null() {
+            Ok(PointerType::Null)
+        } else {
+            let (_, reff, _) =
+                unsafe { wire_helpers::follow_fars(self.arena, self.pointer, self.segment_id)? };
+
+            match unsafe { (*reff).kind() } {
+                WirePointerKind::Far => Err(Error::from_kind(ErrorKind::UnexepectedFarPointer)),
+                WirePointerKind::Struct => Ok(PointerType::Struct),
+                WirePointerKind::List => Ok(PointerType::List),
+                WirePointerKind::Other => {
+                    if unsafe { (*reff).is_capability() } {
+                        Ok(PointerType::Capability)
+                    } else {
+                        Err(Error::from_kind(ErrorKind::UnknownPointerType))
+                    }
+                }
+            }
+        }
+    }
+
+    pub fn is_canonical(&self, read_head: &Cell<*const u8>) -> Result<bool> {
+        if self.pointer.is_null() || unsafe { !(*self.pointer).is_positional() } {
+            return Ok(false);
+        }
+
+        match self.get_pointer_type()? {
+            PointerType::Null => Ok(true),
+            PointerType::Struct => {
+                let mut data_trunc = false;
+                let mut ptr_trunc = false;
+                let st = self.get_struct(None)?;
+                if st.get_data_section_size() == 0 && st.get_pointer_section_size() == 0 {
+                    Ok(self.pointer as *const _ == st.get_location())
+                } else {
+                    let result =
+                        st.is_canonical(read_head, read_head, &mut data_trunc, &mut ptr_trunc)?;
+                    Ok(result && data_trunc && ptr_trunc)
+                }
+            }
+            PointerType::List => unsafe {
+                self.get_list_any_size(ptr::null())?
+                    .is_canonical(read_head, self.pointer)
+            },
+            PointerType::Capability => Ok(false),
+        }
+    }
+}
+
+pub struct PointerBuilder<'a> {
+    arena: &'a mut dyn BuilderArena,
+    segment_id: u32,
+    cap_table: CapTableBuilder,
+    pointer: *mut WirePointer,
+}
+
+impl<'a> PointerBuilder<'a> {
+    #[inline]
+    pub fn get_root(arena: &'a mut dyn BuilderArena, segment_id: u32, location: *mut u8) -> Self {
+        PointerBuilder {
+            arena,
+            cap_table: Default::default(),
+            segment_id,
+            pointer: location as *mut _,
+        }
+    }
+
+    #[inline]
+    pub fn reborrow(&mut self) -> PointerBuilder<'_> {
+        PointerBuilder {
+            arena: self.arena,
+            ..*self
+        }
+    }
+
+    pub fn imbue(&mut self, cap_table: CapTableBuilder) {
+        self.cap_table = cap_table;
+    }
+
+    #[inline]
+    pub fn is_null(&self) -> bool {
+        unsafe { (*self.pointer).is_null() }
+    }
+
+    pub fn get_struct(
+        self,
+        size: StructSize,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<StructBuilder<'a>> {
+        unsafe {
+            wire_helpers::get_writable_struct_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                self.cap_table,
+                size,
+                default,
+            )
+        }
+    }
+
+    pub fn get_list(
+        self,
+        element_size: ElementSize,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<ListBuilder<'a>> {
+        let default_value: *const u8 = match default {
+            None => core::ptr::null(),
+            Some(d) => d.as_ptr() as *const u8,
+        };
+        unsafe {
+            wire_helpers::get_writable_list_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                self.cap_table,
+                element_size,
+                default_value,
+            )
+        }
+    }
+
+    pub fn get_struct_list(
+        self,
+        element_size: StructSize,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<ListBuilder<'a>> {
+        let default_value: *const u8 = match default {
+            None => core::ptr::null(),
+            Some(d) => d.as_ptr() as *const u8,
+        };
+        unsafe {
+            wire_helpers::get_writable_struct_list_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                self.cap_table,
+                element_size,
+                default_value,
+            )
+        }
+    }
+
+    pub fn get_text(self, default: Option<&'a [crate::Word]>) -> Result<text::Builder<'a>> {
+        unsafe {
+            wire_helpers::get_writable_text_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                default,
+            )
+        }
+    }
+
+    pub fn get_data(self, default: Option<&'a [crate::Word]>) -> Result<data::Builder<'a>> {
+        unsafe {
+            wire_helpers::get_writable_data_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                default,
+            )
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn get_capability(&self) -> Result<Box<dyn ClientHook>> {
+        unsafe {
+            wire_helpers::read_capability_pointer(
+                self.arena.as_reader(),
+                self.segment_id,
+                self.cap_table.into_reader(),
+                self.pointer,
+                ::core::i32::MAX,
+            )
+        }
+    }
+
+    pub fn init_struct(self, size: StructSize) -> StructBuilder<'a> {
+        unsafe {
+            wire_helpers::init_struct_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                self.cap_table,
+                size,
+            )
+        }
+    }
+
+    pub fn init_list(
+        self,
+        element_size: ElementSize,
+        element_count: ElementCount32,
+    ) -> ListBuilder<'a> {
+        unsafe {
+            wire_helpers::init_list_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                self.cap_table,
+                element_count,
+                element_size,
+            )
+        }
+    }
+
+    pub fn init_struct_list(
+        self,
+        element_count: ElementCount32,
+        element_size: StructSize,
+    ) -> ListBuilder<'a> {
+        unsafe {
+            wire_helpers::init_struct_list_pointer(
+                self.arena,
+                self.pointer,
+                self.segment_id,
+                self.cap_table,
+                element_count,
+                element_size,
+            )
+        }
+    }
+
+    pub fn init_text(self, size: ByteCount32) -> text::Builder<'a> {
+        unsafe {
+            wire_helpers::init_text_pointer(self.arena, self.pointer, self.segment_id, size).value
+        }
+    }
+
+    pub fn init_data(self, size: ByteCount32) -> data::Builder<'a> {
+        unsafe {
+            wire_helpers::init_data_pointer(self.arena, self.pointer, self.segment_id, size).value
+        }
+    }
+
+    pub fn set_struct(&mut self, value: &StructReader, canonicalize: bool) -> Result<()> {
+        unsafe {
+            wire_helpers::set_struct_pointer(
+                self.arena,
+                self.segment_id,
+                self.cap_table,
+                self.pointer,
+                *value,
+                canonicalize,
+            )?;
+            Ok(())
+        }
+    }
+
+    pub fn set_list(&mut self, value: &ListReader, canonicalize: bool) -> Result<()> {
+        unsafe {
+            wire_helpers::set_list_pointer(
+                self.arena,
+                self.segment_id,
+                self.cap_table,
+                self.pointer,
+                *value,
+                canonicalize,
+            )?;
+            Ok(())
+        }
+    }
+
+    pub fn set_text(&mut self, value: crate::text::Reader<'_>) {
+        unsafe {
+            wire_helpers::set_text_pointer(self.arena, self.pointer, self.segment_id, value);
+        }
+    }
+
+    pub fn set_data(&mut self, value: &[u8]) {
+        unsafe {
+            wire_helpers::set_data_pointer(self.arena, self.pointer, self.segment_id, value);
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    pub fn set_capability(&mut self, cap: Box<dyn ClientHook>) {
+        wire_helpers::set_capability_pointer(
+            self.arena,
+            self.segment_id,
+            self.cap_table,
+            self.pointer,
+            cap,
+        );
+    }
+
+    pub fn copy_from(&mut self, other: PointerReader, canonicalize: bool) -> Result<()> {
+        if other.pointer.is_null() {
+            if !self.pointer.is_null() {
+                unsafe {
+                    wire_helpers::zero_object(self.arena, self.segment_id, self.pointer);
+                    *self.pointer = mem::zeroed();
+                }
+            }
+        } else {
+            unsafe {
+                wire_helpers::copy_pointer(
+                    self.arena,
+                    self.segment_id,
+                    self.cap_table,
+                    self.pointer,
+                    other.arena,
+                    other.segment_id,
+                    other.cap_table,
+                    other.pointer,
+                    other.nesting_limit,
+                    canonicalize,
+                )?;
+            }
+        }
+        Ok(())
+    }
+
+    pub fn clear(&mut self) {
+        unsafe {
+            wire_helpers::zero_object(self.arena, self.segment_id, self.pointer);
+            ptr::write_bytes(self.pointer, 0, 1);
+        }
+    }
+
+    pub fn as_reader(&self) -> PointerReader<'_> {
+        PointerReader {
+            arena: self.arena.as_reader(),
+            segment_id: self.segment_id,
+            cap_table: self.cap_table.into_reader(),
+            pointer: self.pointer,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn into_reader(self) -> PointerReader<'a> {
+        PointerReader {
+            arena: self.arena.as_reader(),
+            segment_id: self.segment_id,
+            cap_table: self.cap_table.into_reader(),
+            pointer: self.pointer,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+}
+
+#[derive(Clone, Copy)]
+pub struct StructReader<'a> {
+    arena: &'a dyn ReaderArena,
+    cap_table: CapTableReader,
+    data: *const u8,
+    pointers: *const WirePointer,
+    segment_id: u32,
+    data_size: BitCount32,
+    pointer_count: WirePointerCount16,
+    nesting_limit: i32,
+}
+
+impl<'a> StructReader<'a> {
+    pub fn new_default<'b>() -> StructReader<'b> {
+        StructReader {
+            arena: &NULL_ARENA,
+            segment_id: 0,
+            cap_table: Default::default(),
+            data: ptr::null(),
+            pointers: ptr::null(),
+            data_size: 0,
+            pointer_count: 0,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn imbue(&mut self, cap_table: CapTableReader) {
+        self.cap_table = cap_table
+    }
+
+    pub fn get_data_section_size(&self) -> BitCount32 {
+        self.data_size
+    }
+
+    pub fn get_pointer_section_size(&self) -> WirePointerCount16 {
+        self.pointer_count
+    }
+
+    pub fn get_pointer_section_as_list(&self) -> ListReader<'a> {
+        ListReader {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            ptr: self.pointers as *const _,
+            element_count: u32::from(self.pointer_count),
+            element_size: ElementSize::Pointer,
+            step: BITS_PER_WORD as BitCount32,
+            struct_data_size: 0,
+            struct_pointer_count: 0,
+            nesting_limit: self.nesting_limit,
+        }
+    }
+
+    pub fn get_data_section_as_blob(&self) -> &'a [u8] {
+        if self.data_size == 0 {
+            // Explictly handle this case to avoid forming a slice to a null pointer,
+            // which would be undefined behavior.
+            &[]
+        } else {
+            unsafe {
+                ::core::slice::from_raw_parts(self.data, self.data_size as usize / BITS_PER_BYTE)
+            }
+        }
+    }
+
+    #[inline]
+    pub fn get_data_field<T: Primitive + zero::Zero>(&self, offset: ElementCount) -> T {
+        // We need to check the offset because the struct may have
+        // been created with an old version of the protocol that did
+        // not contain the field.
+        if (offset + 1) * bits_per_element::<T>() <= self.data_size as usize {
+            let dwv: *const <T as Primitive>::Raw = self.data as *const _;
+            unsafe { <T as Primitive>::get(&*dwv.add(offset)) }
+        } else {
+            T::zero()
+        }
+    }
+
+    #[inline]
+    pub fn get_bool_field(&self, offset: ElementCount) -> bool {
+        let boffset: BitCount32 = offset as BitCount32;
+        if boffset < self.data_size {
+            unsafe {
+                let b: *const u8 = self.data.add(boffset as usize / BITS_PER_BYTE);
+                ((*b) & (1u8 << (boffset % BITS_PER_BYTE as u32) as usize)) != 0
+            }
+        } else {
+            false
+        }
+    }
+
+    #[inline]
+    pub fn get_data_field_mask<T: Primitive + zero::Zero + Mask>(
+        &self,
+        offset: ElementCount,
+        mask: <T as Mask>::T,
+    ) -> T {
+        Mask::mask(self.get_data_field(offset), mask)
+    }
+
+    #[inline]
+    pub fn get_bool_field_mask(&self, offset: ElementCount, mask: bool) -> bool {
+        self.get_bool_field(offset) ^ mask
+    }
+
+    #[inline]
+    pub fn get_pointer_field(&self, ptr_index: WirePointerCount) -> PointerReader<'a> {
+        if ptr_index < self.pointer_count as WirePointerCount {
+            PointerReader {
+                arena: self.arena,
+                segment_id: self.segment_id,
+                cap_table: self.cap_table,
+                pointer: unsafe { self.pointers.add(ptr_index) },
+                nesting_limit: self.nesting_limit,
+            }
+        } else {
+            PointerReader::new_default()
+        }
+    }
+
+    #[inline]
+    pub fn is_pointer_field_null(&self, ptr_index: WirePointerCount) -> bool {
+        if ptr_index < self.pointer_count as WirePointerCount {
+            unsafe { (*self.pointers.add(ptr_index)).is_null() }
+        } else {
+            true
+        }
+    }
+
+    pub fn total_size(&self) -> Result<MessageSize> {
+        let mut result = MessageSize {
+            word_count: u64::from(wire_helpers::round_bits_up_to_words(u64::from(
+                self.data_size,
+            ))) + u64::from(self.pointer_count) * WORDS_PER_POINTER as u64,
+            cap_count: 0,
+        };
+
+        for i in 0..self.pointer_count as isize {
+            unsafe {
+                result += wire_helpers::total_size(
+                    self.arena,
+                    self.segment_id,
+                    self.pointers.offset(i),
+                    self.nesting_limit,
+                )?;
+            }
+        }
+
+        // TODO when we have read limiting: segment->unread()
+
+        Ok(result)
+    }
+
+    fn get_location(&self) -> *const u8 {
+        self.data
+    }
+
+    pub fn is_canonical(
+        &self,
+        read_head: &Cell<*const u8>,
+        ptr_head: &Cell<*const u8>,
+        data_trunc: &mut bool,
+        ptr_trunc: &mut bool,
+    ) -> Result<bool> {
+        if self.get_location() != read_head.get() {
+            return Ok(false);
+        }
+
+        if self.get_data_section_size() % BITS_PER_WORD as u32 != 0 {
+            // legacy non-word-size struct
+            return Ok(false);
+        }
+
+        let data_size = self.get_data_section_size() / BITS_PER_WORD as u32;
+
+        // mark whether the struct is properly truncated
+        if data_size != 0 {
+            *data_trunc = self.get_data_field::<u64>((data_size - 1) as usize) != 0;
+        } else {
+            *data_trunc = true;
+        }
+
+        if self.pointer_count != 0 {
+            *ptr_trunc = !self
+                .get_pointer_field(self.pointer_count as usize - 1)
+                .is_null();
+        } else {
+            *ptr_trunc = true;
+        }
+
+        read_head.set(unsafe {
+            (read_head.get()).offset(
+                (data_size as isize + self.pointer_count as isize) * (BYTES_PER_WORD as isize),
+            )
+        });
+
+        for ptr_idx in 0..self.pointer_count {
+            if !self
+                .get_pointer_field(ptr_idx as usize)
+                .is_canonical(ptr_head)?
+            {
+                return Ok(false);
+            }
+        }
+
+        Ok(true)
+    }
+}
+
+pub struct StructBuilder<'a> {
+    arena: &'a mut dyn BuilderArena,
+    cap_table: CapTableBuilder,
+    data: *mut u8,
+    pointers: *mut WirePointer,
+    segment_id: u32,
+    data_size: BitCount32,
+    pointer_count: WirePointerCount16,
+}
+
+impl<'a> StructBuilder<'a> {
+    #[inline]
+    pub fn reborrow(&mut self) -> StructBuilder<'_> {
+        StructBuilder {
+            arena: self.arena,
+            ..*self
+        }
+    }
+
+    pub fn as_reader(&self) -> StructReader<'_> {
+        StructReader {
+            arena: self.arena.as_reader(),
+            cap_table: self.cap_table.into_reader(),
+            data: self.data,
+            pointers: self.pointers,
+            pointer_count: self.pointer_count,
+            segment_id: self.segment_id,
+            data_size: self.data_size,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn into_reader(self) -> StructReader<'a> {
+        StructReader {
+            arena: self.arena.as_reader(),
+            cap_table: self.cap_table.into_reader(),
+            data: self.data,
+            pointers: self.pointers,
+            pointer_count: self.pointer_count,
+            segment_id: self.segment_id,
+            data_size: self.data_size,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn imbue(&mut self, cap_table: CapTableBuilder) {
+        self.cap_table = cap_table
+    }
+
+    #[inline]
+    pub fn set_data_field<T: Primitive>(&self, offset: ElementCount, value: T) {
+        let ptr: *mut <T as Primitive>::Raw = self.data as *mut _;
+        unsafe { <T as Primitive>::set(&mut *ptr.add(offset), value) }
+    }
+
+    #[inline]
+    pub fn set_data_field_mask<T: Primitive + Mask>(
+        &self,
+        offset: ElementCount,
+        value: T,
+        mask: <T as Mask>::T,
+    ) {
+        self.set_data_field(offset, Mask::mask(value, mask));
+    }
+
+    #[inline]
+    pub fn get_data_field<T: Primitive>(&self, offset: ElementCount) -> T {
+        let ptr: *const <T as Primitive>::Raw = self.data as *const _;
+        unsafe { <T as Primitive>::get(&*ptr.add(offset)) }
+    }
+
+    #[inline]
+    pub fn get_data_field_mask<T: Primitive + Mask>(
+        &self,
+        offset: ElementCount,
+        mask: <T as Mask>::T,
+    ) -> T {
+        Mask::mask(self.get_data_field(offset), mask)
+    }
+
+    #[inline]
+    pub fn set_bool_field(&self, offset: ElementCount, value: bool) {
+        //# This branch should be compiled out whenever this is
+        //# inlined with a constant offset.
+        let boffset: BitCount0 = offset;
+        let b = unsafe { self.data.add(boffset / BITS_PER_BYTE) };
+        let bitnum = boffset % BITS_PER_BYTE;
+        unsafe { (*b) = ((*b) & !(1 << bitnum)) | (u8::from(value) << bitnum) }
+    }
+
+    #[inline]
+    pub fn set_bool_field_mask(&self, offset: ElementCount, value: bool, mask: bool) {
+        self.set_bool_field(offset, value ^ mask);
+    }
+
+    #[inline]
+    pub fn get_bool_field(&self, offset: ElementCount) -> bool {
+        let boffset: BitCount0 = offset;
+        let b = unsafe { self.data.add(boffset / BITS_PER_BYTE) };
+        unsafe { ((*b) & (1 << (boffset % BITS_PER_BYTE))) != 0 }
+    }
+
+    #[inline]
+    pub fn get_bool_field_mask(&self, offset: ElementCount, mask: bool) -> bool {
+        self.get_bool_field(offset) ^ mask
+    }
+
+    #[inline]
+    pub fn get_pointer_field(self, ptr_index: WirePointerCount) -> PointerBuilder<'a> {
+        PointerBuilder {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            pointer: unsafe { self.pointers.add(ptr_index) },
+        }
+    }
+
+    #[inline]
+    pub fn get_pointer_field_mut(&mut self, ptr_index: WirePointerCount) -> PointerBuilder<'_> {
+        PointerBuilder {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            pointer: unsafe { self.pointers.add(ptr_index) },
+        }
+    }
+
+    #[inline]
+    pub fn is_pointer_field_null(&self, ptr_index: WirePointerCount) -> bool {
+        unsafe { (*self.pointers.add(ptr_index)).is_null() }
+    }
+
+    pub fn copy_content_from(&mut self, other: &StructReader) -> Result<()> {
+        use core::cmp::min;
+        // Determine the amount of data the builders have in common.
+        let shared_data_size = min(self.data_size, other.data_size);
+        let shared_pointer_count = min(self.pointer_count, other.pointer_count);
+
+        if (shared_data_size > 0 && other.data == self.data)
+            || (shared_pointer_count > 0 && other.pointers == self.pointers)
+        {
+            // At least one of the section pointers is pointing to ourself. Verify that the other is too
+            // (but ignore empty sections).
+            if (shared_data_size == 0 || other.data == self.data)
+                && (shared_pointer_count == 0 || other.pointers == self.pointers)
+            {
+                return Err(Error::from_kind(
+                    ErrorKind::OnlyOneOfTheSectionPointersIsPointingToOurself,
+                ));
+            }
+
+            // So `other` appears to be a reader for this same struct. No copying is needed.
+            return Ok(());
+        }
+
+        unsafe {
+            if self.data_size > shared_data_size {
+                // Since the target is larger than the source, make sure to zero out the extra bits that the
+                // source doesn't have.
+                if self.data_size == 1 {
+                    self.set_bool_field(0, false);
+                } else {
+                    let unshared = self
+                        .data
+                        .offset((shared_data_size / BITS_PER_BYTE as u32) as isize);
+                    ptr::write_bytes(
+                        unshared,
+                        0,
+                        ((self.data_size - shared_data_size) / BITS_PER_BYTE as u32) as usize,
+                    );
+                }
+            }
+
+            // Copy over the shared part.
+            if shared_data_size == 1 {
+                self.set_bool_field(0, other.get_bool_field(0));
+            } else {
+                ptr::copy_nonoverlapping(
+                    other.data,
+                    self.data,
+                    (shared_data_size / BITS_PER_BYTE as u32) as usize,
+                );
+            }
+
+            // Zero out all pointers in the target.
+            for i in 0..self.pointer_count as isize {
+                wire_helpers::zero_object(
+                    self.arena,
+                    self.segment_id,
+                    self.pointers.offset(i) as *mut _,
+                );
+            }
+            ptr::write_bytes(self.pointers, 0u8, self.pointer_count as usize);
+
+            for i in 0..shared_pointer_count as isize {
+                wire_helpers::copy_pointer(
+                    self.arena,
+                    self.segment_id,
+                    self.cap_table,
+                    self.pointers.offset(i),
+                    other.arena,
+                    other.segment_id,
+                    other.cap_table,
+                    other.pointers.offset(i),
+                    other.nesting_limit,
+                    false,
+                )?;
+            }
+        }
+
+        Ok(())
+    }
+}
+
+#[derive(Clone, Copy)]
+pub struct ListReader<'a> {
+    arena: &'a dyn ReaderArena,
+    cap_table: CapTableReader,
+    ptr: *const u8,
+    segment_id: u32,
+    element_count: ElementCount32,
+    step: BitCount32,
+    struct_data_size: BitCount32,
+    nesting_limit: i32,
+    struct_pointer_count: WirePointerCount16,
+    element_size: ElementSize,
+}
+
+impl<'a> ListReader<'a> {
+    pub fn new_default<'b>() -> ListReader<'b> {
+        ListReader {
+            arena: &NULL_ARENA,
+            segment_id: 0,
+            cap_table: Default::default(),
+            ptr: ptr::null(),
+            element_count: 0,
+            element_size: ElementSize::Void,
+            step: 0,
+            struct_data_size: 0,
+            struct_pointer_count: 0,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    pub fn imbue(&mut self, cap_table: CapTableReader) {
+        self.cap_table = cap_table
+    }
+
+    #[inline]
+    pub fn len(&self) -> ElementCount32 {
+        self.element_count
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub(crate) fn get_step_size_in_bits(&self) -> u32 {
+        self.step
+    }
+
+    pub(crate) fn get_element_size(&self) -> ElementSize {
+        self.element_size
+    }
+
+    pub(crate) fn into_raw_bytes(self) -> &'a [u8] {
+        if self.element_count == 0 {
+            // Explictly handle this case to avoid forming a slice to a null pointer,
+            // which would be undefined behavior.
+            &[]
+        } else {
+            let num_bytes = wire_helpers::round_bits_up_to_bytes(
+                u64::from(self.step) * u64::from(self.element_count),
+            ) as usize;
+            unsafe { ::core::slice::from_raw_parts(self.ptr, num_bytes) }
+        }
+    }
+
+    #[inline]
+    pub fn get_struct_element(&self, index: ElementCount32) -> StructReader<'a> {
+        let index_byte: ByteCount32 =
+            ((u64::from(index) * u64::from(self.step)) / BITS_PER_BYTE as u64) as u32;
+
+        let struct_data: *const u8 = unsafe { self.ptr.offset(index_byte as isize) };
+
+        let struct_pointers: *const WirePointer =
+            unsafe { struct_data.add(self.struct_data_size as usize / BITS_PER_BYTE) as *const _ };
+
+        StructReader {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            data: struct_data,
+            pointers: struct_pointers,
+            data_size: self.struct_data_size,
+            pointer_count: self.struct_pointer_count,
+            nesting_limit: self.nesting_limit - 1,
+        }
+    }
+
+    #[inline]
+    pub fn get_pointer_element(self, index: ElementCount32) -> PointerReader<'a> {
+        let offset = (self.struct_data_size as u64 / BITS_PER_BYTE as u64
+            + u64::from(index) * u64::from(self.step) / BITS_PER_BYTE as u64)
+            as isize;
+        PointerReader {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            pointer: unsafe { self.ptr.offset(offset) } as *const _,
+            nesting_limit: self.nesting_limit,
+        }
+    }
+
+    pub unsafe fn is_canonical(
+        &self,
+        read_head: &Cell<*const u8>,
+        reff: *const WirePointer,
+    ) -> Result<bool> {
+        match self.element_size {
+            ElementSize::InlineComposite => {
+                read_head.set(unsafe { read_head.get().add(BYTES_PER_WORD) }); // tag word
+                if self.ptr as *const _ != read_head.get() {
+                    return Ok(false);
+                }
+                if self.struct_data_size % BITS_PER_WORD as u32 != 0 {
+                    return Ok(false);
+                }
+                let struct_size = (self.struct_data_size / BITS_PER_WORD as u32)
+                    + u32::from(self.struct_pointer_count);
+                let word_count = unsafe { (*reff).list_inline_composite_word_count() };
+                if struct_size * self.element_count != word_count {
+                    return Ok(false);
+                }
+                if struct_size == 0 {
+                    return Ok(true);
+                }
+                let list_end = unsafe {
+                    read_head
+                        .get()
+                        .add((self.element_count * struct_size) as usize * BYTES_PER_WORD)
+                };
+                let pointer_head = Cell::new(list_end);
+                let mut list_data_trunc = false;
+                let mut list_ptr_trunc = false;
+                for idx in 0..self.element_count {
+                    let mut data_trunc = false;
+                    let mut ptr_trunc = false;
+                    if !self.get_struct_element(idx).is_canonical(
+                        read_head,
+                        &pointer_head,
+                        &mut data_trunc,
+                        &mut ptr_trunc,
+                    )? {
+                        return Ok(false);
+                    }
+                    list_data_trunc |= data_trunc;
+                    list_ptr_trunc |= ptr_trunc;
+                }
+                assert_eq!(read_head.get(), list_end);
+                read_head.set(pointer_head.get());
+                Ok(list_data_trunc && list_ptr_trunc)
+            }
+            ElementSize::Pointer => {
+                if self.ptr as *const _ != read_head.get() {
+                    return Ok(false);
+                }
+                read_head.set(unsafe {
+                    read_head
+                        .get()
+                        .offset(self.element_count as isize * BYTES_PER_WORD as isize)
+                });
+                for idx in 0..self.element_count {
+                    if !self.get_pointer_element(idx).is_canonical(read_head)? {
+                        return Ok(false);
+                    }
+                }
+                Ok(true)
+            }
+            element_size => {
+                if self.ptr != read_head.get() as *const _ {
+                    return Ok(false);
+                }
+                let bit_size =
+                    u64::from(self.element_count) * u64::from(data_bits_per_element(element_size));
+                let mut word_size = bit_size / BITS_PER_WORD as u64;
+                if bit_size % BITS_PER_WORD as u64 != 0 {
+                    word_size += 1
+                }
+
+                let byte_size = bit_size / BITS_PER_BYTE as u64;
+                let mut byte_read_head: *const u8 = read_head.get();
+                byte_read_head = unsafe { byte_read_head.offset(byte_size as isize) };
+                let read_head_end = unsafe {
+                    read_head
+                        .get()
+                        .offset(word_size as isize * BYTES_PER_WORD as isize)
+                };
+
+                let leftover_bits = bit_size % BITS_PER_BYTE as u64;
+                if leftover_bits > 0 {
+                    let mask: u8 = !((1 << leftover_bits as u8) - 1);
+                    let partial_byte = unsafe { *byte_read_head };
+
+                    if partial_byte & mask != 0 {
+                        return Ok(false);
+                    }
+                    byte_read_head = unsafe { byte_read_head.offset(1_isize) };
+                }
+
+                while byte_read_head != read_head_end {
+                    if unsafe { *byte_read_head } != 0 {
+                        return Ok(false);
+                    }
+                    byte_read_head = unsafe { byte_read_head.offset(1_isize) };
+                }
+
+                read_head.set(read_head_end);
+                Ok(true)
+            }
+        }
+    }
+}
+
+pub struct ListBuilder<'a> {
+    arena: &'a mut dyn BuilderArena,
+    cap_table: CapTableBuilder,
+    ptr: *mut u8,
+    segment_id: u32,
+    element_count: ElementCount32,
+    step: BitCount32,
+    struct_data_size: BitCount32,
+    struct_pointer_count: WirePointerCount16,
+    element_size: ElementSize,
+}
+
+impl<'a> ListBuilder<'a> {
+    #[inline]
+    pub fn new_default(arena: &mut dyn BuilderArena) -> ListBuilder<'_> {
+        ListBuilder {
+            arena,
+            segment_id: 0,
+            cap_table: Default::default(),
+            ptr: ptr::null_mut(),
+            element_count: 0,
+            element_size: ElementSize::Void,
+            step: 0,
+            struct_data_size: 0,
+            struct_pointer_count: 0,
+        }
+    }
+
+    pub fn into_reader(self) -> ListReader<'a> {
+        ListReader {
+            arena: self.arena.as_reader(),
+            segment_id: self.segment_id,
+            cap_table: self.cap_table.into_reader(),
+            ptr: self.ptr as *const _,
+            element_count: self.element_count,
+            element_size: self.element_size,
+            step: self.step,
+            struct_data_size: self.struct_data_size,
+            struct_pointer_count: self.struct_pointer_count,
+            nesting_limit: 0x7fffffff,
+        }
+    }
+
+    #[inline]
+    pub fn reborrow(&mut self) -> ListBuilder<'_> {
+        ListBuilder {
+            arena: self.arena,
+            ..*self
+        }
+    }
+
+    pub fn imbue(&mut self, cap_table: CapTableBuilder) {
+        self.cap_table = cap_table
+    }
+
+    #[inline]
+    pub fn len(&self) -> ElementCount32 {
+        self.element_count
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    #[inline]
+    pub fn get_struct_element(self, index: ElementCount32) -> StructBuilder<'a> {
+        let index_byte = ((u64::from(index) * u64::from(self.step)) / BITS_PER_BYTE as u64) as u32;
+        let struct_data = unsafe { self.ptr.offset(index_byte as isize) };
+        let struct_pointers =
+            unsafe { struct_data.add((self.struct_data_size as usize) / BITS_PER_BYTE) as *mut _ };
+        StructBuilder {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            data: struct_data,
+            pointers: struct_pointers,
+            data_size: self.struct_data_size,
+            pointer_count: self.struct_pointer_count,
+        }
+    }
+
+    pub(crate) fn get_element_size(&self) -> ElementSize {
+        self.element_size
+    }
+
+    #[inline]
+    pub fn get_pointer_element(self, index: ElementCount32) -> PointerBuilder<'a> {
+        let offset = (u64::from(index) * u64::from(self.step) / BITS_PER_BYTE as u64) as u32;
+        PointerBuilder {
+            arena: self.arena,
+            segment_id: self.segment_id,
+            cap_table: self.cap_table,
+            pointer: unsafe { self.ptr.offset(offset as isize) } as *mut _,
+        }
+    }
+
+    pub(crate) fn into_raw_bytes(&self) -> &'a mut [u8] {
+        if self.element_count == 0 {
+            // Explictly handle this case to avoid forming a slice to a null pointer,
+            // which would be undefined behavior.
+            &mut []
+        } else {
+            let num_bytes = wire_helpers::round_bits_up_to_bytes(
+                u64::from(self.step) * u64::from(self.element_count),
+            ) as usize;
+            unsafe { ::core::slice::from_raw_parts_mut(self.ptr, num_bytes) }
+        }
+    }
+}
+
+/**
+  An element that can be stored in a `primitive_list`.
+*/
+pub trait PrimitiveElement {
+    /// Gets the element at position `index`. Bounds checking is *not* performed.
+    fn get(list_reader: &ListReader, index: ElementCount32) -> Self;
+
+    /// Gets the element at position `index`. Bounds checking is *not* performed.
+    fn get_from_builder(list_builder: &ListBuilder, index: ElementCount32) -> Self;
+
+    /// Sets to element at position `index` to be `value`. Bounds checking is *not* performed.
+    fn set(list_builder: &ListBuilder, index: ElementCount32, value: Self);
+
+    /// Returns the size of an individual element.
+    fn element_size() -> ElementSize;
+}
+
+impl<T: Primitive> PrimitiveElement for T {
+    #[inline]
+    fn get(list_reader: &ListReader, index: ElementCount32) -> Self {
+        let offset = (u64::from(index) * u64::from(list_reader.step) / BITS_PER_BYTE as u64) as u32;
+        unsafe {
+            let ptr: *const u8 = list_reader.ptr.offset(offset as isize);
+            <Self as Primitive>::get(&*(ptr as *const <Self as Primitive>::Raw))
+        }
+    }
+
+    #[inline]
+    fn get_from_builder(list_builder: &ListBuilder, index: ElementCount32) -> Self {
+        let offset =
+            (u64::from(index) * u64::from(list_builder.step) / BITS_PER_BYTE as u64) as u32;
+        unsafe {
+            let ptr: *mut <Self as Primitive>::Raw =
+                list_builder.ptr.offset(offset as isize) as *mut _;
+            <Self as Primitive>::get(&*ptr)
+        }
+    }
+
+    #[inline]
+    fn set(list_builder: &ListBuilder, index: ElementCount32, value: Self) {
+        let offset =
+            (u64::from(index) * u64::from(list_builder.step) / BITS_PER_BYTE as u64) as u32;
+        unsafe {
+            let ptr: *mut <Self as Primitive>::Raw =
+                list_builder.ptr.offset(offset as isize) as *mut _;
+            <Self as Primitive>::set(&mut *ptr, value);
+        }
+    }
+
+    fn element_size() -> ElementSize {
+        match mem::size_of::<Self>() {
+            0 => Void,
+            1 => Byte,
+            2 => TwoBytes,
+            4 => FourBytes,
+            8 => EightBytes,
+            _ => unreachable!(),
+        }
+    }
+}
+
+impl PrimitiveElement for bool {
+    #[inline]
+    fn get(list: &ListReader, index: ElementCount32) -> Self {
+        let bindex = u64::from(index) * u64::from(list.step);
+        unsafe {
+            let b: *const u8 = list.ptr.offset((bindex / BITS_PER_BYTE as u64) as isize);
+            ((*b) & (1 << (bindex % BITS_PER_BYTE as u64))) != 0
+        }
+    }
+    #[inline]
+    fn get_from_builder(list: &ListBuilder, index: ElementCount32) -> Self {
+        let bindex = u64::from(index) * u64::from(list.step);
+        let b = unsafe { list.ptr.offset((bindex / BITS_PER_BYTE as u64) as isize) };
+        unsafe { ((*b) & (1 << (bindex % BITS_PER_BYTE as u64))) != 0 }
+    }
+    #[inline]
+    fn set(list: &ListBuilder, index: ElementCount32, value: Self) {
+        let bindex = u64::from(index) * u64::from(list.step);
+        let b = unsafe { list.ptr.offset((bindex / BITS_PER_BYTE as u64) as isize) };
+
+        let bitnum = bindex % BITS_PER_BYTE as u64;
+        unsafe { (*b) = ((*b) & !(1 << bitnum)) | (u8::from(value) << bitnum) }
+    }
+    fn element_size() -> ElementSize {
+        Bit
+    }
+}
+
+impl PrimitiveElement for () {
+    #[inline]
+    fn get(_list: &ListReader, _index: ElementCount32) {}
+
+    #[inline]
+    fn get_from_builder(_list: &ListBuilder, _index: ElementCount32) {}
+
+    #[inline]
+    fn set(_list: &ListBuilder, _index: ElementCount32, _value: ()) {}
+
+    fn element_size() -> ElementSize {
+        Void
+    }
+}
diff --git a/rust/capnp/private/layout_test.rs b/rust/capnp/private/layout_test.rs
new file mode 100644
index 000000000000..8715e9edab43
--- /dev/null
+++ b/rust/capnp/private/layout_test.rs
@@ -0,0 +1,192 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#![allow(clippy::bool_assert_comparison)]
+
+use crate::private::layout::PointerReader;
+
+fn test_at_alignments(words: &[crate::Word], verify: &dyn Fn(PointerReader)) {
+    verify(unsafe { PointerReader::get_root_unchecked(words.as_ptr() as *const u8) });
+
+    #[cfg(all(feature = "unaligned", feature = "alloc"))]
+    {
+        let mut unaligned_data = crate::Vec::with_capacity((words.len() + 1) * 8);
+        for offset in 0..8 {
+            unaligned_data.clear();
+            unaligned_data.resize(offset, 0);
+            unaligned_data.extend(crate::Word::words_to_bytes(words));
+            verify(unsafe {
+                PointerReader::get_root_unchecked((unaligned_data[offset..]).as_ptr())
+            });
+        }
+    }
+}
+
+#[test]
+fn simple_raw_data_struct() {
+    let data: &[crate::Word] = &[
+        crate::word(0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00),
+        crate::word(0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef),
+    ];
+
+    test_at_alignments(data, &verify);
+    fn verify(reader: PointerReader) {
+        let reader = reader.get_struct(None).unwrap();
+
+        assert_eq!(0xefcdab8967452301u64, reader.get_data_field::<u64>(0));
+        assert_eq!(0, reader.get_data_field::<u64>(1)); // past end of struct --> default value
+
+        assert_eq!(0x67452301u32, reader.get_data_field::<u32>(0));
+        assert_eq!(0xefcdab89u32, reader.get_data_field::<u32>(1));
+        assert_eq!(0, reader.get_data_field::<u32>(2)); // past end of struct --> default value
+
+        assert_eq!(0x2301u16, reader.get_data_field::<u16>(0));
+        assert_eq!(0x6745u16, reader.get_data_field::<u16>(1));
+        assert_eq!(0xab89u16, reader.get_data_field::<u16>(2));
+        assert_eq!(0xefcdu16, reader.get_data_field::<u16>(3));
+        assert_eq!(0u16, reader.get_data_field::<u16>(4)); // past end of struct --> default value
+                                                           // TODO the rest of uints.
+
+        // Bits.
+        assert_eq!(reader.get_bool_field(0), true);
+        assert_eq!(reader.get_bool_field(1), false);
+        assert_eq!(reader.get_bool_field(2), false);
+        assert_eq!(reader.get_bool_field(3), false);
+        assert_eq!(reader.get_bool_field(4), false);
+        assert_eq!(reader.get_bool_field(5), false);
+        assert_eq!(reader.get_bool_field(6), false);
+        assert_eq!(reader.get_bool_field(7), false);
+
+        assert_eq!(reader.get_bool_field(8), true);
+        assert_eq!(reader.get_bool_field(9), true);
+        assert_eq!(reader.get_bool_field(10), false);
+        assert_eq!(reader.get_bool_field(11), false);
+        assert_eq!(reader.get_bool_field(12), false);
+        assert_eq!(reader.get_bool_field(13), true);
+        assert_eq!(reader.get_bool_field(14), false);
+        assert_eq!(reader.get_bool_field(15), false);
+
+        assert_eq!(reader.get_bool_field(63), true);
+        assert_eq!(reader.get_bool_field(64), false); // past end of struct --> default value
+    }
+}
+
+#[test]
+fn bool_list() {
+    // [true, false, true, false,
+    //  true, true, true, false,
+    //  false, true]
+
+    let data: &[crate::Word] = &[
+        crate::word(0x01, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00),
+        crate::word(0x75, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+    ];
+
+    test_at_alignments(data, &verify);
+    fn verify(pointer_reader: PointerReader) {
+        use crate::private::layout::PrimitiveElement;
+        use crate::traits::FromPointerReader;
+
+        let reader = pointer_reader
+            .get_list(crate::private::layout::ElementSize::Bit, None)
+            .unwrap();
+
+        assert_eq!(reader.len(), 10);
+        assert_eq!(bool::get(&reader, 0), true);
+        assert_eq!(bool::get(&reader, 1), false);
+        assert_eq!(bool::get(&reader, 2), true);
+        assert_eq!(bool::get(&reader, 3), false);
+        assert_eq!(bool::get(&reader, 4), true);
+        assert_eq!(bool::get(&reader, 5), true);
+        assert_eq!(bool::get(&reader, 6), true);
+        assert_eq!(bool::get(&reader, 7), false);
+        assert_eq!(bool::get(&reader, 8), false);
+        assert_eq!(bool::get(&reader, 9), true);
+
+        let reader =
+            crate::primitive_list::Reader::<bool>::get_from_pointer(&pointer_reader, None).unwrap();
+
+        assert_eq!(reader.len(), 10);
+        assert_eq!(reader.get(0), true);
+        assert_eq!(reader.get(1), false);
+        assert_eq!(reader.get(2), true);
+        assert_eq!(reader.get(3), false);
+        assert_eq!(reader.get(4), true);
+        assert_eq!(reader.get(5), true);
+        assert_eq!(reader.get(6), true);
+        assert_eq!(reader.get(7), false);
+        assert_eq!(reader.get(8), false);
+        assert_eq!(reader.get(9), true);
+    }
+}
+
+#[test]
+fn struct_size() {
+    let data: &[crate::Word] = &[
+        crate::word(0x00, 0x00, 0x00, 0x00, 0x2, 0x00, 0x01, 0x00),
+        crate::word(0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+        crate::word(0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+        crate::word(0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+    ];
+
+    test_at_alignments(data, &verify);
+    fn verify(pointer_reader: PointerReader) {
+        assert_eq!(pointer_reader.total_size().unwrap().word_count, 3);
+    }
+}
+
+#[test]
+fn struct_list_size() {
+    let data: &[crate::Word] = &[
+        crate::word(0x01, 0, 0, 0, 0x1f, 0, 0, 0), // inline-composite list. 4 words long.
+        crate::word(0x4, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00), // 1 element long
+        crate::word(0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+        crate::word(0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+        crate::word(0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+    ];
+
+    // The list pointer claims that the list consumes four words, but the struct
+    // tag says there is only one element and it has a size of one word.
+    // So there is an inconsistency! total_size() should report the value computed from
+    // the struct tag, because that's what is relevant when the data is copied.
+
+    test_at_alignments(data, &verify);
+    fn verify(pointer_reader: PointerReader) {
+        assert_eq!(pointer_reader.total_size().unwrap().word_count, 2);
+    }
+}
+
+#[test]
+fn empty_struct_list_size() {
+    let data: &[crate::Word] = &[
+        // Struct, one pointer
+        crate::word(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00),
+        // Inline-composite list, zero words long
+        crate::word(0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00),
+        // Tag
+        crate::word(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
+    ];
+
+    test_at_alignments(data, &verify);
+    fn verify(pointer_reader: PointerReader) {
+        assert_eq!(2, pointer_reader.total_size().unwrap().word_count);
+    }
+}
diff --git a/rust/capnp/private/mask.rs b/rust/capnp/private/mask.rs
new file mode 100644
index 000000000000..dfa211521ca7
--- /dev/null
+++ b/rust/capnp/private/mask.rs
@@ -0,0 +1,62 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+pub trait Mask {
+    type T;
+    fn mask(value: Self, mask: Self::T) -> Self;
+}
+
+macro_rules! int_mask(
+    ($t:ident) => (
+        impl Mask for $t {
+            type T = $t;
+            #[inline]
+            fn mask(value: $t, mask: $t) -> $t {
+                value ^ mask
+            }
+        }
+    )
+);
+
+int_mask!(i8);
+int_mask!(i16);
+int_mask!(i32);
+int_mask!(i64);
+int_mask!(u8);
+int_mask!(u16);
+int_mask!(u32);
+int_mask!(u64);
+
+impl Mask for f32 {
+    type T = u32;
+    #[inline]
+    fn mask(value: Self, mask: u32) -> Self {
+        Self::from_bits(value.to_bits() ^ mask)
+    }
+}
+
+impl Mask for f64 {
+    type T = u64;
+    #[inline]
+    fn mask(value: Self, mask: u64) -> Self {
+        Self::from_bits(value.to_bits() ^ mask)
+    }
+}
diff --git a/rust/capnp/private/mod.rs b/rust/capnp/private/mod.rs
new file mode 100644
index 000000000000..1e6bcdab6d6e
--- /dev/null
+++ b/rust/capnp/private/mod.rs
@@ -0,0 +1,36 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Implementation details that should never be directly used by clients.
+//!
+//! We still need to make this module visible so that generated code can use it.
+
+pub mod arena;
+pub mod capability;
+pub mod layout;
+mod mask;
+mod primitive;
+mod read_limiter;
+pub mod units;
+mod zero;
+
+#[cfg(test)]
+mod layout_test;
diff --git a/rust/capnp/private/primitive.rs b/rust/capnp/private/primitive.rs
new file mode 100644
index 000000000000..00e41ce40f08
--- /dev/null
+++ b/rust/capnp/private/primitive.rs
@@ -0,0 +1,119 @@
+pub trait Primitive {
+    type Raw;
+
+    /// Reads the value, swapping bytes on big-endian processors.
+    fn get(raw: &Self::Raw) -> Self;
+
+    /// Writes the value, swapping bytes on big-endian processors.
+    fn set(raw: &mut Self::Raw, value: Self);
+}
+
+#[cfg(feature = "unaligned")]
+macro_rules! primitive_impl(
+    ($typ:ty, $n:expr) => (
+        impl Primitive for $typ {
+            type Raw = [u8; $n];
+
+            #[inline]
+            fn get(raw: &Self::Raw) -> Self {
+                <$typ>::from_le_bytes(*raw)
+            }
+
+            #[inline]
+            fn set(raw: &mut Self::Raw, value: Self) {
+                *raw = value.to_le_bytes();
+            }
+        }
+        );
+    );
+
+#[cfg(not(feature = "unaligned"))]
+macro_rules! primitive_impl(
+    ($typ:ty, $n:expr) => (
+        impl Primitive for $typ {
+            type Raw = Self;
+
+            #[inline]
+            fn get(raw: &Self::Raw) -> Self {
+                raw.to_le()
+            }
+
+            #[inline]
+            fn set(raw: &mut Self::Raw, value: Self) {
+                *raw = value.to_le()
+            }
+        }
+        );
+    );
+
+primitive_impl!(u8, 1);
+primitive_impl!(i8, 1);
+primitive_impl!(u16, 2);
+primitive_impl!(i16, 2);
+primitive_impl!(u32, 4);
+primitive_impl!(i32, 4);
+primitive_impl!(u64, 8);
+primitive_impl!(i64, 8);
+
+#[cfg(feature = "unaligned")]
+primitive_impl!(f32, 4);
+
+#[cfg(feature = "unaligned")]
+primitive_impl!(f64, 8);
+
+#[cfg(not(feature = "unaligned"))]
+impl Primitive for f32 {
+    type Raw = Self;
+
+    #[inline]
+    fn get(raw: &Self::Raw) -> Self {
+        Self::from_bits(raw.to_bits().to_le())
+    }
+
+    #[inline]
+    fn set(raw: &mut Self::Raw, value: Self) {
+        *raw = Self::from_bits(value.to_bits().to_le())
+    }
+}
+
+#[cfg(not(feature = "unaligned"))]
+impl Primitive for f64 {
+    type Raw = Self;
+
+    #[inline]
+    fn get(raw: &Self::Raw) -> Self {
+        Self::from_bits(raw.to_bits().to_le())
+    }
+
+    #[inline]
+    fn set(raw: &mut Self::Raw, value: Self) {
+        *raw = Self::from_bits(value.to_bits().to_le())
+    }
+}
+
+/// A value casted directly from a little-endian byte buffer. On big-endian
+/// processors, the bytes of the value need to be swapped upon reading and writing.
+#[repr(C)]
+pub struct WireValue<T>
+where
+    T: Primitive,
+{
+    value: <T as Primitive>::Raw,
+}
+
+impl<T> WireValue<T>
+where
+    T: Primitive,
+{
+    /// Reads the value, swapping bytes on big-endian processors.
+    #[inline]
+    pub fn get(&self) -> T {
+        <T as Primitive>::get(&self.value)
+    }
+
+    /// Writes the value, swapping bytes on big-endian processors.
+    #[inline]
+    pub fn set(&mut self, value: T) {
+        <T as Primitive>::set(&mut self.value, value)
+    }
+}
diff --git a/rust/capnp/private/read_limiter.rs b/rust/capnp/private/read_limiter.rs
new file mode 100644
index 000000000000..0bb6a7a8415c
--- /dev/null
+++ b/rust/capnp/private/read_limiter.rs
@@ -0,0 +1,113 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#[cfg(feature = "sync_reader")]
+pub use sync::ReadLimiter;
+
+#[cfg(feature = "sync_reader")]
+mod sync {
+    use crate::{Error, ErrorKind, Result};
+    use core::sync::atomic::{AtomicUsize, Ordering};
+
+    pub struct ReadLimiter {
+        limit: AtomicUsize,
+        error_on_limit_exceeded: bool,
+    }
+
+    impl ReadLimiter {
+        pub fn new(limit: Option<usize>) -> Self {
+            match limit {
+                Some(value) => Self {
+                    limit: AtomicUsize::new(value),
+                    error_on_limit_exceeded: true,
+                },
+                None => Self {
+                    limit: AtomicUsize::new(usize::MAX),
+                    error_on_limit_exceeded: false,
+                },
+            }
+        }
+
+        #[inline]
+        pub fn can_read(&self, amount: usize) -> Result<()> {
+            // We use separate AtomicUsize::load() and AtomicUsize::store() steps, which may
+            // result in undercounting reads if multiple threads are reading at the same.
+            // That's okay -- a denial of service attack will eventually hit the limit anyway.
+            //
+            // We could instead do a single fetch_sub() step, but that seems to be slower.
+
+            let current = self.limit.load(Ordering::Relaxed);
+            if amount > current && self.error_on_limit_exceeded {
+                return Err(Error::from_kind(ErrorKind::ReadLimitExceeded));
+            } else {
+                // The common case is current >= amount. Note that we only branch once in that case.
+                // If we combined the fields into an Option<AtomicUsize>, we would
+                // need to branch twice in the common case.
+                self.limit
+                    .store(current.wrapping_sub(amount), Ordering::Relaxed);
+            }
+            Ok(())
+        }
+    }
+}
+
+#[cfg(not(feature = "sync_reader"))]
+pub use unsync::ReadLimiter;
+
+#[cfg(not(feature = "sync_reader"))]
+mod unsync {
+    use crate::{Error, ErrorKind, Result};
+    use core::cell::Cell;
+
+    pub struct ReadLimiter {
+        limit: Cell<usize>,
+        error_on_limit_exceeded: bool,
+    }
+
+    impl ReadLimiter {
+        pub fn new(limit: Option<usize>) -> Self {
+            match limit {
+                Some(value) => Self {
+                    limit: Cell::new(value),
+                    error_on_limit_exceeded: true,
+                },
+                None => Self {
+                    limit: Cell::new(usize::MAX),
+                    error_on_limit_exceeded: false,
+                },
+            }
+        }
+
+        #[inline]
+        pub fn can_read(&self, amount: usize) -> Result<()> {
+            let current = self.limit.get();
+            if amount > current && self.error_on_limit_exceeded {
+                Err(Error::from_kind(ErrorKind::ReadLimitExceeded))
+            } else {
+                // The common case is current >= amount. Note that we only branch once in that case.
+                // If we combined the fields into an Option<Cell<usize>>, we would
+                // need to branch twice in the common case.
+                self.limit.set(current.wrapping_sub(amount));
+                Ok(())
+            }
+        }
+    }
+}
diff --git a/rust/capnp/private/units.rs b/rust/capnp/private/units.rs
new file mode 100644
index 000000000000..90fbf663f777
--- /dev/null
+++ b/rust/capnp/private/units.rs
@@ -0,0 +1,68 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+pub type BitCount0 = usize; // `BitCount` clashes with a standard trait
+pub type BitCount8 = u8;
+pub type BitCount16 = u16;
+pub type BitCount32 = u32;
+pub type BitCount64 = u64;
+
+pub type ByteCount = usize;
+pub type ByteCount8 = u8;
+pub type ByteCount16 = u16;
+pub type ByteCount32 = u32;
+pub type ByteCount64 = u64;
+
+pub type WordCount = usize;
+pub type WordCount8 = u8;
+pub type WordCount16 = u16;
+pub type WordCount32 = u32;
+pub type WordCount64 = u64;
+
+pub type ElementCount = usize;
+pub type ElementCount8 = u8;
+pub type ElementCount16 = u16;
+pub type ElementCount32 = u32;
+pub type ElementCount64 = u64;
+
+pub type WirePointerCount = usize;
+pub type WirePointerCount8 = u8;
+pub type WirePointerCount16 = u16;
+pub type WirePointerCount32 = u32;
+pub type WirePointerCount64 = u64;
+
+pub const BITS_PER_BYTE: BitCount0 = 8;
+pub const BITS_PER_WORD: BitCount0 = 64;
+pub const BYTES_PER_WORD: ByteCount = 8;
+
+pub const BITS_PER_POINTER: BitCount0 = 64;
+pub const _BYTES_PER_POINTER: ByteCount = 8;
+pub const WORDS_PER_POINTER: WordCount = 1;
+
+pub const POINTER_SIZE_IN_WORDS: WordCount = 1;
+
+pub fn _bytes_per_element<T>() -> ByteCount {
+    ::core::mem::size_of::<T>()
+}
+
+pub fn bits_per_element<T>() -> BitCount0 {
+    8 * ::core::mem::size_of::<T>()
+}
diff --git a/rust/capnp/private/zero.rs b/rust/capnp/private/zero.rs
new file mode 100644
index 000000000000..00769cfebafc
--- /dev/null
+++ b/rust/capnp/private/zero.rs
@@ -0,0 +1,46 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+/// At one point the standard library had `::std::num::Zero`. It was never stabilized
+/// it eventually got deleted. So we define our own version here.
+pub trait Zero {
+    fn zero() -> Self;
+}
+
+macro_rules! zero_impl(
+    ($t:ident, $e:expr) => (
+        impl Zero for $t {
+            #[inline]
+            fn zero() -> $t { $e }
+        }
+    )
+);
+
+zero_impl!(u8, 0);
+zero_impl!(u16, 0);
+zero_impl!(u32, 0);
+zero_impl!(u64, 0);
+zero_impl!(i8, 0);
+zero_impl!(i16, 0);
+zero_impl!(i32, 0);
+zero_impl!(i64, 0);
+zero_impl!(f32, 0.0);
+zero_impl!(f64, 0.0);
diff --git a/rust/capnp/raw.rs b/rust/capnp/raw.rs
new file mode 100644
index 000000000000..5883b1207be9
--- /dev/null
+++ b/rust/capnp/raw.rs
@@ -0,0 +1,69 @@
+// Copyright (c) 2018 the capnproto-rust contributors
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Functions providing low level access to encoded data.
+
+use crate::traits::{IntoInternalListReader, IntoInternalStructReader};
+
+/// Gets a slice view of the data section of a struct.
+pub fn get_struct_data_section<'a, T>(value: T) -> &'a [u8]
+where
+    T: IntoInternalStructReader<'a>,
+{
+    value
+        .into_internal_struct_reader()
+        .get_data_section_as_blob()
+}
+
+/// Gets the pointer section as a list.
+pub fn get_struct_pointer_section<'a, T>(value: T) -> crate::any_pointer_list::Reader<'a>
+where
+    T: IntoInternalStructReader<'a>,
+{
+    crate::any_pointer_list::Reader::new(
+        value
+            .into_internal_struct_reader()
+            .get_pointer_section_as_list(),
+    )
+}
+
+/// Gets the size of the elements in a list.
+pub fn get_list_element_size<'a, T>(value: T) -> crate::private::layout::ElementSize
+where
+    T: IntoInternalListReader<'a>,
+{
+    value.into_internal_list_reader().get_element_size()
+}
+
+/// Gets the number of bits between successive elements in a list.
+pub fn get_list_step_size_in_bits<'a, T>(value: T) -> u32
+where
+    T: IntoInternalListReader<'a>,
+{
+    value.into_internal_list_reader().get_step_size_in_bits()
+}
+
+/// Gets a slice view of a list, excluding any tag word.
+pub fn get_list_bytes<'a, T>(value: T) -> &'a [u8]
+where
+    T: IntoInternalListReader<'a>,
+{
+    value.into_internal_list_reader().into_raw_bytes()
+}
diff --git a/rust/capnp/schema.rs b/rust/capnp/schema.rs
new file mode 100644
index 000000000000..4120868f4051
--- /dev/null
+++ b/rust/capnp/schema.rs
@@ -0,0 +1,430 @@
+//! Convenience wrappers of the datatypes defined in schema.capnp.
+
+use crate::dynamic_value;
+use crate::introspect::{self, RawBrandedStructSchema, RawEnumSchema};
+use crate::private::layout;
+use crate::schema_capnp::{annotation, enumerant, field, node};
+use crate::struct_list;
+use crate::traits::{IndexMove, ListIter, ShortListIter};
+use crate::Result;
+
+/// A struct node, with generics applied.
+#[derive(Clone, Copy)]
+pub struct StructSchema {
+    pub(crate) raw: RawBrandedStructSchema,
+    pub(crate) proto: node::Reader<'static>,
+}
+
+impl StructSchema {
+    pub fn new(raw: RawBrandedStructSchema) -> Self {
+        let proto =
+            crate::any_pointer::Reader::new(unsafe {
+                layout::PointerReader::get_root_unchecked(
+                    raw.generic.encoded_node.as_ptr() as *const u8
+                )
+            })
+            .get_as()
+            .unwrap();
+        Self { raw, proto }
+    }
+
+    pub fn get_proto(&self) -> node::Reader<'static> {
+        self.proto
+    }
+
+    pub fn get_fields(self) -> crate::Result<FieldList> {
+        if let node::Struct(s) = self.proto.which()? {
+            Ok(FieldList {
+                fields: s.get_fields()?,
+                parent: self,
+            })
+        } else {
+            panic!()
+        }
+    }
+
+    pub fn get_field_by_discriminant(self, discriminant: u16) -> Result<Option<Field>> {
+        match self
+            .raw
+            .generic
+            .members_by_discriminant
+            .get(discriminant as usize)
+        {
+            None => Ok(None),
+            Some(&idx) => Ok(Some(self.get_fields()?.get(idx))),
+        }
+    }
+
+    /// Looks up a field by name. Returns `None` if no matching field is found.
+    pub fn find_field_by_name(&self, name: &str) -> Result<Option<Field>> {
+        for field in self.get_fields()? {
+            if field.get_proto().get_name()? == name {
+                return Ok(Some(field));
+            }
+        }
+        Ok(None)
+    }
+
+    /// Like `find_field_by_name()`, but returns an error if the field is not found.
+    pub fn get_field_by_name(&self, name: &str) -> Result<Field> {
+        if let Some(field) = self.find_field_by_name(name)? {
+            Ok(field)
+        } else {
+            let mut error = crate::Error::from_kind(crate::ErrorKind::FieldNotFound);
+            write!(error, "{}", name);
+            Err(error)
+        }
+    }
+
+    pub fn get_union_fields(self) -> Result<FieldSubset> {
+        if let node::Struct(s) = self.proto.which()? {
+            Ok(FieldSubset {
+                fields: s.get_fields()?,
+                indices: self.raw.generic.members_by_discriminant,
+                parent: self,
+            })
+        } else {
+            panic!()
+        }
+    }
+
+    pub fn get_non_union_fields(self) -> Result<FieldSubset> {
+        if let node::Struct(s) = self.proto.which()? {
+            Ok(FieldSubset {
+                fields: s.get_fields()?,
+                indices: self.raw.generic.nonunion_members,
+                parent: self,
+            })
+        } else {
+            panic!()
+        }
+    }
+
+    pub fn get_annotations(self) -> Result<AnnotationList> {
+        Ok(AnnotationList {
+            annotations: self.proto.get_annotations()?,
+            child_index: None,
+            get_annotation_type: self.raw.annotation_types,
+        })
+    }
+}
+
+impl From<RawBrandedStructSchema> for StructSchema {
+    fn from(rs: RawBrandedStructSchema) -> StructSchema {
+        StructSchema::new(rs)
+    }
+}
+
+/// A field of a struct, with generics applied.
+#[derive(Clone, Copy)]
+pub struct Field {
+    proto: field::Reader<'static>,
+    index: u16,
+    pub(crate) parent: StructSchema,
+}
+
+impl Field {
+    pub fn get_proto(self) -> field::Reader<'static> {
+        self.proto
+    }
+
+    pub fn get_type(&self) -> introspect::Type {
+        (self.parent.raw.field_types)(self.index)
+    }
+
+    pub fn get_index(&self) -> u16 {
+        self.index
+    }
+
+    pub fn get_annotations(self) -> Result<AnnotationList> {
+        Ok(AnnotationList {
+            annotations: self.proto.get_annotations()?,
+            child_index: Some(self.index),
+            get_annotation_type: self.parent.raw.annotation_types,
+        })
+    }
+}
+
+/// A list of fields of a struct, with generics applied.
+#[derive(Clone, Copy)]
+pub struct FieldList {
+    pub(crate) fields: crate::struct_list::Reader<'static, field::Owned>,
+    pub(crate) parent: StructSchema,
+}
+
+impl FieldList {
+    pub fn len(&self) -> u16 {
+        self.fields.len() as u16
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn get(self, index: u16) -> Field {
+        Field {
+            proto: self.fields.get(index as u32),
+            index,
+            parent: self.parent,
+        }
+    }
+
+    pub fn iter(self) -> ShortListIter<Self, Field> {
+        ShortListIter::new(self, self.len())
+    }
+}
+
+impl IndexMove<u16, Field> for FieldList {
+    fn index_move(&self, index: u16) -> Field {
+        self.get(index)
+    }
+}
+
+impl ::core::iter::IntoIterator for FieldList {
+    type Item = Field;
+    type IntoIter = ShortListIter<FieldList, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+/// A list of a subset of fields of a struct, with generics applied.
+#[derive(Clone, Copy)]
+pub struct FieldSubset {
+    fields: struct_list::Reader<'static, field::Owned>,
+    indices: &'static [u16],
+    parent: StructSchema,
+}
+
+impl FieldSubset {
+    pub fn len(&self) -> u16 {
+        self.indices.len() as u16
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn get(self, index: u16) -> Field {
+        let index = self.indices[index as usize];
+        Field {
+            proto: self.fields.get(index as u32),
+            index,
+            parent: self.parent,
+        }
+    }
+
+    pub fn iter(self) -> ShortListIter<Self, Field> {
+        ShortListIter::new(self, self.len())
+    }
+}
+
+impl IndexMove<u16, Field> for FieldSubset {
+    fn index_move(&self, index: u16) -> Field {
+        self.get(index)
+    }
+}
+
+impl ::core::iter::IntoIterator for FieldSubset {
+    type Item = Field;
+    type IntoIter = ShortListIter<FieldSubset, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+/// An enum, with generics applied. (Generics may affect types of annotations.)
+#[derive(Clone, Copy)]
+pub struct EnumSchema {
+    pub(crate) raw: RawEnumSchema,
+    pub(crate) proto: node::Reader<'static>,
+}
+
+impl EnumSchema {
+    pub fn new(raw: RawEnumSchema) -> Self {
+        let proto = crate::any_pointer::Reader::new(unsafe {
+            layout::PointerReader::get_root_unchecked(raw.encoded_node.as_ptr() as *const u8)
+        })
+        .get_as()
+        .unwrap();
+        Self { raw, proto }
+    }
+
+    pub fn get_proto(self) -> node::Reader<'static> {
+        self.proto
+    }
+
+    pub fn get_enumerants(self) -> crate::Result<EnumerantList> {
+        if let node::Enum(s) = self.proto.which()? {
+            Ok(EnumerantList {
+                enumerants: s.get_enumerants()?,
+                parent: self,
+            })
+        } else {
+            panic!()
+        }
+    }
+
+    pub fn get_annotations(self) -> Result<AnnotationList> {
+        Ok(AnnotationList {
+            annotations: self.proto.get_annotations()?,
+            child_index: None,
+            get_annotation_type: self.raw.annotation_types,
+        })
+    }
+}
+
+impl From<RawEnumSchema> for EnumSchema {
+    fn from(re: RawEnumSchema) -> EnumSchema {
+        EnumSchema::new(re)
+    }
+}
+
+/// An enumerant, with generics applied. (Generics may affect types of annotations.)
+#[derive(Clone, Copy)]
+pub struct Enumerant {
+    ordinal: u16,
+    parent: EnumSchema,
+    proto: enumerant::Reader<'static>,
+}
+
+impl Enumerant {
+    pub fn get_containing_enum(self) -> EnumSchema {
+        self.parent
+    }
+
+    pub fn get_ordinal(self) -> u16 {
+        self.ordinal
+    }
+
+    pub fn get_proto(self) -> enumerant::Reader<'static> {
+        self.proto
+    }
+
+    pub fn get_annotations(self) -> Result<AnnotationList> {
+        Ok(AnnotationList {
+            annotations: self.proto.get_annotations()?,
+            child_index: Some(self.ordinal),
+            get_annotation_type: self.parent.raw.annotation_types,
+        })
+    }
+}
+
+/// A list of enumerants.
+#[derive(Clone, Copy)]
+pub struct EnumerantList {
+    enumerants: struct_list::Reader<'static, enumerant::Owned>,
+    parent: EnumSchema,
+}
+
+impl EnumerantList {
+    pub fn len(&self) -> u16 {
+        self.enumerants.len() as u16
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn get(self, ordinal: u16) -> Enumerant {
+        Enumerant {
+            proto: self.enumerants.get(ordinal as u32),
+            ordinal,
+            parent: self.parent,
+        }
+    }
+
+    pub fn iter(self) -> ShortListIter<Self, Enumerant> {
+        ShortListIter::new(self, self.len())
+    }
+}
+
+impl IndexMove<u16, Enumerant> for EnumerantList {
+    fn index_move(&self, index: u16) -> Enumerant {
+        self.get(index)
+    }
+}
+
+impl ::core::iter::IntoIterator for EnumerantList {
+    type Item = Enumerant;
+    type IntoIter = ShortListIter<Self, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+/// An annotation.
+#[derive(Clone, Copy)]
+pub struct Annotation {
+    proto: annotation::Reader<'static>,
+    ty: introspect::Type,
+}
+
+impl Annotation {
+    /// Gets the value held in this annotation.
+    pub fn get_value(self) -> Result<dynamic_value::Reader<'static>> {
+        dynamic_value::Reader::new(self.proto.get_value()?, self.ty)
+    }
+
+    /// Gets the ID of the annotation node.
+    pub fn get_id(&self) -> u64 {
+        self.proto.get_id()
+    }
+
+    /// Gets the type of the value held in this annotation.
+    pub fn get_type(&self) -> introspect::Type {
+        self.ty
+    }
+}
+
+/// A list of annotations.
+#[derive(Clone, Copy)]
+pub struct AnnotationList {
+    annotations: struct_list::Reader<'static, annotation::Owned>,
+    child_index: Option<u16>,
+    get_annotation_type: fn(Option<u16>, u32) -> introspect::Type,
+}
+
+impl AnnotationList {
+    pub fn len(&self) -> u32 {
+        self.annotations.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn get(self, index: u32) -> Annotation {
+        let proto = self.annotations.get(index);
+        let ty = (self.get_annotation_type)(self.child_index, index);
+        Annotation { proto, ty }
+    }
+
+    /// Returns the first annotation in the list that matches `id`.
+    /// Otherwise returns `None`.
+    pub fn find(self, id: u64) -> Option<Annotation> {
+        self.iter().find(|&annotation| annotation.get_id() == id)
+    }
+
+    pub fn iter(self) -> ListIter<Self, Annotation> {
+        ListIter::new(self, self.len())
+    }
+}
+
+impl IndexMove<u32, Annotation> for AnnotationList {
+    fn index_move(&self, index: u32) -> Annotation {
+        self.get(index)
+    }
+}
+
+impl ::core::iter::IntoIterator for AnnotationList {
+    type Item = Annotation;
+    type IntoIter = ListIter<Self, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
diff --git a/rust/capnp/schema_capnp.rs b/rust/capnp/schema_capnp.rs
new file mode 100644
index 000000000000..4f92ee288821
--- /dev/null
+++ b/rust/capnp/schema_capnp.rs
@@ -0,0 +1,14448 @@
+// @generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
+// DO NOT EDIT.
+// source: schema.capnp
+
+pub mod node {
+    pub use self::Which::{Annotation, Const, Enum, File, Interface, Struct};
+
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_id(self) -> u64 {
+            self.reader.get_data_field::<u64>(0)
+        }
+        #[inline]
+        pub fn get_display_name(self) -> crate::Result<crate::text::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_display_name(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn get_display_name_prefix_length(self) -> u32 {
+            self.reader.get_data_field::<u32>(2)
+        }
+        #[inline]
+        pub fn get_scope_id(self) -> u64 {
+            self.reader.get_data_field::<u64>(2)
+        }
+        #[inline]
+        pub fn get_nested_nodes(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Reader<'a, crate::schema_capnp::node::nested_node::Owned>,
+        > {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_nested_nodes(&self) -> bool {
+            !self.reader.get_pointer_field(1).is_null()
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(2),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.reader.get_pointer_field(2).is_null()
+        }
+        #[inline]
+        pub fn get_parameters(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Reader<'a, crate::schema_capnp::node::parameter::Owned>,
+        > {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(5),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_parameters(&self) -> bool {
+            !self.reader.get_pointer_field(5).is_null()
+        }
+        #[inline]
+        pub fn get_is_generic(self) -> bool {
+            self.reader.get_bool_field(288)
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+            match self.reader.get_data_field::<u16>(6) {
+                0 => ::core::result::Result::Ok(File(())),
+                1 => ::core::result::Result::Ok(Struct(self.reader.into())),
+                2 => ::core::result::Result::Ok(Enum(self.reader.into())),
+                3 => ::core::result::Result::Ok(Interface(self.reader.into())),
+                4 => ::core::result::Result::Ok(Const(self.reader.into())),
+                5 => ::core::result::Result::Ok(Annotation(self.reader.into())),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 5,
+                pointers: 6,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_id(self) -> u64 {
+            self.builder.get_data_field::<u64>(0)
+        }
+        #[inline]
+        pub fn set_id(&mut self, value: u64) {
+            self.builder.set_data_field::<u64>(0, value);
+        }
+        #[inline]
+        pub fn get_display_name(self) -> crate::Result<crate::text::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_display_name(&mut self, value: crate::text::Reader<'_>) {
+            self.builder.reborrow().get_pointer_field(0).set_text(value);
+        }
+        #[inline]
+        pub fn init_display_name(self, size: u32) -> crate::text::Builder<'a> {
+            self.builder.get_pointer_field(0).init_text(size)
+        }
+        #[inline]
+        pub fn has_display_name(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn get_display_name_prefix_length(self) -> u32 {
+            self.builder.get_data_field::<u32>(2)
+        }
+        #[inline]
+        pub fn set_display_name_prefix_length(&mut self, value: u32) {
+            self.builder.set_data_field::<u32>(2, value);
+        }
+        #[inline]
+        pub fn get_scope_id(self) -> u64 {
+            self.builder.get_data_field::<u64>(2)
+        }
+        #[inline]
+        pub fn set_scope_id(&mut self, value: u64) {
+            self.builder.set_data_field::<u64>(2, value);
+        }
+        #[inline]
+        pub fn get_nested_nodes(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Builder<'a, crate::schema_capnp::node::nested_node::Owned>,
+        > {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_nested_nodes(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::node::nested_node::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(1),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_nested_nodes(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::node::nested_node::Owned>
+        {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), size)
+        }
+        #[inline]
+        pub fn has_nested_nodes(&self) -> bool {
+            !self.builder.is_pointer_field_null(1)
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(2),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_annotations(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(2),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_annotations(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(2), size)
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.builder.is_pointer_field_null(2)
+        }
+        #[inline]
+        pub fn set_file(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(6, 0);
+        }
+        #[inline]
+        pub fn init_struct(mut self) -> crate::schema_capnp::node::struct_::Builder<'a> {
+            self.builder.set_data_field::<u16>(6, 1);
+            self.builder.set_data_field::<u16>(7, 0u16);
+            self.builder.set_data_field::<u16>(12, 0u16);
+            self.builder.set_data_field::<u16>(13, 0u16);
+            self.builder.set_bool_field(224, false);
+            self.builder.set_data_field::<u16>(15, 0u16);
+            self.builder.set_data_field::<u32>(8, 0u32);
+            self.builder.reborrow().get_pointer_field(3).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_enum(mut self) -> crate::schema_capnp::node::enum_::Builder<'a> {
+            self.builder.set_data_field::<u16>(6, 2);
+            self.builder.reborrow().get_pointer_field(3).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_interface(mut self) -> crate::schema_capnp::node::interface::Builder<'a> {
+            self.builder.set_data_field::<u16>(6, 3);
+            self.builder.reborrow().get_pointer_field(3).clear();
+            self.builder.reborrow().get_pointer_field(4).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_const(mut self) -> crate::schema_capnp::node::const_::Builder<'a> {
+            self.builder.set_data_field::<u16>(6, 4);
+            self.builder.reborrow().get_pointer_field(3).clear();
+            self.builder.reborrow().get_pointer_field(4).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_annotation(mut self) -> crate::schema_capnp::node::annotation::Builder<'a> {
+            self.builder.set_data_field::<u16>(6, 5);
+            self.builder.reborrow().get_pointer_field(3).clear();
+            self.builder.set_bool_field(112, false);
+            self.builder.set_bool_field(113, false);
+            self.builder.set_bool_field(114, false);
+            self.builder.set_bool_field(115, false);
+            self.builder.set_bool_field(116, false);
+            self.builder.set_bool_field(117, false);
+            self.builder.set_bool_field(118, false);
+            self.builder.set_bool_field(119, false);
+            self.builder.set_bool_field(120, false);
+            self.builder.set_bool_field(121, false);
+            self.builder.set_bool_field(122, false);
+            self.builder.set_bool_field(123, false);
+            self.builder.into()
+        }
+        #[inline]
+        pub fn get_parameters(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Builder<'a, crate::schema_capnp::node::parameter::Owned>,
+        > {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(5),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_parameters(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::node::parameter::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(5),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_parameters(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::node::parameter::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(5), size)
+        }
+        #[inline]
+        pub fn has_parameters(&self) -> bool {
+            !self.builder.is_pointer_field_null(5)
+        }
+        #[inline]
+        pub fn get_is_generic(self) -> bool {
+            self.builder.get_bool_field(288)
+        }
+        #[inline]
+        pub fn set_is_generic(&mut self, value: bool) {
+            self.builder.set_bool_field(288, value);
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+            match self.builder.get_data_field::<u16>(6) {
+                0 => ::core::result::Result::Ok(File(())),
+                1 => ::core::result::Result::Ok(Struct(self.builder.into())),
+                2 => ::core::result::Result::Ok(Enum(self.builder.into())),
+                3 => ::core::result::Result::Ok(Interface(self.builder.into())),
+                4 => ::core::result::Result::Ok(Const(self.builder.into())),
+                5 => ::core::result::Result::Ok(Annotation(self.builder.into())),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {}
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 225] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+            crate::word(13, 0, 0, 0, 1, 0, 5, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(6, 0, 7, 0, 0, 0, 6, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 146, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 55, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(73, 0, 0, 0, 23, 3, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+            crate::word(101, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(177, 163, 15, 241, 204, 27, 82, 185),
+            crate::word(17, 0, 0, 0, 82, 0, 0, 0),
+            crate::word(66, 194, 15, 250, 187, 85, 191, 222),
+            crate::word(17, 0, 0, 0, 90, 0, 0, 0),
+            crate::word(174, 87, 19, 4, 227, 29, 142, 243),
+            crate::word(17, 0, 0, 0, 90, 0, 0, 0),
+            crate::word(80, 97, 114, 97, 109, 101, 116, 101),
+            crate::word(114, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(78, 101, 115, 116, 101, 100, 78, 111),
+            crate::word(100, 101, 0, 0, 0, 0, 0, 0),
+            crate::word(83, 111, 117, 114, 99, 101, 73, 110),
+            crate::word(102, 111, 0, 0, 0, 0, 0, 0),
+            crate::word(56, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(121, 1, 0, 0, 26, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(116, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(128, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(125, 1, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(124, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(136, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(133, 1, 0, 0, 194, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(136, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(148, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(3, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(145, 1, 0, 0, 66, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(140, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(152, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(6, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 4, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(149, 1, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(148, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(176, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(7, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 5, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(173, 1, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(172, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(200, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(8, 0, 255, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 6, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(197, 1, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(192, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(204, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(9, 0, 254, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(53, 68, 251, 55, 155, 177, 160, 158),
+            crate::word(201, 1, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(10, 0, 253, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(152, 245, 51, 67, 54, 179, 74, 181),
+            crate::word(177, 1, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(11, 0, 252, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(143, 33, 194, 240, 207, 83, 39, 232),
+            crate::word(153, 1, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 251, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(32, 148, 13, 122, 172, 165, 138, 177),
+            crate::word(133, 1, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(13, 0, 250, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(144, 2, 10, 64, 212, 25, 22, 236),
+            crate::word(109, 1, 0, 0, 90, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(4, 0, 0, 0, 5, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 32, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(89, 1, 0, 0, 90, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(88, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(116, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(5, 0, 0, 0, 32, 1, 0, 0),
+            crate::word(0, 0, 1, 0, 33, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(113, 1, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(112, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(124, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(100, 105, 115, 112, 108, 97, 121, 78),
+            crate::word(97, 109, 101, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(100, 105, 115, 112, 108, 97, 121, 78),
+            crate::word(97, 109, 101, 80, 114, 101, 102, 105),
+            crate::word(120, 76, 101, 110, 103, 116, 104, 0),
+            crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 111, 112, 101, 73, 100, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(110, 101, 115, 116, 101, 100, 78, 111),
+            crate::word(100, 101, 115, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(66, 194, 15, 250, 187, 85, 191, 222),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 110, 110, 111, 116, 97, 116, 105),
+            crate::word(111, 110, 115, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(66, 117, 37, 171, 13, 149, 200, 241),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(102, 105, 108, 101, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 116, 114, 117, 99, 116, 0, 0),
+            crate::word(101, 110, 117, 109, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 101, 114, 102, 97, 99),
+            crate::word(101, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(99, 111, 110, 115, 116, 0, 0, 0),
+            crate::word(97, 110, 110, 111, 116, 97, 116, 105),
+            crate::word(111, 110, 0, 0, 0, 0, 0, 0),
+            crate::word(112, 97, 114, 97, 109, 101, 116, 101),
+            crate::word(114, 115, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(177, 163, 15, 241, 204, 27, 82, 185),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 115, 71, 101, 110, 101, 114, 105),
+            crate::word(99, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <u64 as crate::introspect::Introspect>::introspect(),
+        1 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+        2 => <u32 as crate::introspect::Introspect>::introspect(),
+        3 => <u64 as crate::introspect::Introspect>::introspect(),
+        4 => <crate::struct_list::Owned<crate::schema_capnp::node::nested_node::Owned> as crate::introspect::Introspect>::introspect(),
+        5 => <crate::struct_list::Owned<crate::schema_capnp::annotation::Owned> as crate::introspect::Introspect>::introspect(),
+        6 => <() as crate::introspect::Introspect>::introspect(),
+        7 => <crate::schema_capnp::node::struct_::Owned as crate::introspect::Introspect>::introspect(),
+        8 => <crate::schema_capnp::node::enum_::Owned as crate::introspect::Introspect>::introspect(),
+        9 => <crate::schema_capnp::node::interface::Owned as crate::introspect::Introspect>::introspect(),
+        10 => <crate::schema_capnp::node::const_::Owned as crate::introspect::Introspect>::introspect(),
+        11 => <crate::schema_capnp::node::annotation::Owned as crate::introspect::Introspect>::introspect(),
+        12 => <crate::struct_list::Owned<crate::schema_capnp::node::parameter::Owned> as crate::introspect::Introspect>::introspect(),
+        13 => <bool as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3, 4, 5, 12, 13];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[6, 7, 8, 9, 10, 11];
+        pub const TYPE_ID: u64 = 0xe682_ab4c_f923_a417;
+    }
+    pub enum Which<A0, A1, A2, A3, A4> {
+        File(()),
+        Struct(A0),
+        Enum(A1),
+        Interface(A2),
+        Const(A3),
+        Annotation(A4),
+    }
+    pub type WhichReader<'a> = Which<
+        crate::schema_capnp::node::struct_::Reader<'a>,
+        crate::schema_capnp::node::enum_::Reader<'a>,
+        crate::schema_capnp::node::interface::Reader<'a>,
+        crate::schema_capnp::node::const_::Reader<'a>,
+        crate::schema_capnp::node::annotation::Reader<'a>,
+    >;
+    pub type WhichBuilder<'a> = Which<
+        crate::schema_capnp::node::struct_::Builder<'a>,
+        crate::schema_capnp::node::enum_::Builder<'a>,
+        crate::schema_capnp::node::interface::Builder<'a>,
+        crate::schema_capnp::node::const_::Builder<'a>,
+        crate::schema_capnp::node::annotation::Builder<'a>,
+    >;
+
+    pub mod parameter {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_name(self) -> crate::Result<crate::text::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_name(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 0,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_name(self) -> crate::Result<crate::text::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_name(&mut self, value: crate::text::Reader<'_>) {
+                self.builder.reborrow().get_pointer_field(0).set_text(value);
+            }
+            #[inline]
+            pub fn init_name(self, size: u32) -> crate::text::Builder<'a> {
+                self.builder.get_pointer_field(0).init_text(size)
+            }
+            #[inline]
+            pub fn has_name(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 33] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(177, 163, 15, 241, 204, 27, 82, 185),
+                crate::word(18, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(1, 0, 7, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 226, 0, 0, 0),
+                crate::word(33, 0, 0, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(29, 0, 0, 0, 63, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 80, 97, 114, 97, 109, 101),
+                crate::word(116, 101, 114, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(13, 0, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(20, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(110, 97, 109, 101, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+                    0 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                    _ => panic!("invalid field index {}", index),
+                }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xb952_1bcc_f10f_a3b1;
+        }
+    }
+
+    pub mod nested_node {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_name(self) -> crate::Result<crate::text::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_name(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+            #[inline]
+            pub fn get_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(0)
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 1,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_name(self) -> crate::Result<crate::text::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_name(&mut self, value: crate::text::Reader<'_>) {
+                self.builder.reborrow().get_pointer_field(0).set_text(value);
+            }
+            #[inline]
+            pub fn init_name(self, size: u32) -> crate::text::Builder<'a> {
+                self.builder.get_pointer_field(0).init_text(size)
+            }
+            #[inline]
+            pub fn has_name(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+            #[inline]
+            pub fn get_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn set_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(0, value);
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 48] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(66, 194, 15, 250, 187, 85, 191, 222),
+                crate::word(18, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(1, 0, 7, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 234, 0, 0, 0),
+                crate::word(33, 0, 0, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(29, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 78, 101, 115, 116, 101, 100),
+                crate::word(78, 111, 100, 101, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(45, 0, 0, 0, 26, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(110, 97, 109, 101, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+                    0 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                    1 => <u64 as crate::introspect::Introspect>::introspect(),
+                    _ => panic!("invalid field index {}", index),
+                }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xdebf_55bb_fa0f_c242;
+        }
+    }
+
+    pub mod source_info {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn get_doc_comment(self) -> crate::Result<crate::text::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_doc_comment(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+            #[inline]
+            pub fn get_members(
+                self,
+            ) -> crate::Result<
+                crate::struct_list::Reader<
+                    'a,
+                    crate::schema_capnp::node::source_info::member::Owned,
+                >,
+            > {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(1),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_members(&self) -> bool {
+                !self.reader.get_pointer_field(1).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 1,
+                    pointers: 2,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn set_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(0, value);
+            }
+            #[inline]
+            pub fn get_doc_comment(self) -> crate::Result<crate::text::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_doc_comment(&mut self, value: crate::text::Reader<'_>) {
+                self.builder.reborrow().get_pointer_field(0).set_text(value);
+            }
+            #[inline]
+            pub fn init_doc_comment(self, size: u32) -> crate::text::Builder<'a> {
+                self.builder.get_pointer_field(0).init_text(size)
+            }
+            #[inline]
+            pub fn has_doc_comment(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+            #[inline]
+            pub fn get_members(
+                self,
+            ) -> crate::Result<
+                crate::struct_list::Builder<
+                    'a,
+                    crate::schema_capnp::node::source_info::member::Owned,
+                >,
+            > {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(1),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_members(
+                &mut self,
+                value: crate::struct_list::Reader<
+                    'a,
+                    crate::schema_capnp::node::source_info::member::Owned,
+                >,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(1),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_members(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<
+                'a,
+                crate::schema_capnp::node::source_info::member::Owned,
+            > {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(1),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_members(&self) -> bool {
+                !self.builder.is_pointer_field_null(1)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 71] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(174, 87, 19, 4, 227, 29, 142, 243),
+                crate::word(18, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(2, 0, 7, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 234, 0, 0, 0),
+                crate::word(33, 0, 0, 0, 23, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 175, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 83, 111, 117, 114, 99, 101),
+                crate::word(73, 110, 102, 111, 0, 0, 0, 0),
+                crate::word(4, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(162, 31, 142, 137, 56, 144, 186, 194),
+                crate::word(1, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(77, 101, 109, 98, 101, 114, 0, 0),
+                crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(69, 0, 0, 0, 26, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(64, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(76, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(73, 0, 0, 0, 90, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(72, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(84, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(2, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(81, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(76, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(104, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(100, 111, 99, 67, 111, 109, 109, 101),
+                crate::word(110, 116, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(109, 101, 109, 98, 101, 114, 115, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(162, 31, 142, 137, 56, 144, 186, 194),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+                    0 => <u64 as crate::introspect::Introspect>::introspect(),
+                    1 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                    2 => <crate::struct_list::Owned<
+                        crate::schema_capnp::node::source_info::member::Owned,
+                    > as crate::introspect::Introspect>::introspect(),
+                    _ => panic!("invalid field index {}", index),
+                }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xf38e_1de3_0413_57ae;
+        }
+
+        pub mod member {
+            #[derive(Copy, Clone)]
+            pub struct Owned(());
+            impl crate::introspect::Introspect for Owned {
+                fn introspect() -> crate::introspect::Type {
+                    crate::introspect::TypeVariant::Struct(
+                        crate::introspect::RawBrandedStructSchema {
+                            generic: &_private::RAW_SCHEMA,
+                            field_types: _private::get_field_types,
+                            annotation_types: _private::get_annotation_types,
+                        },
+                    )
+                    .into()
+                }
+            }
+            impl crate::traits::Owned for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::OwnedStruct for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::Pipelined for Owned {
+                type Pipeline = Pipeline;
+            }
+
+            pub struct Reader<'a> {
+                reader: crate::private::layout::StructReader<'a>,
+            }
+            impl<'a> ::core::marker::Copy for Reader<'a> {}
+            impl<'a> ::core::clone::Clone for Reader<'a> {
+                fn clone(&self) -> Self {
+                    *self
+                }
+            }
+
+            impl<'a> crate::traits::HasTypeId for Reader<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+                fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                    Self { reader }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+                fn from(reader: Reader<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Reader::new(
+                        reader.reader,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> ::core::fmt::Debug for Reader<'a> {
+                fn fmt(
+                    &self,
+                    f: &mut ::core::fmt::Formatter<'_>,
+                ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                    core::fmt::Debug::fmt(
+                        &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                        f,
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+                fn get_from_pointer(
+                    reader: &crate::private::layout::PointerReader<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(reader.get_struct(default)?.into())
+                }
+            }
+
+            impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+                fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                    self.reader
+                }
+            }
+
+            impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+                fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                    self.reader
+                        .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+                }
+            }
+
+            impl<'a> Reader<'a> {
+                pub fn reborrow(&self) -> Reader<'_> {
+                    Self { ..*self }
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.reader.total_size()
+                }
+                #[inline]
+                pub fn get_doc_comment(self) -> crate::Result<crate::text::Reader<'a>> {
+                    crate::traits::FromPointerReader::get_from_pointer(
+                        &self.reader.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    )
+                }
+                #[inline]
+                pub fn has_doc_comment(&self) -> bool {
+                    !self.reader.get_pointer_field(0).is_null()
+                }
+            }
+
+            pub struct Builder<'a> {
+                builder: crate::private::layout::StructBuilder<'a>,
+            }
+            impl<'a> crate::traits::HasStructSize for Builder<'a> {
+                const STRUCT_SIZE: crate::private::layout::StructSize =
+                    crate::private::layout::StructSize {
+                        data: 0,
+                        pointers: 1,
+                    };
+            }
+            impl<'a> crate::traits::HasTypeId for Builder<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+                fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                    Self { builder }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+                fn from(builder: Builder<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Builder::new(
+                        builder.builder,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+                fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                    self.builder
+                        .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+                fn init_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    _size: u32,
+                ) -> Self {
+                    builder
+                        .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                        .into()
+                }
+                fn get_from_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(
+                        builder
+                            .get_struct(
+                                <Self as crate::traits::HasStructSize>::STRUCT_SIZE,
+                                default,
+                            )?
+                            .into(),
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+                fn set_pointer_builder(
+                    mut pointer: crate::private::layout::PointerBuilder<'_>,
+                    value: Self,
+                    canonicalize: bool,
+                ) -> crate::Result<()> {
+                    pointer.set_struct(&value.reader, canonicalize)
+                }
+            }
+
+            impl<'a> Builder<'a> {
+                pub fn into_reader(self) -> Reader<'a> {
+                    self.builder.into_reader().into()
+                }
+                pub fn reborrow(&mut self) -> Builder<'_> {
+                    Builder {
+                        builder: self.builder.reborrow(),
+                    }
+                }
+                pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                    self.builder.as_reader().into()
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.builder.as_reader().total_size()
+                }
+                #[inline]
+                pub fn get_doc_comment(self) -> crate::Result<crate::text::Builder<'a>> {
+                    crate::traits::FromPointerBuilder::get_from_pointer(
+                        self.builder.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    )
+                }
+                #[inline]
+                pub fn set_doc_comment(&mut self, value: crate::text::Reader<'_>) {
+                    self.builder.reborrow().get_pointer_field(0).set_text(value);
+                }
+                #[inline]
+                pub fn init_doc_comment(self, size: u32) -> crate::text::Builder<'a> {
+                    self.builder.get_pointer_field(0).init_text(size)
+                }
+                #[inline]
+                pub fn has_doc_comment(&self) -> bool {
+                    !self.builder.is_pointer_field_null(0)
+                }
+            }
+
+            pub struct Pipeline {
+                _typeless: crate::any_pointer::Pipeline,
+            }
+            impl crate::capability::FromTypelessPipeline for Pipeline {
+                fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                    Self {
+                        _typeless: typeless,
+                    }
+                }
+            }
+            impl Pipeline {}
+            mod _private {
+                pub static ENCODED_NODE: [crate::Word; 35] = [
+                    crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                    crate::word(162, 31, 142, 137, 56, 144, 186, 194),
+                    crate::word(29, 0, 0, 0, 1, 0, 0, 0),
+                    crate::word(174, 87, 19, 4, 227, 29, 142, 243),
+                    crate::word(1, 0, 7, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(21, 0, 0, 0, 34, 1, 0, 0),
+                    crate::word(37, 0, 0, 0, 7, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(33, 0, 0, 0, 63, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                    crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                    crate::word(101, 46, 83, 111, 117, 114, 99, 101),
+                    crate::word(73, 110, 102, 111, 46, 77, 101, 109),
+                    crate::word(98, 101, 114, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+                    crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(13, 0, 0, 0, 90, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(12, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(24, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(100, 111, 99, 67, 111, 109, 109, 101),
+                    crate::word(110, 116, 0, 0, 0, 0, 0, 0),
+                    crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                ];
+                pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                    match index {
+                        0 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                        _ => panic!("invalid field index {}", index),
+                    }
+                }
+                pub fn get_annotation_types(
+                    child_index: Option<u16>,
+                    index: u32,
+                ) -> crate::introspect::Type {
+                    panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+                }
+                pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                    crate::introspect::RawStructSchema {
+                        encoded_node: &ENCODED_NODE,
+                        nonunion_members: NONUNION_MEMBERS,
+                        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                    };
+                pub static NONUNION_MEMBERS: &[u16] = &[0];
+                pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+                pub const TYPE_ID: u64 = 0xc2ba_9038_898e_1fa2;
+            }
+        }
+    }
+
+    pub mod struct_ {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_data_word_count(self) -> u16 {
+                self.reader.get_data_field::<u16>(7)
+            }
+            #[inline]
+            pub fn get_pointer_count(self) -> u16 {
+                self.reader.get_data_field::<u16>(12)
+            }
+            #[inline]
+            pub fn get_preferred_list_encoding(
+                self,
+            ) -> ::core::result::Result<crate::schema_capnp::ElementSize, crate::NotInSchema>
+            {
+                ::core::convert::TryInto::try_into(self.reader.get_data_field::<u16>(13))
+            }
+            #[inline]
+            pub fn get_is_group(self) -> bool {
+                self.reader.get_bool_field(224)
+            }
+            #[inline]
+            pub fn get_discriminant_count(self) -> u16 {
+                self.reader.get_data_field::<u16>(15)
+            }
+            #[inline]
+            pub fn get_discriminant_offset(self) -> u32 {
+                self.reader.get_data_field::<u32>(8)
+            }
+            #[inline]
+            pub fn get_fields(
+                self,
+            ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::field::Owned>>
+            {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_fields(&self) -> bool {
+                !self.reader.get_pointer_field(3).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 5,
+                    pointers: 6,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_data_word_count(self) -> u16 {
+                self.builder.get_data_field::<u16>(7)
+            }
+            #[inline]
+            pub fn set_data_word_count(&mut self, value: u16) {
+                self.builder.set_data_field::<u16>(7, value);
+            }
+            #[inline]
+            pub fn get_pointer_count(self) -> u16 {
+                self.builder.get_data_field::<u16>(12)
+            }
+            #[inline]
+            pub fn set_pointer_count(&mut self, value: u16) {
+                self.builder.set_data_field::<u16>(12, value);
+            }
+            #[inline]
+            pub fn get_preferred_list_encoding(
+                self,
+            ) -> ::core::result::Result<crate::schema_capnp::ElementSize, crate::NotInSchema>
+            {
+                ::core::convert::TryInto::try_into(self.builder.get_data_field::<u16>(13))
+            }
+            #[inline]
+            pub fn set_preferred_list_encoding(&mut self, value: crate::schema_capnp::ElementSize) {
+                self.builder.set_data_field::<u16>(13, value as u16);
+            }
+            #[inline]
+            pub fn get_is_group(self) -> bool {
+                self.builder.get_bool_field(224)
+            }
+            #[inline]
+            pub fn set_is_group(&mut self, value: bool) {
+                self.builder.set_bool_field(224, value);
+            }
+            #[inline]
+            pub fn get_discriminant_count(self) -> u16 {
+                self.builder.get_data_field::<u16>(15)
+            }
+            #[inline]
+            pub fn set_discriminant_count(&mut self, value: u16) {
+                self.builder.set_data_field::<u16>(15, value);
+            }
+            #[inline]
+            pub fn get_discriminant_offset(self) -> u32 {
+                self.builder.get_data_field::<u32>(8)
+            }
+            #[inline]
+            pub fn set_discriminant_offset(&mut self, value: u32) {
+                self.builder.set_data_field::<u32>(8, value);
+            }
+            #[inline]
+            pub fn get_fields(
+                self,
+            ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::field::Owned>>
+            {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_fields(
+                &mut self,
+                value: crate::struct_list::Reader<'a, crate::schema_capnp::field::Owned>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(3),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_fields(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<'a, crate::schema_capnp::field::Owned> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(3),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_fields(&self) -> bool {
+                !self.builder.is_pointer_field_null(3)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 134] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(53, 68, 251, 55, 155, 177, 160, 158),
+                crate::word(18, 0, 0, 0, 1, 0, 5, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(6, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 202, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 143, 1, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 115, 116, 114, 117, 99, 116),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(28, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(181, 0, 0, 0, 114, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(180, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(192, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 12, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 8, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(189, 0, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(188, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(200, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(2, 0, 0, 0, 13, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 9, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(197, 0, 0, 0, 178, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(200, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(212, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(3, 0, 0, 0, 224, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 10, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(209, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(204, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(216, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(4, 0, 0, 0, 15, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 11, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(213, 0, 0, 0, 146, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(216, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(228, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(5, 0, 0, 0, 8, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 12, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(225, 0, 0, 0, 154, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(228, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(240, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(6, 0, 0, 0, 3, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 13, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(237, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(232, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(4, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(100, 97, 116, 97, 87, 111, 114, 100),
+                crate::word(67, 111, 117, 110, 116, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(112, 111, 105, 110, 116, 101, 114, 67),
+                crate::word(111, 117, 110, 116, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(112, 114, 101, 102, 101, 114, 114, 101),
+                crate::word(100, 76, 105, 115, 116, 69, 110, 99),
+                crate::word(111, 100, 105, 110, 103, 0, 0, 0),
+                crate::word(15, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(38, 25, 82, 186, 125, 143, 149, 209),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(15, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 115, 71, 114, 111, 117, 112, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(100, 105, 115, 99, 114, 105, 109, 105),
+                crate::word(110, 97, 110, 116, 67, 111, 117, 110),
+                crate::word(116, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(100, 105, 115, 99, 114, 105, 109, 105),
+                crate::word(110, 97, 110, 116, 79, 102, 102, 115),
+                crate::word(101, 116, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(102, 105, 101, 108, 100, 115, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(95, 244, 74, 31, 164, 80, 173, 154),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <u16 as crate::introspect::Introspect>::introspect(),
+          1 => <u16 as crate::introspect::Introspect>::introspect(),
+          2 => <crate::schema_capnp::ElementSize as crate::introspect::Introspect>::introspect(),
+          3 => <bool as crate::introspect::Introspect>::introspect(),
+          4 => <u16 as crate::introspect::Introspect>::introspect(),
+          5 => <u32 as crate::introspect::Introspect>::introspect(),
+          6 => <crate::struct_list::Owned<crate::schema_capnp::field::Owned> as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3, 4, 5, 6];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0x9ea0_b19b_37fb_4435;
+        }
+    }
+
+    pub mod enum_ {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_enumerants(
+                self,
+            ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::enumerant::Owned>>
+            {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_enumerants(&self) -> bool {
+                !self.reader.get_pointer_field(3).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 5,
+                    pointers: 6,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_enumerants(
+                self,
+            ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::enumerant::Owned>>
+            {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_enumerants(
+                &mut self,
+                value: crate::struct_list::Reader<'a, crate::schema_capnp::enumerant::Owned>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(3),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_enumerants(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<'a, crate::schema_capnp::enumerant::Owned>
+            {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(3),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_enumerants(&self) -> bool {
+                !self.builder.is_pointer_field_null(3)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 36] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(152, 245, 51, 67, 54, 179, 74, 181),
+                crate::word(18, 0, 0, 0, 1, 0, 5, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(6, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 186, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 63, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 101, 110, 117, 109, 0, 0),
+                crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 14, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(13, 0, 0, 0, 90, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(40, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(101, 110, 117, 109, 101, 114, 97, 110),
+                crate::word(116, 115, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(77, 154, 84, 220, 235, 124, 138, 151),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <crate::struct_list::Owned<crate::schema_capnp::enumerant::Owned> as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xb54a_b336_4333_f598;
+        }
+    }
+
+    pub mod interface {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_methods(
+                self,
+            ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::method::Owned>>
+            {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_methods(&self) -> bool {
+                !self.reader.get_pointer_field(3).is_null()
+            }
+            #[inline]
+            pub fn get_superclasses(
+                self,
+            ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::superclass::Owned>>
+            {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(4),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_superclasses(&self) -> bool {
+                !self.reader.get_pointer_field(4).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 5,
+                    pointers: 6,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_methods(
+                self,
+            ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::method::Owned>>
+            {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_methods(
+                &mut self,
+                value: crate::struct_list::Reader<'a, crate::schema_capnp::method::Owned>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(3),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_methods(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<'a, crate::schema_capnp::method::Owned> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(3),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_methods(&self) -> bool {
+                !self.builder.is_pointer_field_null(3)
+            }
+            #[inline]
+            pub fn get_superclasses(
+                self,
+            ) -> crate::Result<
+                crate::struct_list::Builder<'a, crate::schema_capnp::superclass::Owned>,
+            > {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(4),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_superclasses(
+                &mut self,
+                value: crate::struct_list::Reader<'a, crate::schema_capnp::superclass::Owned>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(4),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_superclasses(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<'a, crate::schema_capnp::superclass::Owned>
+            {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(4),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_superclasses(&self) -> bool {
+                !self.builder.is_pointer_field_null(4)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 56] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(143, 33, 194, 240, 207, 83, 39, 232),
+                crate::word(18, 0, 0, 0, 1, 0, 5, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(6, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 226, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 105, 110, 116, 101, 114, 102),
+                crate::word(97, 99, 101, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 15, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(64, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 4, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 31, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(61, 0, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(60, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(88, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(109, 101, 116, 104, 111, 100, 115, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(128, 77, 51, 59, 226, 204, 0, 149),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 117, 112, 101, 114, 99, 108, 97),
+                crate::word(115, 115, 101, 115, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(248, 215, 164, 208, 158, 42, 150, 169),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <crate::struct_list::Owned<crate::schema_capnp::method::Owned> as crate::introspect::Introspect>::introspect(),
+          1 => <crate::struct_list::Owned<crate::schema_capnp::superclass::Owned> as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xe827_53cf_f0c2_218f;
+        }
+    }
+
+    pub mod const_ {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_type(self) -> crate::Result<crate::schema_capnp::type_::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                !self.reader.get_pointer_field(3).is_null()
+            }
+            #[inline]
+            pub fn get_value(self) -> crate::Result<crate::schema_capnp::value::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(4),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_value(&self) -> bool {
+                !self.reader.get_pointer_field(4).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 5,
+                    pointers: 6,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_type(self) -> crate::Result<crate::schema_capnp::type_::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_type(
+                &mut self,
+                value: crate::schema_capnp::type_::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(3),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_type(self) -> crate::schema_capnp::type_::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(3),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                !self.builder.is_pointer_field_null(3)
+            }
+            #[inline]
+            pub fn get_value(self) -> crate::Result<crate::schema_capnp::value::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(4),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_value(
+                &mut self,
+                value: crate::schema_capnp::value::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(4),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_value(self) -> crate::schema_capnp::value::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(4),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_value(&self) -> bool {
+                !self.builder.is_pointer_field_null(4)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_type(&self) -> crate::schema_capnp::type_::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(3))
+            }
+            pub fn get_value(&self) -> crate::schema_capnp::value::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(4))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 46] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(32, 148, 13, 122, 172, 165, 138, 177),
+                crate::word(18, 0, 0, 0, 1, 0, 5, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(6, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 194, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 99, 111, 110, 115, 116, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 16, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 4, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 17, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(45, 0, 0, 0, 50, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(116, 121, 112, 101, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(118, 97, 108, 117, 101, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(155, 12, 176, 215, 210, 220, 35, 206),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <crate::schema_capnp::type_::Owned as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::value::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xb18a_a5ac_7a0d_9420;
+        }
+    }
+
+    pub mod annotation {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_type(self) -> crate::Result<crate::schema_capnp::type_::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                !self.reader.get_pointer_field(3).is_null()
+            }
+            #[inline]
+            pub fn get_targets_file(self) -> bool {
+                self.reader.get_bool_field(112)
+            }
+            #[inline]
+            pub fn get_targets_const(self) -> bool {
+                self.reader.get_bool_field(113)
+            }
+            #[inline]
+            pub fn get_targets_enum(self) -> bool {
+                self.reader.get_bool_field(114)
+            }
+            #[inline]
+            pub fn get_targets_enumerant(self) -> bool {
+                self.reader.get_bool_field(115)
+            }
+            #[inline]
+            pub fn get_targets_struct(self) -> bool {
+                self.reader.get_bool_field(116)
+            }
+            #[inline]
+            pub fn get_targets_field(self) -> bool {
+                self.reader.get_bool_field(117)
+            }
+            #[inline]
+            pub fn get_targets_union(self) -> bool {
+                self.reader.get_bool_field(118)
+            }
+            #[inline]
+            pub fn get_targets_group(self) -> bool {
+                self.reader.get_bool_field(119)
+            }
+            #[inline]
+            pub fn get_targets_interface(self) -> bool {
+                self.reader.get_bool_field(120)
+            }
+            #[inline]
+            pub fn get_targets_method(self) -> bool {
+                self.reader.get_bool_field(121)
+            }
+            #[inline]
+            pub fn get_targets_param(self) -> bool {
+                self.reader.get_bool_field(122)
+            }
+            #[inline]
+            pub fn get_targets_annotation(self) -> bool {
+                self.reader.get_bool_field(123)
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 5,
+                    pointers: 6,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_type(self) -> crate::Result<crate::schema_capnp::type_::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_type(
+                &mut self,
+                value: crate::schema_capnp::type_::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(3),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_type(self) -> crate::schema_capnp::type_::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(3),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                !self.builder.is_pointer_field_null(3)
+            }
+            #[inline]
+            pub fn get_targets_file(self) -> bool {
+                self.builder.get_bool_field(112)
+            }
+            #[inline]
+            pub fn set_targets_file(&mut self, value: bool) {
+                self.builder.set_bool_field(112, value);
+            }
+            #[inline]
+            pub fn get_targets_const(self) -> bool {
+                self.builder.get_bool_field(113)
+            }
+            #[inline]
+            pub fn set_targets_const(&mut self, value: bool) {
+                self.builder.set_bool_field(113, value);
+            }
+            #[inline]
+            pub fn get_targets_enum(self) -> bool {
+                self.builder.get_bool_field(114)
+            }
+            #[inline]
+            pub fn set_targets_enum(&mut self, value: bool) {
+                self.builder.set_bool_field(114, value);
+            }
+            #[inline]
+            pub fn get_targets_enumerant(self) -> bool {
+                self.builder.get_bool_field(115)
+            }
+            #[inline]
+            pub fn set_targets_enumerant(&mut self, value: bool) {
+                self.builder.set_bool_field(115, value);
+            }
+            #[inline]
+            pub fn get_targets_struct(self) -> bool {
+                self.builder.get_bool_field(116)
+            }
+            #[inline]
+            pub fn set_targets_struct(&mut self, value: bool) {
+                self.builder.set_bool_field(116, value);
+            }
+            #[inline]
+            pub fn get_targets_field(self) -> bool {
+                self.builder.get_bool_field(117)
+            }
+            #[inline]
+            pub fn set_targets_field(&mut self, value: bool) {
+                self.builder.set_bool_field(117, value);
+            }
+            #[inline]
+            pub fn get_targets_union(self) -> bool {
+                self.builder.get_bool_field(118)
+            }
+            #[inline]
+            pub fn set_targets_union(&mut self, value: bool) {
+                self.builder.set_bool_field(118, value);
+            }
+            #[inline]
+            pub fn get_targets_group(self) -> bool {
+                self.builder.get_bool_field(119)
+            }
+            #[inline]
+            pub fn set_targets_group(&mut self, value: bool) {
+                self.builder.set_bool_field(119, value);
+            }
+            #[inline]
+            pub fn get_targets_interface(self) -> bool {
+                self.builder.get_bool_field(120)
+            }
+            #[inline]
+            pub fn set_targets_interface(&mut self, value: bool) {
+                self.builder.set_bool_field(120, value);
+            }
+            #[inline]
+            pub fn get_targets_method(self) -> bool {
+                self.builder.get_bool_field(121)
+            }
+            #[inline]
+            pub fn set_targets_method(&mut self, value: bool) {
+                self.builder.set_bool_field(121, value);
+            }
+            #[inline]
+            pub fn get_targets_param(self) -> bool {
+                self.builder.get_bool_field(122)
+            }
+            #[inline]
+            pub fn set_targets_param(&mut self, value: bool) {
+                self.builder.set_bool_field(122, value);
+            }
+            #[inline]
+            pub fn get_targets_annotation(self) -> bool {
+                self.builder.get_bool_field(123)
+            }
+            #[inline]
+            pub fn set_targets_annotation(&mut self, value: bool) {
+                self.builder.set_bool_field(123, value);
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_type(&self) -> crate::schema_capnp::type_::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(3))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 227] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(144, 2, 10, 64, 212, 25, 22, 236),
+                crate::word(18, 0, 0, 0, 1, 0, 5, 0),
+                crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+                crate::word(6, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 234, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 223, 2, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 78, 111, 100),
+                crate::word(101, 46, 97, 110, 110, 111, 116, 97),
+                crate::word(116, 105, 111, 110, 0, 0, 0, 0),
+                crate::word(52, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 18, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(93, 1, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(88, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(100, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 112, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 19, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(97, 1, 0, 0, 98, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(108, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(2, 0, 0, 0, 113, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 20, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 1, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(104, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(116, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(3, 0, 0, 0, 114, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 21, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(113, 1, 0, 0, 98, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(112, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(124, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(4, 0, 0, 0, 115, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 22, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(121, 1, 0, 0, 138, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(124, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(136, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(5, 0, 0, 0, 116, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 23, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(133, 1, 0, 0, 114, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(132, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(144, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(6, 0, 0, 0, 117, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 24, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(141, 1, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(140, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(152, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(7, 0, 0, 0, 118, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 25, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(149, 1, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(148, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(160, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(8, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 26, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(157, 1, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(156, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(168, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(9, 0, 0, 0, 120, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 27, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(165, 1, 0, 0, 138, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(168, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(180, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(10, 0, 0, 0, 121, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 28, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(177, 1, 0, 0, 114, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(176, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(188, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(11, 0, 0, 0, 122, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 29, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(185, 1, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(184, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(196, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(12, 0, 0, 0, 123, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 30, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(193, 1, 0, 0, 146, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(196, 1, 0, 0, 3, 0, 1, 0),
+                crate::word(208, 1, 0, 0, 2, 0, 1, 0),
+                crate::word(116, 121, 112, 101, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 70),
+                crate::word(105, 108, 101, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 67),
+                crate::word(111, 110, 115, 116, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 69),
+                crate::word(110, 117, 109, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 69),
+                crate::word(110, 117, 109, 101, 114, 97, 110, 116),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 83),
+                crate::word(116, 114, 117, 99, 116, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 70),
+                crate::word(105, 101, 108, 100, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 85),
+                crate::word(110, 105, 111, 110, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 71),
+                crate::word(114, 111, 117, 112, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 73),
+                crate::word(110, 116, 101, 114, 102, 97, 99, 101),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 77),
+                crate::word(101, 116, 104, 111, 100, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 80),
+                crate::word(97, 114, 97, 109, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 97, 114, 103, 101, 116, 115, 65),
+                crate::word(110, 110, 111, 116, 97, 116, 105, 111),
+                crate::word(110, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <crate::schema_capnp::type_::Owned as crate::introspect::Introspect>::introspect(),
+          1 => <bool as crate::introspect::Introspect>::introspect(),
+          2 => <bool as crate::introspect::Introspect>::introspect(),
+          3 => <bool as crate::introspect::Introspect>::introspect(),
+          4 => <bool as crate::introspect::Introspect>::introspect(),
+          5 => <bool as crate::introspect::Introspect>::introspect(),
+          6 => <bool as crate::introspect::Introspect>::introspect(),
+          7 => <bool as crate::introspect::Introspect>::introspect(),
+          8 => <bool as crate::introspect::Introspect>::introspect(),
+          9 => <bool as crate::introspect::Introspect>::introspect(),
+          10 => <bool as crate::introspect::Introspect>::introspect(),
+          11 => <bool as crate::introspect::Introspect>::introspect(),
+          12 => <bool as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xec16_19d4_400a_0290;
+        }
+    }
+}
+
+pub mod field {
+    pub use self::Which::{Group, Slot};
+
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_name(self) -> crate::Result<crate::text::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_name(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn get_code_order(self) -> u16 {
+            self.reader.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.reader.get_pointer_field(1).is_null()
+        }
+        #[inline]
+        pub fn get_discriminant_value(self) -> u16 {
+            self.reader.get_data_field_mask::<u16>(1, 65535)
+        }
+        #[inline]
+        pub fn get_ordinal(self) -> crate::schema_capnp::field::ordinal::Reader<'a> {
+            self.reader.into()
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+            match self.reader.get_data_field::<u16>(4) {
+                0 => ::core::result::Result::Ok(Slot(self.reader.into())),
+                1 => ::core::result::Result::Ok(Group(self.reader.into())),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 3,
+                pointers: 4,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_name(self) -> crate::Result<crate::text::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_name(&mut self, value: crate::text::Reader<'_>) {
+            self.builder.reborrow().get_pointer_field(0).set_text(value);
+        }
+        #[inline]
+        pub fn init_name(self, size: u32) -> crate::text::Builder<'a> {
+            self.builder.get_pointer_field(0).init_text(size)
+        }
+        #[inline]
+        pub fn has_name(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn get_code_order(self) -> u16 {
+            self.builder.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn set_code_order(&mut self, value: u16) {
+            self.builder.set_data_field::<u16>(0, value);
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_annotations(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(1),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_annotations(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), size)
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.builder.is_pointer_field_null(1)
+        }
+        #[inline]
+        pub fn get_discriminant_value(self) -> u16 {
+            self.builder.get_data_field_mask::<u16>(1, 65535)
+        }
+        #[inline]
+        pub fn set_discriminant_value(&mut self, value: u16) {
+            self.builder.set_data_field_mask::<u16>(1, value, 65535);
+        }
+        #[inline]
+        pub fn init_slot(mut self) -> crate::schema_capnp::field::slot::Builder<'a> {
+            self.builder.set_data_field::<u16>(4, 0);
+            self.builder.set_data_field::<u32>(1, 0u32);
+            self.builder.reborrow().get_pointer_field(2).clear();
+            self.builder.reborrow().get_pointer_field(3).clear();
+            self.builder.set_bool_field(128, false);
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_group(self) -> crate::schema_capnp::field::group::Builder<'a> {
+            self.builder.set_data_field::<u16>(4, 1);
+            self.builder.set_data_field::<u64>(2, 0u64);
+            self.builder.into()
+        }
+        #[inline]
+        pub fn get_ordinal(self) -> crate::schema_capnp::field::ordinal::Builder<'a> {
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_ordinal(self) -> crate::schema_capnp::field::ordinal::Builder<'a> {
+            self.builder.set_data_field::<u16>(5, 0);
+            self.builder.set_data_field::<u16>(6, 0u16);
+            self.builder.into()
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+            match self.builder.get_data_field::<u16>(4) {
+                0 => ::core::result::Result::Ok(Slot(self.builder.into())),
+                1 => ::core::result::Result::Ok(Group(self.builder.into())),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {
+        pub fn get_ordinal(&self) -> crate::schema_capnp::field::ordinal::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.noop())
+        }
+    }
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 113] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(95, 244, 74, 31, 164, 80, 173, 154),
+            crate::word(13, 0, 0, 0, 1, 0, 3, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(4, 0, 7, 0, 0, 0, 2, 0),
+            crate::word(4, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 154, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 23, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(41, 0, 0, 0, 143, 1, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 70, 105, 101),
+            crate::word(108, 100, 0, 0, 0, 0, 0, 0),
+            crate::word(4, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(18, 199, 254, 124, 190, 76, 177, 151),
+            crate::word(1, 0, 0, 0, 122, 0, 0, 0),
+            crate::word(110, 111, 68, 105, 115, 99, 114, 105),
+            crate::word(109, 105, 110, 97, 110, 116, 0, 0),
+            crate::word(28, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(181, 0, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(176, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(188, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(185, 0, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(184, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(196, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(193, 0, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(192, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(220, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(3, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 3, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(217, 0, 0, 0, 146, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(220, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(232, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(4, 0, 255, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(111, 116, 180, 107, 71, 5, 35, 196),
+            crate::word(229, 0, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(5, 0, 254, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(17, 29, 219, 104, 219, 205, 252, 202),
+            crate::word(205, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(230, 11, 135, 135, 194, 213, 144, 187),
+            crate::word(181, 0, 0, 0, 66, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(110, 97, 109, 101, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(99, 111, 100, 101, 79, 114, 100, 101),
+            crate::word(114, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 110, 110, 111, 116, 97, 116, 105),
+            crate::word(111, 110, 115, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(66, 117, 37, 171, 13, 149, 200, 241),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(100, 105, 115, 99, 114, 105, 109, 105),
+            crate::word(110, 97, 110, 116, 86, 97, 108, 117),
+            crate::word(101, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 255, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 108, 111, 116, 0, 0, 0, 0),
+            crate::word(103, 114, 111, 117, 112, 0, 0, 0),
+            crate::word(111, 114, 100, 105, 110, 97, 108, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+        1 => <u16 as crate::introspect::Introspect>::introspect(),
+        2 => <crate::struct_list::Owned<crate::schema_capnp::annotation::Owned> as crate::introspect::Introspect>::introspect(),
+        3 => <u16 as crate::introspect::Introspect>::introspect(),
+        4 => <crate::schema_capnp::field::slot::Owned as crate::introspect::Introspect>::introspect(),
+        5 => <crate::schema_capnp::field::group::Owned as crate::introspect::Introspect>::introspect(),
+        6 => <crate::schema_capnp::field::ordinal::Owned as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3, 6];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[4, 5];
+        pub const TYPE_ID: u64 = 0x9aad_50a4_1f4a_f45f;
+    }
+    pub enum Which<A0, A1> {
+        Slot(A0),
+        Group(A1),
+    }
+    pub type WhichReader<'a> = Which<
+        crate::schema_capnp::field::slot::Reader<'a>,
+        crate::schema_capnp::field::group::Reader<'a>,
+    >;
+    pub type WhichBuilder<'a> = Which<
+        crate::schema_capnp::field::slot::Builder<'a>,
+        crate::schema_capnp::field::group::Builder<'a>,
+    >;
+    pub const NO_DISCRIMINANT: u16 = 65535;
+
+    pub mod slot {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_offset(self) -> u32 {
+                self.reader.get_data_field::<u32>(1)
+            }
+            #[inline]
+            pub fn get_type(self) -> crate::Result<crate::schema_capnp::type_::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(2),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                !self.reader.get_pointer_field(2).is_null()
+            }
+            #[inline]
+            pub fn get_default_value(
+                self,
+            ) -> crate::Result<crate::schema_capnp::value::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_default_value(&self) -> bool {
+                !self.reader.get_pointer_field(3).is_null()
+            }
+            #[inline]
+            pub fn get_had_explicit_default(self) -> bool {
+                self.reader.get_bool_field(128)
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 4,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_offset(self) -> u32 {
+                self.builder.get_data_field::<u32>(1)
+            }
+            #[inline]
+            pub fn set_offset(&mut self, value: u32) {
+                self.builder.set_data_field::<u32>(1, value);
+            }
+            #[inline]
+            pub fn get_type(self) -> crate::Result<crate::schema_capnp::type_::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(2),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_type(
+                &mut self,
+                value: crate::schema_capnp::type_::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(2),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_type(self) -> crate::schema_capnp::type_::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(2),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                !self.builder.is_pointer_field_null(2)
+            }
+            #[inline]
+            pub fn get_default_value(
+                self,
+            ) -> crate::Result<crate::schema_capnp::value::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(3),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_default_value(
+                &mut self,
+                value: crate::schema_capnp::value::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(3),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_default_value(self) -> crate::schema_capnp::value::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(3),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_default_value(&self) -> bool {
+                !self.builder.is_pointer_field_null(3)
+            }
+            #[inline]
+            pub fn get_had_explicit_default(self) -> bool {
+                self.builder.get_bool_field(128)
+            }
+            #[inline]
+            pub fn set_had_explicit_default(&mut self, value: bool) {
+                self.builder.set_bool_field(128, value);
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_type(&self) -> crate::schema_capnp::type_::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(2))
+            }
+            pub fn get_default_value(&self) -> crate::schema_capnp::value::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(3))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 79] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(111, 116, 180, 107, 71, 5, 35, 196),
+                crate::word(19, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(95, 244, 74, 31, 164, 80, 173, 154),
+                crate::word(4, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 194, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 231, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 70, 105, 101),
+                crate::word(108, 100, 46, 115, 108, 111, 116, 0),
+                crate::word(16, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 4, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(97, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(92, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(104, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 2, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 5, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(101, 0, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(108, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(2, 0, 0, 0, 3, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 6, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 0, 0, 0, 106, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(104, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(116, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(3, 0, 0, 0, 128, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 10, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(113, 0, 0, 0, 154, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(128, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(111, 102, 102, 115, 101, 116, 0, 0),
+                crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 121, 112, 101, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(100, 101, 102, 97, 117, 108, 116, 86),
+                crate::word(97, 108, 117, 101, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(155, 12, 176, 215, 210, 220, 35, 206),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(104, 97, 100, 69, 120, 112, 108, 105),
+                crate::word(99, 105, 116, 68, 101, 102, 97, 117),
+                crate::word(108, 116, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <u32 as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::type_::Owned as crate::introspect::Introspect>::introspect(),
+          2 => <crate::schema_capnp::value::Owned as crate::introspect::Introspect>::introspect(),
+          3 => <bool as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xc423_0547_6bb4_746f;
+        }
+    }
+
+    pub mod group {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(2)
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 4,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(2)
+            }
+            #[inline]
+            pub fn set_type_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(2, value);
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 32] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(17, 29, 219, 104, 219, 205, 252, 202),
+                crate::word(19, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(95, 244, 74, 31, 164, 80, 173, 154),
+                crate::word(4, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 202, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 63, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 70, 105, 101),
+                crate::word(108, 100, 46, 103, 114, 111, 117, 112),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 2, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(13, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(20, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(116, 121, 112, 101, 73, 100, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+                    0 => <u64 as crate::introspect::Introspect>::introspect(),
+                    _ => panic!("invalid field index {}", index),
+                }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xcafc_cddb_68db_1d11;
+        }
+    }
+
+    pub mod ordinal {
+        pub use self::Which::{Explicit, Implicit};
+
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichReader, crate::NotInSchema> {
+                match self.reader.get_data_field::<u16>(5) {
+                    0 => ::core::result::Result::Ok(Implicit(())),
+                    1 => ::core::result::Result::Ok(Explicit(self.reader.get_data_field::<u16>(6))),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 4,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn set_implicit(&mut self, _value: ()) {
+                self.builder.set_data_field::<u16>(5, 0);
+            }
+            #[inline]
+            pub fn set_explicit(&mut self, value: u16) {
+                self.builder.set_data_field::<u16>(5, 1);
+                self.builder.set_data_field::<u16>(6, value);
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichBuilder, crate::NotInSchema> {
+                match self.builder.get_data_field::<u16>(5) {
+                    0 => ::core::result::Result::Ok(Implicit(())),
+                    1 => {
+                        ::core::result::Result::Ok(Explicit(self.builder.get_data_field::<u16>(6)))
+                    }
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 49] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(230, 11, 135, 135, 194, 213, 144, 187),
+                crate::word(19, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(95, 244, 74, 31, 164, 80, 173, 154),
+                crate::word(4, 0, 7, 0, 1, 0, 2, 0),
+                crate::word(5, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 218, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 70, 105, 101),
+                crate::word(108, 100, 46, 111, 114, 100, 105, 110),
+                crate::word(97, 108, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 255, 255, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 8, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 74, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 254, 255, 6, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 9, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(49, 0, 0, 0, 74, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(48, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(60, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(105, 109, 112, 108, 105, 99, 105, 116),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(101, 120, 112, 108, 105, 99, 105, 116),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+                    0 => <() as crate::introspect::Introspect>::introspect(),
+                    1 => <u16 as crate::introspect::Introspect>::introspect(),
+                    _ => panic!("invalid field index {}", index),
+                }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[0, 1];
+            pub const TYPE_ID: u64 = 0xbb90_d5c2_8787_0be6;
+        }
+        pub enum Which {
+            Implicit(()),
+            Explicit(u16),
+        }
+        pub type WhichReader = Which;
+        pub type WhichBuilder = Which;
+    }
+}
+
+pub mod enumerant {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_name(self) -> crate::Result<crate::text::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_name(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn get_code_order(self) -> u16 {
+            self.reader.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.reader.get_pointer_field(1).is_null()
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 1,
+                pointers: 2,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_name(self) -> crate::Result<crate::text::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_name(&mut self, value: crate::text::Reader<'_>) {
+            self.builder.reborrow().get_pointer_field(0).set_text(value);
+        }
+        #[inline]
+        pub fn init_name(self, size: u32) -> crate::text::Builder<'a> {
+            self.builder.get_pointer_field(0).init_text(size)
+        }
+        #[inline]
+        pub fn has_name(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn get_code_order(self) -> u16 {
+            self.builder.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn set_code_order(&mut self, value: u16) {
+            self.builder.set_data_field::<u16>(0, value);
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_annotations(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(1),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_annotations(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), size)
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.builder.is_pointer_field_null(1)
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {}
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 68] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(77, 154, 84, 220, 235, 124, 138, 151),
+            crate::word(13, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(2, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 186, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 0, 0, 0, 175, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 69, 110, 117),
+            crate::word(109, 101, 114, 97, 110, 116, 0, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(69, 0, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(64, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(76, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(73, 0, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(72, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(84, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(81, 0, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(80, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(108, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(110, 97, 109, 101, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(99, 111, 100, 101, 79, 114, 100, 101),
+            crate::word(114, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 110, 110, 111, 116, 97, 116, 105),
+            crate::word(111, 110, 115, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(66, 117, 37, 171, 13, 149, 200, 241),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+        1 => <u16 as crate::introspect::Introspect>::introspect(),
+        2 => <crate::struct_list::Owned<crate::schema_capnp::annotation::Owned> as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0x978a_7ceb_dc54_9a4d;
+    }
+}
+
+pub mod superclass {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_id(self) -> u64 {
+            self.reader.get_data_field::<u64>(0)
+        }
+        #[inline]
+        pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_brand(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 1,
+                pointers: 1,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_id(self) -> u64 {
+            self.builder.get_data_field::<u64>(0)
+        }
+        #[inline]
+        pub fn set_id(&mut self, value: u64) {
+            self.builder.set_data_field::<u64>(0, value);
+        }
+        #[inline]
+        pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_brand(
+            &mut self,
+            value: crate::schema_capnp::brand::Reader<'_>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(0),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
+        }
+        #[inline]
+        pub fn has_brand(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {
+        pub fn get_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
+        }
+    }
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 47] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(248, 215, 164, 208, 158, 42, 150, 169),
+            crate::word(13, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(1, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 194, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 0, 0, 0, 119, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 83, 117, 112),
+            crate::word(101, 114, 99, 108, 97, 115, 115, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(41, 0, 0, 0, 26, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(45, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(98, 114, 97, 110, 100, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+                0 => <u64 as crate::introspect::Introspect>::introspect(),
+                1 => {
+                    <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(
+                    )
+                }
+                _ => panic!("invalid field index {}", index),
+            }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0xa996_2a9e_d0a4_d7f8;
+    }
+}
+
+pub mod method {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_name(self) -> crate::Result<crate::text::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_name(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn get_code_order(self) -> u16 {
+            self.reader.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn get_param_struct_type(self) -> u64 {
+            self.reader.get_data_field::<u64>(1)
+        }
+        #[inline]
+        pub fn get_result_struct_type(self) -> u64 {
+            self.reader.get_data_field::<u64>(2)
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.reader.get_pointer_field(1).is_null()
+        }
+        #[inline]
+        pub fn get_param_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(2),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_param_brand(&self) -> bool {
+            !self.reader.get_pointer_field(2).is_null()
+        }
+        #[inline]
+        pub fn get_result_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(3),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_result_brand(&self) -> bool {
+            !self.reader.get_pointer_field(3).is_null()
+        }
+        #[inline]
+        pub fn get_implicit_parameters(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Reader<'a, crate::schema_capnp::node::parameter::Owned>,
+        > {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(4),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_implicit_parameters(&self) -> bool {
+            !self.reader.get_pointer_field(4).is_null()
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 3,
+                pointers: 5,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_name(self) -> crate::Result<crate::text::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_name(&mut self, value: crate::text::Reader<'_>) {
+            self.builder.reborrow().get_pointer_field(0).set_text(value);
+        }
+        #[inline]
+        pub fn init_name(self, size: u32) -> crate::text::Builder<'a> {
+            self.builder.get_pointer_field(0).init_text(size)
+        }
+        #[inline]
+        pub fn has_name(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn get_code_order(self) -> u16 {
+            self.builder.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn set_code_order(&mut self, value: u16) {
+            self.builder.set_data_field::<u16>(0, value);
+        }
+        #[inline]
+        pub fn get_param_struct_type(self) -> u64 {
+            self.builder.get_data_field::<u64>(1)
+        }
+        #[inline]
+        pub fn set_param_struct_type(&mut self, value: u64) {
+            self.builder.set_data_field::<u64>(1, value);
+        }
+        #[inline]
+        pub fn get_result_struct_type(self) -> u64 {
+            self.builder.get_data_field::<u64>(2)
+        }
+        #[inline]
+        pub fn set_result_struct_type(&mut self, value: u64) {
+            self.builder.set_data_field::<u64>(2, value);
+        }
+        #[inline]
+        pub fn get_annotations(
+            self,
+        ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned>>
+        {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_annotations(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::annotation::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(1),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_annotations(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::annotation::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), size)
+        }
+        #[inline]
+        pub fn has_annotations(&self) -> bool {
+            !self.builder.is_pointer_field_null(1)
+        }
+        #[inline]
+        pub fn get_param_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(2),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_param_brand(
+            &mut self,
+            value: crate::schema_capnp::brand::Reader<'_>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(2),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_param_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(2), 0)
+        }
+        #[inline]
+        pub fn has_param_brand(&self) -> bool {
+            !self.builder.is_pointer_field_null(2)
+        }
+        #[inline]
+        pub fn get_result_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(3),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_result_brand(
+            &mut self,
+            value: crate::schema_capnp::brand::Reader<'_>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(3),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_result_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(3), 0)
+        }
+        #[inline]
+        pub fn has_result_brand(&self) -> bool {
+            !self.builder.is_pointer_field_null(3)
+        }
+        #[inline]
+        pub fn get_implicit_parameters(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Builder<'a, crate::schema_capnp::node::parameter::Owned>,
+        > {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(4),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_implicit_parameters(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::node::parameter::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(4),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_implicit_parameters(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::node::parameter::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(4), size)
+        }
+        #[inline]
+        pub fn has_implicit_parameters(&self) -> bool {
+            !self.builder.is_pointer_field_null(4)
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {
+        pub fn get_param_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(2))
+        }
+        pub fn get_result_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(3))
+        }
+    }
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 154] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(128, 77, 51, 59, 226, 204, 0, 149),
+            crate::word(13, 0, 0, 0, 1, 0, 3, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(5, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 162, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 0, 0, 0, 199, 1, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 77, 101, 116),
+            crate::word(104, 111, 100, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(32, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(209, 0, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(204, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(216, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(213, 0, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(212, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(224, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(3, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(221, 0, 0, 0, 130, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(220, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(232, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(5, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(229, 0, 0, 0, 138, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(232, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(244, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(7, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 4, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(241, 0, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(240, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(12, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(4, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 5, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 1, 0, 0, 90, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(20, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(6, 0, 0, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 6, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(17, 1, 0, 0, 98, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(28, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 4, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 1, 0, 0, 154, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(28, 1, 0, 0, 3, 0, 1, 0),
+            crate::word(56, 1, 0, 0, 2, 0, 1, 0),
+            crate::word(110, 97, 109, 101, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(99, 111, 100, 101, 79, 114, 100, 101),
+            crate::word(114, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(112, 97, 114, 97, 109, 83, 116, 114),
+            crate::word(117, 99, 116, 84, 121, 112, 101, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(114, 101, 115, 117, 108, 116, 83, 116),
+            crate::word(114, 117, 99, 116, 84, 121, 112, 101),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 110, 110, 111, 116, 97, 116, 105),
+            crate::word(111, 110, 115, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(66, 117, 37, 171, 13, 149, 200, 241),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(112, 97, 114, 97, 109, 66, 114, 97),
+            crate::word(110, 100, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(114, 101, 115, 117, 108, 116, 66, 114),
+            crate::word(97, 110, 100, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 109, 112, 108, 105, 99, 105, 116),
+            crate::word(80, 97, 114, 97, 109, 101, 116, 101),
+            crate::word(114, 115, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(177, 163, 15, 241, 204, 27, 82, 185),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+        1 => <u16 as crate::introspect::Introspect>::introspect(),
+        2 => <u64 as crate::introspect::Introspect>::introspect(),
+        3 => <u64 as crate::introspect::Introspect>::introspect(),
+        4 => <crate::struct_list::Owned<crate::schema_capnp::annotation::Owned> as crate::introspect::Introspect>::introspect(),
+        5 => <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(),
+        6 => <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(),
+        7 => <crate::struct_list::Owned<crate::schema_capnp::node::parameter::Owned> as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3, 4, 5, 6, 7];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0x9500_cce2_3b33_4d80;
+    }
+}
+
+pub mod type_ {
+    pub use self::Which::{
+        AnyPointer, Bool, Data, Enum, Float32, Float64, Int16, Int32, Int64, Int8, Interface, List,
+        Struct, Text, Uint16, Uint32, Uint64, Uint8, Void,
+    };
+
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+            match self.reader.get_data_field::<u16>(0) {
+                0 => ::core::result::Result::Ok(Void(())),
+                1 => ::core::result::Result::Ok(Bool(())),
+                2 => ::core::result::Result::Ok(Int8(())),
+                3 => ::core::result::Result::Ok(Int16(())),
+                4 => ::core::result::Result::Ok(Int32(())),
+                5 => ::core::result::Result::Ok(Int64(())),
+                6 => ::core::result::Result::Ok(Uint8(())),
+                7 => ::core::result::Result::Ok(Uint16(())),
+                8 => ::core::result::Result::Ok(Uint32(())),
+                9 => ::core::result::Result::Ok(Uint64(())),
+                10 => ::core::result::Result::Ok(Float32(())),
+                11 => ::core::result::Result::Ok(Float64(())),
+                12 => ::core::result::Result::Ok(Text(())),
+                13 => ::core::result::Result::Ok(Data(())),
+                14 => ::core::result::Result::Ok(List(self.reader.into())),
+                15 => ::core::result::Result::Ok(Enum(self.reader.into())),
+                16 => ::core::result::Result::Ok(Struct(self.reader.into())),
+                17 => ::core::result::Result::Ok(Interface(self.reader.into())),
+                18 => ::core::result::Result::Ok(AnyPointer(self.reader.into())),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 3,
+                pointers: 1,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn set_void(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 0);
+        }
+        #[inline]
+        pub fn set_bool(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 1);
+        }
+        #[inline]
+        pub fn set_int8(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 2);
+        }
+        #[inline]
+        pub fn set_int16(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 3);
+        }
+        #[inline]
+        pub fn set_int32(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 4);
+        }
+        #[inline]
+        pub fn set_int64(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 5);
+        }
+        #[inline]
+        pub fn set_uint8(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 6);
+        }
+        #[inline]
+        pub fn set_uint16(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 7);
+        }
+        #[inline]
+        pub fn set_uint32(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 8);
+        }
+        #[inline]
+        pub fn set_uint64(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 9);
+        }
+        #[inline]
+        pub fn set_float32(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 10);
+        }
+        #[inline]
+        pub fn set_float64(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 11);
+        }
+        #[inline]
+        pub fn set_text(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 12);
+        }
+        #[inline]
+        pub fn set_data(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 13);
+        }
+        #[inline]
+        pub fn init_list(mut self) -> crate::schema_capnp::type_::list::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 14);
+            self.builder.reborrow().get_pointer_field(0).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_enum(mut self) -> crate::schema_capnp::type_::enum_::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 15);
+            self.builder.set_data_field::<u64>(1, 0u64);
+            self.builder.reborrow().get_pointer_field(0).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_struct(mut self) -> crate::schema_capnp::type_::struct_::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 16);
+            self.builder.set_data_field::<u64>(1, 0u64);
+            self.builder.reborrow().get_pointer_field(0).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_interface(mut self) -> crate::schema_capnp::type_::interface::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 17);
+            self.builder.set_data_field::<u64>(1, 0u64);
+            self.builder.reborrow().get_pointer_field(0).clear();
+            self.builder.into()
+        }
+        #[inline]
+        pub fn init_any_pointer(self) -> crate::schema_capnp::type_::any_pointer::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 18);
+            self.builder.set_data_field::<u16>(4, 0);
+            self.builder.set_data_field::<u16>(5, 0);
+            self.builder.set_data_field::<u64>(2, 0u64);
+            self.builder.set_data_field::<u16>(5, 0u16);
+            self.builder.set_data_field::<u16>(5, 0u16);
+            self.builder.into()
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+            match self.builder.get_data_field::<u16>(0) {
+                0 => ::core::result::Result::Ok(Void(())),
+                1 => ::core::result::Result::Ok(Bool(())),
+                2 => ::core::result::Result::Ok(Int8(())),
+                3 => ::core::result::Result::Ok(Int16(())),
+                4 => ::core::result::Result::Ok(Int32(())),
+                5 => ::core::result::Result::Ok(Int64(())),
+                6 => ::core::result::Result::Ok(Uint8(())),
+                7 => ::core::result::Result::Ok(Uint16(())),
+                8 => ::core::result::Result::Ok(Uint32(())),
+                9 => ::core::result::Result::Ok(Uint64(())),
+                10 => ::core::result::Result::Ok(Float32(())),
+                11 => ::core::result::Result::Ok(Float64(())),
+                12 => ::core::result::Result::Ok(Text(())),
+                13 => ::core::result::Result::Ok(Data(())),
+                14 => ::core::result::Result::Ok(List(self.builder.into())),
+                15 => ::core::result::Result::Ok(Enum(self.builder.into())),
+                16 => ::core::result::Result::Ok(Struct(self.builder.into())),
+                17 => ::core::result::Result::Ok(Interface(self.builder.into())),
+                18 => ::core::result::Result::Ok(AnyPointer(self.builder.into())),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {}
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 269] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+            crate::word(13, 0, 0, 0, 1, 0, 3, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(1, 0, 7, 0, 0, 0, 19, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 146, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 0, 0, 0, 47, 4, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+            crate::word(101, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(76, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 255, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(5, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(12, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 254, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(4, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 253, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(13, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(20, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(3, 0, 252, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(17, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(24, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(4, 0, 251, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 4, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(28, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(5, 0, 250, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 5, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(20, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(32, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(6, 0, 249, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 6, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(29, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(24, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(36, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(7, 0, 248, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(33, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(28, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(40, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(8, 0, 247, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 8, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(37, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(32, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(44, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(9, 0, 246, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 9, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(41, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(36, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(48, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(10, 0, 245, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 10, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(45, 2, 0, 0, 66, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(40, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(52, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(11, 0, 244, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 11, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(49, 2, 0, 0, 66, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(44, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(56, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(12, 0, 243, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 12, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(53, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(48, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(60, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(13, 0, 242, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 13, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(57, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(52, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(64, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(14, 0, 241, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(151, 234, 96, 10, 37, 57, 231, 135),
+            crate::word(61, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(15, 0, 240, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(169, 135, 127, 26, 113, 120, 14, 158),
+            crate::word(37, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 239, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(211, 198, 76, 239, 96, 111, 58, 172),
+            crate::word(13, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(17, 0, 238, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(191, 12, 251, 247, 105, 202, 139, 237),
+            crate::word(245, 1, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(18, 0, 237, 255, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(241, 73, 62, 162, 232, 63, 87, 194),
+            crate::word(225, 1, 0, 0, 90, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(118, 111, 105, 100, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(98, 111, 111, 108, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 56, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 49, 54, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 51, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 54, 52, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 56, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 49, 54, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 51, 50, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 54, 52, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(102, 108, 111, 97, 116, 51, 50, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(102, 108, 111, 97, 116, 54, 52, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(116, 101, 120, 116, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(100, 97, 116, 97, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(108, 105, 115, 116, 0, 0, 0, 0),
+            crate::word(101, 110, 117, 109, 0, 0, 0, 0),
+            crate::word(115, 116, 114, 117, 99, 116, 0, 0),
+            crate::word(105, 110, 116, 101, 114, 102, 97, 99),
+            crate::word(101, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 110, 121, 80, 111, 105, 110, 116),
+            crate::word(101, 114, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <() as crate::introspect::Introspect>::introspect(),
+        1 => <() as crate::introspect::Introspect>::introspect(),
+        2 => <() as crate::introspect::Introspect>::introspect(),
+        3 => <() as crate::introspect::Introspect>::introspect(),
+        4 => <() as crate::introspect::Introspect>::introspect(),
+        5 => <() as crate::introspect::Introspect>::introspect(),
+        6 => <() as crate::introspect::Introspect>::introspect(),
+        7 => <() as crate::introspect::Introspect>::introspect(),
+        8 => <() as crate::introspect::Introspect>::introspect(),
+        9 => <() as crate::introspect::Introspect>::introspect(),
+        10 => <() as crate::introspect::Introspect>::introspect(),
+        11 => <() as crate::introspect::Introspect>::introspect(),
+        12 => <() as crate::introspect::Introspect>::introspect(),
+        13 => <() as crate::introspect::Introspect>::introspect(),
+        14 => <crate::schema_capnp::type_::list::Owned as crate::introspect::Introspect>::introspect(),
+        15 => <crate::schema_capnp::type_::enum_::Owned as crate::introspect::Introspect>::introspect(),
+        16 => <crate::schema_capnp::type_::struct_::Owned as crate::introspect::Introspect>::introspect(),
+        17 => <crate::schema_capnp::type_::interface::Owned as crate::introspect::Introspect>::introspect(),
+        18 => <crate::schema_capnp::type_::any_pointer::Owned as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
+        ];
+        pub const TYPE_ID: u64 = 0xd073_78ed_e1f9_cc60;
+    }
+    pub enum Which<A0, A1, A2, A3, A4> {
+        Void(()),
+        Bool(()),
+        Int8(()),
+        Int16(()),
+        Int32(()),
+        Int64(()),
+        Uint8(()),
+        Uint16(()),
+        Uint32(()),
+        Uint64(()),
+        Float32(()),
+        Float64(()),
+        Text(()),
+        Data(()),
+        List(A0),
+        Enum(A1),
+        Struct(A2),
+        Interface(A3),
+        AnyPointer(A4),
+    }
+    pub type WhichReader<'a> = Which<
+        crate::schema_capnp::type_::list::Reader<'a>,
+        crate::schema_capnp::type_::enum_::Reader<'a>,
+        crate::schema_capnp::type_::struct_::Reader<'a>,
+        crate::schema_capnp::type_::interface::Reader<'a>,
+        crate::schema_capnp::type_::any_pointer::Reader<'a>,
+    >;
+    pub type WhichBuilder<'a> = Which<
+        crate::schema_capnp::type_::list::Builder<'a>,
+        crate::schema_capnp::type_::enum_::Builder<'a>,
+        crate::schema_capnp::type_::struct_::Builder<'a>,
+        crate::schema_capnp::type_::interface::Builder<'a>,
+        crate::schema_capnp::type_::any_pointer::Builder<'a>,
+    >;
+
+    pub mod list {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_element_type(self) -> crate::Result<crate::schema_capnp::type_::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_element_type(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_element_type(
+                self,
+            ) -> crate::Result<crate::schema_capnp::type_::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_element_type(
+                &mut self,
+                value: crate::schema_capnp::type_::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(0),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_element_type(self) -> crate::schema_capnp::type_::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(0),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_element_type(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_element_type(&self) -> crate::schema_capnp::type_::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 32] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(151, 234, 96, 10, 37, 57, 231, 135),
+                crate::word(18, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(1, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 186, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 63, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                crate::word(101, 46, 108, 105, 115, 116, 0, 0),
+                crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 14, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(13, 0, 0, 0, 98, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(24, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(101, 108, 101, 109, 101, 110, 116, 84),
+                crate::word(121, 112, 101, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <crate::schema_capnp::type_::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0x87e7_3925_0a60_ea97;
+        }
+    }
+
+    pub mod enum_ {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(1)
+            }
+            #[inline]
+            pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_brand(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(1)
+            }
+            #[inline]
+            pub fn set_type_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(1, value);
+            }
+            #[inline]
+            pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_brand(
+                &mut self,
+                value: crate::schema_capnp::brand::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(0),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(0),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_brand(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 46] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(169, 135, 127, 26, 113, 120, 14, 158),
+                crate::word(18, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(1, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 186, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                crate::word(101, 46, 101, 110, 117, 109, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 15, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 21, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(45, 0, 0, 0, 50, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(116, 121, 112, 101, 73, 100, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(98, 114, 97, 110, 100, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <u64 as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0x9e0e_7871_1a7f_87a9;
+        }
+    }
+
+    pub mod struct_ {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(1)
+            }
+            #[inline]
+            pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_brand(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(1)
+            }
+            #[inline]
+            pub fn set_type_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(1, value);
+            }
+            #[inline]
+            pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_brand(
+                &mut self,
+                value: crate::schema_capnp::brand::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(0),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(0),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_brand(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 47] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(211, 198, 76, 239, 96, 111, 58, 172),
+                crate::word(18, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(1, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 202, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                crate::word(101, 46, 115, 116, 114, 117, 99, 116),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 16, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 22, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(45, 0, 0, 0, 50, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(116, 121, 112, 101, 73, 100, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(98, 114, 97, 110, 100, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <u64 as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xac3a_6f60_ef4c_c6d3;
+        }
+    }
+
+    pub mod interface {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(1)
+            }
+            #[inline]
+            pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_brand(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_type_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(1)
+            }
+            #[inline]
+            pub fn set_type_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(1, value);
+            }
+            #[inline]
+            pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_brand(
+                &mut self,
+                value: crate::schema_capnp::brand::Reader<'_>,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(0),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(0),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_brand(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {
+            pub fn get_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+                crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
+            }
+        }
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 47] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(191, 12, 251, 247, 105, 202, 139, 237),
+                crate::word(18, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(1, 0, 7, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 226, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                crate::word(101, 46, 105, 110, 116, 101, 114, 102),
+                crate::word(97, 99, 101, 0, 0, 0, 0, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 17, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 23, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(45, 0, 0, 0, 50, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(116, 121, 112, 101, 73, 100, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(98, 114, 97, 110, 100, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <u64 as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xed8b_ca69_f7fb_0cbf;
+        }
+    }
+
+    pub mod any_pointer {
+        pub use self::Which::{ImplicitMethodParameter, Parameter, Unconstrained};
+
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+                match self.reader.get_data_field::<u16>(4) {
+                    0 => ::core::result::Result::Ok(Unconstrained(self.reader.into())),
+                    1 => ::core::result::Result::Ok(Parameter(self.reader.into())),
+                    2 => ::core::result::Result::Ok(ImplicitMethodParameter(self.reader.into())),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 3,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn init_unconstrained(
+                self,
+            ) -> crate::schema_capnp::type_::any_pointer::unconstrained::Builder<'a> {
+                self.builder.set_data_field::<u16>(4, 0);
+                self.builder.set_data_field::<u16>(5, 0);
+                self.builder.into()
+            }
+            #[inline]
+            pub fn init_parameter(
+                self,
+            ) -> crate::schema_capnp::type_::any_pointer::parameter::Builder<'a> {
+                self.builder.set_data_field::<u16>(4, 1);
+                self.builder.set_data_field::<u64>(2, 0u64);
+                self.builder.set_data_field::<u16>(5, 0u16);
+                self.builder.into()
+            }
+            #[inline]
+            pub fn init_implicit_method_parameter(
+                self,
+            ) -> crate::schema_capnp::type_::any_pointer::implicit_method_parameter::Builder<'a>
+            {
+                self.builder.set_data_field::<u16>(4, 2);
+                self.builder.set_data_field::<u16>(5, 0u16);
+                self.builder.into()
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+                match self.builder.get_data_field::<u16>(4) {
+                    0 => ::core::result::Result::Ok(Unconstrained(self.builder.into())),
+                    1 => ::core::result::Result::Ok(Parameter(self.builder.into())),
+                    2 => ::core::result::Result::Ok(ImplicitMethodParameter(self.builder.into())),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 45] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(241, 73, 62, 162, 232, 63, 87, 194),
+                crate::word(18, 0, 0, 0, 1, 0, 3, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(1, 0, 7, 0, 1, 0, 3, 0),
+                crate::word(4, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 234, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(25, 0, 0, 0, 175, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                crate::word(101, 46, 97, 110, 121, 80, 111, 105),
+                crate::word(110, 116, 101, 114, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 255, 255, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(86, 54, 89, 254, 121, 95, 59, 142),
+                crate::word(69, 0, 0, 0, 114, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(1, 0, 254, 255, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(133, 74, 97, 244, 36, 247, 209, 157),
+                crate::word(49, 0, 0, 0, 82, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(2, 0, 253, 255, 0, 0, 0, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 226, 86, 12, 18, 201, 239, 186),
+                crate::word(29, 0, 0, 0, 194, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(117, 110, 99, 111, 110, 115, 116, 114),
+                crate::word(97, 105, 110, 101, 100, 0, 0, 0),
+                crate::word(112, 97, 114, 97, 109, 101, 116, 101),
+                crate::word(114, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 109, 112, 108, 105, 99, 105, 116),
+                crate::word(77, 101, 116, 104, 111, 100, 80, 97),
+                crate::word(114, 97, 109, 101, 116, 101, 114, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <crate::schema_capnp::type_::any_pointer::unconstrained::Owned as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::type_::any_pointer::parameter::Owned as crate::introspect::Introspect>::introspect(),
+          2 => <crate::schema_capnp::type_::any_pointer::implicit_method_parameter::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[0, 1, 2];
+            pub const TYPE_ID: u64 = 0xc257_3fe8_a23e_49f1;
+        }
+        pub enum Which<A0, A1, A2> {
+            Unconstrained(A0),
+            Parameter(A1),
+            ImplicitMethodParameter(A2),
+        }
+        pub type WhichReader<'a> = Which<
+            crate::schema_capnp::type_::any_pointer::unconstrained::Reader<'a>,
+            crate::schema_capnp::type_::any_pointer::parameter::Reader<'a>,
+            crate::schema_capnp::type_::any_pointer::implicit_method_parameter::Reader<'a>,
+        >;
+        pub type WhichBuilder<'a> = Which<
+            crate::schema_capnp::type_::any_pointer::unconstrained::Builder<'a>,
+            crate::schema_capnp::type_::any_pointer::parameter::Builder<'a>,
+            crate::schema_capnp::type_::any_pointer::implicit_method_parameter::Builder<'a>,
+        >;
+
+        pub mod unconstrained {
+            pub use self::Which::{AnyKind, Capability, List, Struct};
+
+            #[derive(Copy, Clone)]
+            pub struct Owned(());
+            impl crate::introspect::Introspect for Owned {
+                fn introspect() -> crate::introspect::Type {
+                    crate::introspect::TypeVariant::Struct(
+                        crate::introspect::RawBrandedStructSchema {
+                            generic: &_private::RAW_SCHEMA,
+                            field_types: _private::get_field_types,
+                            annotation_types: _private::get_annotation_types,
+                        },
+                    )
+                    .into()
+                }
+            }
+            impl crate::traits::Owned for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::OwnedStruct for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::Pipelined for Owned {
+                type Pipeline = Pipeline;
+            }
+
+            pub struct Reader<'a> {
+                reader: crate::private::layout::StructReader<'a>,
+            }
+            impl<'a> ::core::marker::Copy for Reader<'a> {}
+            impl<'a> ::core::clone::Clone for Reader<'a> {
+                fn clone(&self) -> Self {
+                    *self
+                }
+            }
+
+            impl<'a> crate::traits::HasTypeId for Reader<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+                fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                    Self { reader }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+                fn from(reader: Reader<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Reader::new(
+                        reader.reader,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> ::core::fmt::Debug for Reader<'a> {
+                fn fmt(
+                    &self,
+                    f: &mut ::core::fmt::Formatter<'_>,
+                ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                    core::fmt::Debug::fmt(
+                        &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                        f,
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+                fn get_from_pointer(
+                    reader: &crate::private::layout::PointerReader<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(reader.get_struct(default)?.into())
+                }
+            }
+
+            impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+                fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                    self.reader
+                }
+            }
+
+            impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+                fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                    self.reader
+                        .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+                }
+            }
+
+            impl<'a> Reader<'a> {
+                pub fn reborrow(&self) -> Reader<'_> {
+                    Self { ..*self }
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.reader.total_size()
+                }
+                #[inline]
+                pub fn which(self) -> ::core::result::Result<WhichReader, crate::NotInSchema> {
+                    match self.reader.get_data_field::<u16>(5) {
+                        0 => ::core::result::Result::Ok(AnyKind(())),
+                        1 => ::core::result::Result::Ok(Struct(())),
+                        2 => ::core::result::Result::Ok(List(())),
+                        3 => ::core::result::Result::Ok(Capability(())),
+                        x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                    }
+                }
+            }
+
+            pub struct Builder<'a> {
+                builder: crate::private::layout::StructBuilder<'a>,
+            }
+            impl<'a> crate::traits::HasStructSize for Builder<'a> {
+                const STRUCT_SIZE: crate::private::layout::StructSize =
+                    crate::private::layout::StructSize {
+                        data: 3,
+                        pointers: 1,
+                    };
+            }
+            impl<'a> crate::traits::HasTypeId for Builder<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+                fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                    Self { builder }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+                fn from(builder: Builder<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Builder::new(
+                        builder.builder,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+                fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                    self.builder
+                        .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+                fn init_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    _size: u32,
+                ) -> Self {
+                    builder
+                        .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                        .into()
+                }
+                fn get_from_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(
+                        builder
+                            .get_struct(
+                                <Self as crate::traits::HasStructSize>::STRUCT_SIZE,
+                                default,
+                            )?
+                            .into(),
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+                fn set_pointer_builder(
+                    mut pointer: crate::private::layout::PointerBuilder<'_>,
+                    value: Self,
+                    canonicalize: bool,
+                ) -> crate::Result<()> {
+                    pointer.set_struct(&value.reader, canonicalize)
+                }
+            }
+
+            impl<'a> Builder<'a> {
+                pub fn into_reader(self) -> Reader<'a> {
+                    self.builder.into_reader().into()
+                }
+                pub fn reborrow(&mut self) -> Builder<'_> {
+                    Builder {
+                        builder: self.builder.reborrow(),
+                    }
+                }
+                pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                    self.builder.as_reader().into()
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.builder.as_reader().total_size()
+                }
+                #[inline]
+                pub fn set_any_kind(&mut self, _value: ()) {
+                    self.builder.set_data_field::<u16>(5, 0);
+                }
+                #[inline]
+                pub fn set_struct(&mut self, _value: ()) {
+                    self.builder.set_data_field::<u16>(5, 1);
+                }
+                #[inline]
+                pub fn set_list(&mut self, _value: ()) {
+                    self.builder.set_data_field::<u16>(5, 2);
+                }
+                #[inline]
+                pub fn set_capability(&mut self, _value: ()) {
+                    self.builder.set_data_field::<u16>(5, 3);
+                }
+                #[inline]
+                pub fn which(self) -> ::core::result::Result<WhichBuilder, crate::NotInSchema> {
+                    match self.builder.get_data_field::<u16>(5) {
+                        0 => ::core::result::Result::Ok(AnyKind(())),
+                        1 => ::core::result::Result::Ok(Struct(())),
+                        2 => ::core::result::Result::Ok(List(())),
+                        3 => ::core::result::Result::Ok(Capability(())),
+                        x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                    }
+                }
+            }
+
+            pub struct Pipeline {
+                _typeless: crate::any_pointer::Pipeline,
+            }
+            impl crate::capability::FromTypelessPipeline for Pipeline {
+                fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                    Self {
+                        _typeless: typeless,
+                    }
+                }
+            }
+            impl Pipeline {}
+            mod _private {
+                pub static ENCODED_NODE: [crate::Word; 80] = [
+                    crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                    crate::word(86, 54, 89, 254, 121, 95, 59, 142),
+                    crate::word(29, 0, 0, 0, 1, 0, 3, 0),
+                    crate::word(241, 73, 62, 162, 232, 63, 87, 194),
+                    crate::word(1, 0, 7, 0, 1, 0, 4, 0),
+                    crate::word(5, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(21, 0, 0, 0, 90, 1, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(33, 0, 0, 0, 231, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                    crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                    crate::word(101, 46, 97, 110, 121, 80, 111, 105),
+                    crate::word(110, 116, 101, 114, 46, 117, 110, 99),
+                    crate::word(111, 110, 115, 116, 114, 97, 105, 110),
+                    crate::word(101, 100, 0, 0, 0, 0, 0, 0),
+                    crate::word(16, 0, 0, 0, 3, 0, 4, 0),
+                    crate::word(0, 0, 255, 255, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 18, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(97, 0, 0, 0, 66, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(92, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(104, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(1, 0, 254, 255, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 25, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(101, 0, 0, 0, 58, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(96, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(108, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(2, 0, 253, 255, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 26, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(105, 0, 0, 0, 42, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(100, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(112, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(3, 0, 252, 255, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 27, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(109, 0, 0, 0, 90, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(108, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(120, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(97, 110, 121, 75, 105, 110, 100, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(115, 116, 114, 117, 99, 116, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(108, 105, 115, 116, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(99, 97, 112, 97, 98, 105, 108, 105),
+                    crate::word(116, 121, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                ];
+                pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                    match index {
+                        0 => <() as crate::introspect::Introspect>::introspect(),
+                        1 => <() as crate::introspect::Introspect>::introspect(),
+                        2 => <() as crate::introspect::Introspect>::introspect(),
+                        3 => <() as crate::introspect::Introspect>::introspect(),
+                        _ => panic!("invalid field index {}", index),
+                    }
+                }
+                pub fn get_annotation_types(
+                    child_index: Option<u16>,
+                    index: u32,
+                ) -> crate::introspect::Type {
+                    panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+                }
+                pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                    crate::introspect::RawStructSchema {
+                        encoded_node: &ENCODED_NODE,
+                        nonunion_members: NONUNION_MEMBERS,
+                        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                    };
+                pub static NONUNION_MEMBERS: &[u16] = &[];
+                pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[0, 1, 2, 3];
+                pub const TYPE_ID: u64 = 0x8e3b_5f79_fe59_3656;
+            }
+            pub enum Which {
+                AnyKind(()),
+                Struct(()),
+                List(()),
+                Capability(()),
+            }
+            pub type WhichReader = Which;
+            pub type WhichBuilder = Which;
+        }
+
+        pub mod parameter {
+            #[derive(Copy, Clone)]
+            pub struct Owned(());
+            impl crate::introspect::Introspect for Owned {
+                fn introspect() -> crate::introspect::Type {
+                    crate::introspect::TypeVariant::Struct(
+                        crate::introspect::RawBrandedStructSchema {
+                            generic: &_private::RAW_SCHEMA,
+                            field_types: _private::get_field_types,
+                            annotation_types: _private::get_annotation_types,
+                        },
+                    )
+                    .into()
+                }
+            }
+            impl crate::traits::Owned for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::OwnedStruct for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::Pipelined for Owned {
+                type Pipeline = Pipeline;
+            }
+
+            pub struct Reader<'a> {
+                reader: crate::private::layout::StructReader<'a>,
+            }
+            impl<'a> ::core::marker::Copy for Reader<'a> {}
+            impl<'a> ::core::clone::Clone for Reader<'a> {
+                fn clone(&self) -> Self {
+                    *self
+                }
+            }
+
+            impl<'a> crate::traits::HasTypeId for Reader<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+                fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                    Self { reader }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+                fn from(reader: Reader<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Reader::new(
+                        reader.reader,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> ::core::fmt::Debug for Reader<'a> {
+                fn fmt(
+                    &self,
+                    f: &mut ::core::fmt::Formatter<'_>,
+                ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                    core::fmt::Debug::fmt(
+                        &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                        f,
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+                fn get_from_pointer(
+                    reader: &crate::private::layout::PointerReader<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(reader.get_struct(default)?.into())
+                }
+            }
+
+            impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+                fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                    self.reader
+                }
+            }
+
+            impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+                fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                    self.reader
+                        .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+                }
+            }
+
+            impl<'a> Reader<'a> {
+                pub fn reborrow(&self) -> Reader<'_> {
+                    Self { ..*self }
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.reader.total_size()
+                }
+                #[inline]
+                pub fn get_scope_id(self) -> u64 {
+                    self.reader.get_data_field::<u64>(2)
+                }
+                #[inline]
+                pub fn get_parameter_index(self) -> u16 {
+                    self.reader.get_data_field::<u16>(5)
+                }
+            }
+
+            pub struct Builder<'a> {
+                builder: crate::private::layout::StructBuilder<'a>,
+            }
+            impl<'a> crate::traits::HasStructSize for Builder<'a> {
+                const STRUCT_SIZE: crate::private::layout::StructSize =
+                    crate::private::layout::StructSize {
+                        data: 3,
+                        pointers: 1,
+                    };
+            }
+            impl<'a> crate::traits::HasTypeId for Builder<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+                fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                    Self { builder }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+                fn from(builder: Builder<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Builder::new(
+                        builder.builder,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+                fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                    self.builder
+                        .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+                fn init_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    _size: u32,
+                ) -> Self {
+                    builder
+                        .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                        .into()
+                }
+                fn get_from_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(
+                        builder
+                            .get_struct(
+                                <Self as crate::traits::HasStructSize>::STRUCT_SIZE,
+                                default,
+                            )?
+                            .into(),
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+                fn set_pointer_builder(
+                    mut pointer: crate::private::layout::PointerBuilder<'_>,
+                    value: Self,
+                    canonicalize: bool,
+                ) -> crate::Result<()> {
+                    pointer.set_struct(&value.reader, canonicalize)
+                }
+            }
+
+            impl<'a> Builder<'a> {
+                pub fn into_reader(self) -> Reader<'a> {
+                    self.builder.into_reader().into()
+                }
+                pub fn reborrow(&mut self) -> Builder<'_> {
+                    Builder {
+                        builder: self.builder.reborrow(),
+                    }
+                }
+                pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                    self.builder.as_reader().into()
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.builder.as_reader().total_size()
+                }
+                #[inline]
+                pub fn get_scope_id(self) -> u64 {
+                    self.builder.get_data_field::<u64>(2)
+                }
+                #[inline]
+                pub fn set_scope_id(&mut self, value: u64) {
+                    self.builder.set_data_field::<u64>(2, value);
+                }
+                #[inline]
+                pub fn get_parameter_index(self) -> u16 {
+                    self.builder.get_data_field::<u16>(5)
+                }
+                #[inline]
+                pub fn set_parameter_index(&mut self, value: u16) {
+                    self.builder.set_data_field::<u16>(5, value);
+                }
+            }
+
+            pub struct Pipeline {
+                _typeless: crate::any_pointer::Pipeline,
+            }
+            impl crate::capability::FromTypelessPipeline for Pipeline {
+                fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                    Self {
+                        _typeless: typeless,
+                    }
+                }
+            }
+            impl Pipeline {}
+            mod _private {
+                pub static ENCODED_NODE: [crate::Word; 49] = [
+                    crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                    crate::word(133, 74, 97, 244, 36, 247, 209, 157),
+                    crate::word(29, 0, 0, 0, 1, 0, 3, 0),
+                    crate::word(241, 73, 62, 162, 232, 63, 87, 194),
+                    crate::word(1, 0, 7, 0, 1, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(21, 0, 0, 0, 58, 1, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(29, 0, 0, 0, 119, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                    crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                    crate::word(101, 46, 97, 110, 121, 80, 111, 105),
+                    crate::word(110, 116, 101, 114, 46, 112, 97, 114),
+                    crate::word(97, 109, 101, 116, 101, 114, 0, 0),
+                    crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                    crate::word(0, 0, 0, 0, 2, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 19, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(41, 0, 0, 0, 66, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(1, 0, 0, 0, 5, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 20, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(45, 0, 0, 0, 122, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(44, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(56, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(115, 99, 111, 112, 101, 73, 100, 0),
+                    crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(112, 97, 114, 97, 109, 101, 116, 101),
+                    crate::word(114, 73, 110, 100, 101, 120, 0, 0),
+                    crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                ];
+                pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                    match index {
+                        0 => <u64 as crate::introspect::Introspect>::introspect(),
+                        1 => <u16 as crate::introspect::Introspect>::introspect(),
+                        _ => panic!("invalid field index {}", index),
+                    }
+                }
+                pub fn get_annotation_types(
+                    child_index: Option<u16>,
+                    index: u32,
+                ) -> crate::introspect::Type {
+                    panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+                }
+                pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                    crate::introspect::RawStructSchema {
+                        encoded_node: &ENCODED_NODE,
+                        nonunion_members: NONUNION_MEMBERS,
+                        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                    };
+                pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+                pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+                pub const TYPE_ID: u64 = 0x9dd1_f724_f461_4a85;
+            }
+        }
+
+        pub mod implicit_method_parameter {
+            #[derive(Copy, Clone)]
+            pub struct Owned(());
+            impl crate::introspect::Introspect for Owned {
+                fn introspect() -> crate::introspect::Type {
+                    crate::introspect::TypeVariant::Struct(
+                        crate::introspect::RawBrandedStructSchema {
+                            generic: &_private::RAW_SCHEMA,
+                            field_types: _private::get_field_types,
+                            annotation_types: _private::get_annotation_types,
+                        },
+                    )
+                    .into()
+                }
+            }
+            impl crate::traits::Owned for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::OwnedStruct for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::Pipelined for Owned {
+                type Pipeline = Pipeline;
+            }
+
+            pub struct Reader<'a> {
+                reader: crate::private::layout::StructReader<'a>,
+            }
+            impl<'a> ::core::marker::Copy for Reader<'a> {}
+            impl<'a> ::core::clone::Clone for Reader<'a> {
+                fn clone(&self) -> Self {
+                    *self
+                }
+            }
+
+            impl<'a> crate::traits::HasTypeId for Reader<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+                fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                    Self { reader }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+                fn from(reader: Reader<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Reader::new(
+                        reader.reader,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> ::core::fmt::Debug for Reader<'a> {
+                fn fmt(
+                    &self,
+                    f: &mut ::core::fmt::Formatter<'_>,
+                ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                    core::fmt::Debug::fmt(
+                        &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                        f,
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+                fn get_from_pointer(
+                    reader: &crate::private::layout::PointerReader<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(reader.get_struct(default)?.into())
+                }
+            }
+
+            impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+                fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                    self.reader
+                }
+            }
+
+            impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+                fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                    self.reader
+                        .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+                }
+            }
+
+            impl<'a> Reader<'a> {
+                pub fn reborrow(&self) -> Reader<'_> {
+                    Self { ..*self }
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.reader.total_size()
+                }
+                #[inline]
+                pub fn get_parameter_index(self) -> u16 {
+                    self.reader.get_data_field::<u16>(5)
+                }
+            }
+
+            pub struct Builder<'a> {
+                builder: crate::private::layout::StructBuilder<'a>,
+            }
+            impl<'a> crate::traits::HasStructSize for Builder<'a> {
+                const STRUCT_SIZE: crate::private::layout::StructSize =
+                    crate::private::layout::StructSize {
+                        data: 3,
+                        pointers: 1,
+                    };
+            }
+            impl<'a> crate::traits::HasTypeId for Builder<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+                fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                    Self { builder }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+                fn from(builder: Builder<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Builder::new(
+                        builder.builder,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+                fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                    self.builder
+                        .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+                fn init_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    _size: u32,
+                ) -> Self {
+                    builder
+                        .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                        .into()
+                }
+                fn get_from_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(
+                        builder
+                            .get_struct(
+                                <Self as crate::traits::HasStructSize>::STRUCT_SIZE,
+                                default,
+                            )?
+                            .into(),
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+                fn set_pointer_builder(
+                    mut pointer: crate::private::layout::PointerBuilder<'_>,
+                    value: Self,
+                    canonicalize: bool,
+                ) -> crate::Result<()> {
+                    pointer.set_struct(&value.reader, canonicalize)
+                }
+            }
+
+            impl<'a> Builder<'a> {
+                pub fn into_reader(self) -> Reader<'a> {
+                    self.builder.into_reader().into()
+                }
+                pub fn reborrow(&mut self) -> Builder<'_> {
+                    Builder {
+                        builder: self.builder.reborrow(),
+                    }
+                }
+                pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                    self.builder.as_reader().into()
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.builder.as_reader().total_size()
+                }
+                #[inline]
+                pub fn get_parameter_index(self) -> u16 {
+                    self.builder.get_data_field::<u16>(5)
+                }
+                #[inline]
+                pub fn set_parameter_index(&mut self, value: u16) {
+                    self.builder.set_data_field::<u16>(5, value);
+                }
+            }
+
+            pub struct Pipeline {
+                _typeless: crate::any_pointer::Pipeline,
+            }
+            impl crate::capability::FromTypelessPipeline for Pipeline {
+                fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                    Self {
+                        _typeless: typeless,
+                    }
+                }
+            }
+            impl Pipeline {}
+            mod _private {
+                pub static ENCODED_NODE: [crate::Word; 36] = [
+                    crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                    crate::word(116, 226, 86, 12, 18, 201, 239, 186),
+                    crate::word(29, 0, 0, 0, 1, 0, 3, 0),
+                    crate::word(241, 73, 62, 162, 232, 63, 87, 194),
+                    crate::word(1, 0, 7, 0, 1, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(21, 0, 0, 0, 170, 1, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(37, 0, 0, 0, 63, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                    crate::word(97, 112, 110, 112, 58, 84, 121, 112),
+                    crate::word(101, 46, 97, 110, 121, 80, 111, 105),
+                    crate::word(110, 116, 101, 114, 46, 105, 109, 112),
+                    crate::word(108, 105, 99, 105, 116, 77, 101, 116),
+                    crate::word(104, 111, 100, 80, 97, 114, 97, 109),
+                    crate::word(101, 116, 101, 114, 0, 0, 0, 0),
+                    crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+                    crate::word(0, 0, 0, 0, 5, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 24, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(13, 0, 0, 0, 122, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(12, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(24, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(112, 97, 114, 97, 109, 101, 116, 101),
+                    crate::word(114, 73, 110, 100, 101, 120, 0, 0),
+                    crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                ];
+                pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                    match index {
+                        0 => <u16 as crate::introspect::Introspect>::introspect(),
+                        _ => panic!("invalid field index {}", index),
+                    }
+                }
+                pub fn get_annotation_types(
+                    child_index: Option<u16>,
+                    index: u32,
+                ) -> crate::introspect::Type {
+                    panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+                }
+                pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                    crate::introspect::RawStructSchema {
+                        encoded_node: &ENCODED_NODE,
+                        nonunion_members: NONUNION_MEMBERS,
+                        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                    };
+                pub static NONUNION_MEMBERS: &[u16] = &[0];
+                pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+                pub const TYPE_ID: u64 = 0xbaef_c912_0c56_e274;
+            }
+        }
+    }
+}
+
+pub mod brand {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_scopes(
+            self,
+        ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::brand::scope::Owned>>
+        {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_scopes(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 0,
+                pointers: 1,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_scopes(
+            self,
+        ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::brand::scope::Owned>>
+        {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_scopes(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::brand::scope::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(0),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_scopes(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::brand::scope::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
+        }
+        #[inline]
+        pub fn has_scopes(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {}
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 42] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+            crate::word(13, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(1, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 154, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 39, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(49, 0, 0, 0, 63, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 66, 114, 97),
+            crate::word(110, 100, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(201, 107, 99, 169, 133, 52, 215, 171),
+            crate::word(9, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(252, 231, 158, 150, 22, 205, 99, 200),
+            crate::word(5, 0, 0, 0, 66, 0, 0, 0),
+            crate::word(83, 99, 111, 112, 101, 0, 0, 0),
+            crate::word(66, 105, 110, 100, 105, 110, 103, 0),
+            crate::word(4, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(13, 0, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(36, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(115, 99, 111, 112, 101, 115, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(201, 107, 99, 169, 133, 52, 215, 171),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <crate::struct_list::Owned<crate::schema_capnp::brand::scope::Owned> as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0x9034_55f0_6065_422b;
+    }
+
+    pub mod scope {
+        pub use self::Which::{Bind, Inherit};
+
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_scope_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn has_bind(&self) -> bool {
+                if self.reader.get_data_field::<u16>(4) != 0 {
+                    return false;
+                }
+                !self.reader.get_pointer_field(0).is_null()
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+                match self.reader.get_data_field::<u16>(4) {
+                    0 => ::core::result::Result::Ok(Bind(
+                        crate::traits::FromPointerReader::get_from_pointer(
+                            &self.reader.get_pointer_field(0),
+                            ::core::option::Option::None,
+                        ),
+                    )),
+                    1 => ::core::result::Result::Ok(Inherit(())),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 2,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_scope_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn set_scope_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(0, value);
+            }
+            #[inline]
+            pub fn set_bind(
+                &mut self,
+                value: crate::struct_list::Reader<'a, crate::schema_capnp::brand::binding::Owned>,
+            ) -> crate::Result<()> {
+                self.builder.set_data_field::<u16>(4, 0);
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(0),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_bind(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<'a, crate::schema_capnp::brand::binding::Owned>
+            {
+                self.builder.set_data_field::<u16>(4, 0);
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(0),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_bind(&self) -> bool {
+                if self.builder.get_data_field::<u16>(4) != 0 {
+                    return false;
+                }
+                !self.builder.is_pointer_field_null(0)
+            }
+            #[inline]
+            pub fn set_inherit(&mut self, _value: ()) {
+                self.builder.set_data_field::<u16>(4, 1);
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+                match self.builder.get_data_field::<u16>(4) {
+                    0 => ::core::result::Result::Ok(Bind(
+                        crate::traits::FromPointerBuilder::get_from_pointer(
+                            self.builder.get_pointer_field(0),
+                            ::core::option::Option::None,
+                        ),
+                    )),
+                    1 => ::core::result::Result::Ok(Inherit(())),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 67] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(201, 107, 99, 169, 133, 52, 215, 171),
+                crate::word(19, 0, 0, 0, 1, 0, 2, 0),
+                crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+                crate::word(1, 0, 7, 0, 0, 0, 2, 0),
+                crate::word(4, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 202, 0, 0, 0),
+                crate::word(33, 0, 0, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(29, 0, 0, 0, 175, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 66, 114, 97),
+                crate::word(110, 100, 46, 83, 99, 111, 112, 101),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(69, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(64, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(76, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 255, 255, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(73, 0, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(68, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(96, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(2, 0, 254, 255, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(93, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(88, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(100, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(115, 99, 111, 112, 101, 73, 100, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(98, 105, 110, 100, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(252, 231, 158, 150, 22, 205, 99, 200),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 110, 104, 101, 114, 105, 116, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <u64 as crate::introspect::Introspect>::introspect(),
+          1 => <crate::struct_list::Owned<crate::schema_capnp::brand::binding::Owned> as crate::introspect::Introspect>::introspect(),
+          2 => <() as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[1, 2];
+            pub const TYPE_ID: u64 = 0xabd7_3485_a963_6bc9;
+        }
+        pub enum Which<A0> {
+            Bind(A0),
+            Inherit(()),
+        }
+        pub type WhichReader<'a> = Which<
+            crate::Result<
+                crate::struct_list::Reader<'a, crate::schema_capnp::brand::binding::Owned>,
+            >,
+        >;
+        pub type WhichBuilder<'a> = Which<
+            crate::Result<
+                crate::struct_list::Builder<'a, crate::schema_capnp::brand::binding::Owned>,
+            >,
+        >;
+    }
+
+    pub mod binding {
+        pub use self::Which::{Type, Unbound};
+
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                if self.reader.get_data_field::<u16>(0) != 1 {
+                    return false;
+                }
+                !self.reader.get_pointer_field(0).is_null()
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+                match self.reader.get_data_field::<u16>(0) {
+                    0 => ::core::result::Result::Ok(Unbound(())),
+                    1 => ::core::result::Result::Ok(Type(
+                        crate::traits::FromPointerReader::get_from_pointer(
+                            &self.reader.get_pointer_field(0),
+                            ::core::option::Option::None,
+                        ),
+                    )),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 1,
+                    pointers: 1,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn set_unbound(&mut self, _value: ()) {
+                self.builder.set_data_field::<u16>(0, 0);
+            }
+            #[inline]
+            pub fn set_type(
+                &mut self,
+                value: crate::schema_capnp::type_::Reader<'_>,
+            ) -> crate::Result<()> {
+                self.builder.set_data_field::<u16>(0, 1);
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(0),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_type(self) -> crate::schema_capnp::type_::Builder<'a> {
+                self.builder.set_data_field::<u16>(0, 1);
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(0),
+                    0,
+                )
+            }
+            #[inline]
+            pub fn has_type(&self) -> bool {
+                if self.builder.get_data_field::<u16>(0) != 1 {
+                    return false;
+                }
+                !self.builder.is_pointer_field_null(0)
+            }
+            #[inline]
+            pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+                match self.builder.get_data_field::<u16>(0) {
+                    0 => ::core::result::Result::Ok(Unbound(())),
+                    1 => ::core::result::Result::Ok(Type(
+                        crate::traits::FromPointerBuilder::get_from_pointer(
+                            self.builder.get_pointer_field(0),
+                            ::core::option::Option::None,
+                        ),
+                    )),
+                    x => ::core::result::Result::Err(crate::NotInSchema(x)),
+                }
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 48] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(252, 231, 158, 150, 22, 205, 99, 200),
+                crate::word(19, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+                crate::word(1, 0, 7, 0, 0, 0, 2, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 218, 0, 0, 0),
+                crate::word(33, 0, 0, 0, 7, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(29, 0, 0, 0, 119, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 66, 114, 97),
+                crate::word(110, 100, 46, 66, 105, 110, 100, 105),
+                crate::word(110, 103, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 255, 255, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(41, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 254, 255, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(45, 0, 0, 0, 42, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(117, 110, 98, 111, 117, 110, 100, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(116, 121, 112, 101, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(96, 204, 249, 225, 237, 120, 115, 208),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+          0 => <() as crate::introspect::Introspect>::introspect(),
+          1 => <crate::schema_capnp::type_::Owned as crate::introspect::Introspect>::introspect(),
+          _ => panic!("invalid field index {}", index),
+        }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[0, 1];
+            pub const TYPE_ID: u64 = 0xc863_cd16_969e_e7fc;
+        }
+        pub enum Which<A0> {
+            Unbound(()),
+            Type(A0),
+        }
+        pub type WhichReader<'a> = Which<crate::Result<crate::schema_capnp::type_::Reader<'a>>>;
+        pub type WhichBuilder<'a> = Which<crate::Result<crate::schema_capnp::type_::Builder<'a>>>;
+    }
+}
+
+pub mod value {
+    pub use self::Which::{
+        AnyPointer, Bool, Data, Enum, Float32, Float64, Int16, Int32, Int64, Int8, Interface, List,
+        Struct, Text, Uint16, Uint32, Uint64, Uint8, Void,
+    };
+
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn has_text(&self) -> bool {
+            if self.reader.get_data_field::<u16>(0) != 12 {
+                return false;
+            }
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn has_data(&self) -> bool {
+            if self.reader.get_data_field::<u16>(0) != 13 {
+                return false;
+            }
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn has_list(&self) -> bool {
+            if self.reader.get_data_field::<u16>(0) != 14 {
+                return false;
+            }
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn has_struct(&self) -> bool {
+            if self.reader.get_data_field::<u16>(0) != 16 {
+                return false;
+            }
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn has_any_pointer(&self) -> bool {
+            if self.reader.get_data_field::<u16>(0) != 18 {
+                return false;
+            }
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichReader<'a>, crate::NotInSchema> {
+            match self.reader.get_data_field::<u16>(0) {
+                0 => ::core::result::Result::Ok(Void(())),
+                1 => ::core::result::Result::Ok(Bool(self.reader.get_bool_field(16))),
+                2 => ::core::result::Result::Ok(Int8(self.reader.get_data_field::<i8>(2))),
+                3 => ::core::result::Result::Ok(Int16(self.reader.get_data_field::<i16>(1))),
+                4 => ::core::result::Result::Ok(Int32(self.reader.get_data_field::<i32>(1))),
+                5 => ::core::result::Result::Ok(Int64(self.reader.get_data_field::<i64>(1))),
+                6 => ::core::result::Result::Ok(Uint8(self.reader.get_data_field::<u8>(2))),
+                7 => ::core::result::Result::Ok(Uint16(self.reader.get_data_field::<u16>(1))),
+                8 => ::core::result::Result::Ok(Uint32(self.reader.get_data_field::<u32>(1))),
+                9 => ::core::result::Result::Ok(Uint64(self.reader.get_data_field::<u64>(1))),
+                10 => ::core::result::Result::Ok(Float32(self.reader.get_data_field::<f32>(1))),
+                11 => ::core::result::Result::Ok(Float64(self.reader.get_data_field::<f64>(1))),
+                12 => ::core::result::Result::Ok(Text(
+                    crate::traits::FromPointerReader::get_from_pointer(
+                        &self.reader.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    ),
+                )),
+                13 => ::core::result::Result::Ok(Data(
+                    crate::traits::FromPointerReader::get_from_pointer(
+                        &self.reader.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    ),
+                )),
+                14 => ::core::result::Result::Ok(List(crate::any_pointer::Reader::new(
+                    self.reader.get_pointer_field(0),
+                ))),
+                15 => ::core::result::Result::Ok(Enum(self.reader.get_data_field::<u16>(1))),
+                16 => ::core::result::Result::Ok(Struct(crate::any_pointer::Reader::new(
+                    self.reader.get_pointer_field(0),
+                ))),
+                17 => ::core::result::Result::Ok(Interface(())),
+                18 => ::core::result::Result::Ok(AnyPointer(crate::any_pointer::Reader::new(
+                    self.reader.get_pointer_field(0),
+                ))),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 2,
+                pointers: 1,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn set_void(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 0);
+        }
+        #[inline]
+        pub fn set_bool(&mut self, value: bool) {
+            self.builder.set_data_field::<u16>(0, 1);
+            self.builder.set_bool_field(16, value);
+        }
+        #[inline]
+        pub fn set_int8(&mut self, value: i8) {
+            self.builder.set_data_field::<u16>(0, 2);
+            self.builder.set_data_field::<i8>(2, value);
+        }
+        #[inline]
+        pub fn set_int16(&mut self, value: i16) {
+            self.builder.set_data_field::<u16>(0, 3);
+            self.builder.set_data_field::<i16>(1, value);
+        }
+        #[inline]
+        pub fn set_int32(&mut self, value: i32) {
+            self.builder.set_data_field::<u16>(0, 4);
+            self.builder.set_data_field::<i32>(1, value);
+        }
+        #[inline]
+        pub fn set_int64(&mut self, value: i64) {
+            self.builder.set_data_field::<u16>(0, 5);
+            self.builder.set_data_field::<i64>(1, value);
+        }
+        #[inline]
+        pub fn set_uint8(&mut self, value: u8) {
+            self.builder.set_data_field::<u16>(0, 6);
+            self.builder.set_data_field::<u8>(2, value);
+        }
+        #[inline]
+        pub fn set_uint16(&mut self, value: u16) {
+            self.builder.set_data_field::<u16>(0, 7);
+            self.builder.set_data_field::<u16>(1, value);
+        }
+        #[inline]
+        pub fn set_uint32(&mut self, value: u32) {
+            self.builder.set_data_field::<u16>(0, 8);
+            self.builder.set_data_field::<u32>(1, value);
+        }
+        #[inline]
+        pub fn set_uint64(&mut self, value: u64) {
+            self.builder.set_data_field::<u16>(0, 9);
+            self.builder.set_data_field::<u64>(1, value);
+        }
+        #[inline]
+        pub fn set_float32(&mut self, value: f32) {
+            self.builder.set_data_field::<u16>(0, 10);
+            self.builder.set_data_field::<f32>(1, value);
+        }
+        #[inline]
+        pub fn set_float64(&mut self, value: f64) {
+            self.builder.set_data_field::<u16>(0, 11);
+            self.builder.set_data_field::<f64>(1, value);
+        }
+        #[inline]
+        pub fn set_text(&mut self, value: crate::text::Reader<'_>) {
+            self.builder.set_data_field::<u16>(0, 12);
+            self.builder.reborrow().get_pointer_field(0).set_text(value);
+        }
+        #[inline]
+        pub fn init_text(self, size: u32) -> crate::text::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 12);
+            self.builder.get_pointer_field(0).init_text(size)
+        }
+        #[inline]
+        pub fn has_text(&self) -> bool {
+            if self.builder.get_data_field::<u16>(0) != 12 {
+                return false;
+            }
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn set_data(&mut self, value: crate::data::Reader<'_>) {
+            self.builder.set_data_field::<u16>(0, 13);
+            self.builder.reborrow().get_pointer_field(0).set_data(value);
+        }
+        #[inline]
+        pub fn init_data(self, size: u32) -> crate::data::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 13);
+            self.builder.get_pointer_field(0).init_data(size)
+        }
+        #[inline]
+        pub fn has_data(&self) -> bool {
+            if self.builder.get_data_field::<u16>(0) != 13 {
+                return false;
+            }
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn init_list(self) -> crate::any_pointer::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 14);
+            let mut result = crate::any_pointer::Builder::new(self.builder.get_pointer_field(0));
+            result.clear();
+            result
+        }
+        #[inline]
+        pub fn has_list(&self) -> bool {
+            if self.builder.get_data_field::<u16>(0) != 14 {
+                return false;
+            }
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn set_enum(&mut self, value: u16) {
+            self.builder.set_data_field::<u16>(0, 15);
+            self.builder.set_data_field::<u16>(1, value);
+        }
+        #[inline]
+        pub fn init_struct(self) -> crate::any_pointer::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 16);
+            let mut result = crate::any_pointer::Builder::new(self.builder.get_pointer_field(0));
+            result.clear();
+            result
+        }
+        #[inline]
+        pub fn has_struct(&self) -> bool {
+            if self.builder.get_data_field::<u16>(0) != 16 {
+                return false;
+            }
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn set_interface(&mut self, _value: ()) {
+            self.builder.set_data_field::<u16>(0, 17);
+        }
+        #[inline]
+        pub fn init_any_pointer(self) -> crate::any_pointer::Builder<'a> {
+            self.builder.set_data_field::<u16>(0, 18);
+            let mut result = crate::any_pointer::Builder::new(self.builder.get_pointer_field(0));
+            result.clear();
+            result
+        }
+        #[inline]
+        pub fn has_any_pointer(&self) -> bool {
+            if self.builder.get_data_field::<u16>(0) != 18 {
+                return false;
+            }
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn which(self) -> ::core::result::Result<WhichBuilder<'a>, crate::NotInSchema> {
+            match self.builder.get_data_field::<u16>(0) {
+                0 => ::core::result::Result::Ok(Void(())),
+                1 => ::core::result::Result::Ok(Bool(self.builder.get_bool_field(16))),
+                2 => ::core::result::Result::Ok(Int8(self.builder.get_data_field::<i8>(2))),
+                3 => ::core::result::Result::Ok(Int16(self.builder.get_data_field::<i16>(1))),
+                4 => ::core::result::Result::Ok(Int32(self.builder.get_data_field::<i32>(1))),
+                5 => ::core::result::Result::Ok(Int64(self.builder.get_data_field::<i64>(1))),
+                6 => ::core::result::Result::Ok(Uint8(self.builder.get_data_field::<u8>(2))),
+                7 => ::core::result::Result::Ok(Uint16(self.builder.get_data_field::<u16>(1))),
+                8 => ::core::result::Result::Ok(Uint32(self.builder.get_data_field::<u32>(1))),
+                9 => ::core::result::Result::Ok(Uint64(self.builder.get_data_field::<u64>(1))),
+                10 => ::core::result::Result::Ok(Float32(self.builder.get_data_field::<f32>(1))),
+                11 => ::core::result::Result::Ok(Float64(self.builder.get_data_field::<f64>(1))),
+                12 => ::core::result::Result::Ok(Text(
+                    crate::traits::FromPointerBuilder::get_from_pointer(
+                        self.builder.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    ),
+                )),
+                13 => ::core::result::Result::Ok(Data(
+                    crate::traits::FromPointerBuilder::get_from_pointer(
+                        self.builder.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    ),
+                )),
+                14 => ::core::result::Result::Ok(List(crate::any_pointer::Builder::new(
+                    self.builder.get_pointer_field(0),
+                ))),
+                15 => ::core::result::Result::Ok(Enum(self.builder.get_data_field::<u16>(1))),
+                16 => ::core::result::Result::Ok(Struct(crate::any_pointer::Builder::new(
+                    self.builder.get_pointer_field(0),
+                ))),
+                17 => ::core::result::Result::Ok(Interface(())),
+                18 => ::core::result::Result::Ok(AnyPointer(crate::any_pointer::Builder::new(
+                    self.builder.get_pointer_field(0),
+                ))),
+                x => ::core::result::Result::Err(crate::NotInSchema(x)),
+            }
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {}
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 304] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(155, 12, 176, 215, 210, 220, 35, 206),
+            crate::word(13, 0, 0, 0, 1, 0, 2, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(1, 0, 7, 0, 0, 0, 19, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 154, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 0, 0, 0, 47, 4, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 86, 97, 108),
+            crate::word(117, 101, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(76, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 255, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(5, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(12, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 254, 255, 16, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(4, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 253, 255, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(13, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(20, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(3, 0, 252, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(17, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(24, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(4, 0, 251, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 4, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(28, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(5, 0, 250, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 5, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(20, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(32, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(6, 0, 249, 255, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 6, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(29, 2, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(24, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(36, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(7, 0, 248, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(33, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(28, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(40, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(8, 0, 247, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 8, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(37, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(32, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(44, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(9, 0, 246, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 9, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(41, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(36, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(48, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(10, 0, 245, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 10, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(45, 2, 0, 0, 66, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(40, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(52, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(11, 0, 244, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 11, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(49, 2, 0, 0, 66, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(44, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(56, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(12, 0, 243, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 12, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(53, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(48, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(60, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(13, 0, 242, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 13, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(57, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(52, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(64, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(14, 0, 241, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 14, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(61, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(56, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(68, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(15, 0, 240, 255, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 15, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(65, 2, 0, 0, 42, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(60, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(72, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(16, 0, 239, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 16, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(69, 2, 0, 0, 58, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(64, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(76, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(17, 0, 238, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 17, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(73, 2, 0, 0, 82, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(72, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(84, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(18, 0, 237, 255, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 18, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(81, 2, 0, 0, 90, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(80, 2, 0, 0, 3, 0, 1, 0),
+            crate::word(92, 2, 0, 0, 2, 0, 1, 0),
+            crate::word(118, 111, 105, 100, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(98, 111, 111, 108, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 56, 0, 0, 0, 0),
+            crate::word(2, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(2, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 49, 54, 0, 0, 0),
+            crate::word(3, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(3, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 51, 50, 0, 0, 0),
+            crate::word(4, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(4, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 54, 52, 0, 0, 0),
+            crate::word(5, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(5, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 56, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 49, 54, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 51, 50, 0, 0),
+            crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(8, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 105, 110, 116, 54, 52, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(102, 108, 111, 97, 116, 51, 50, 0),
+            crate::word(10, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(10, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(102, 108, 111, 97, 116, 54, 52, 0),
+            crate::word(11, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(11, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(116, 101, 120, 116, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(100, 97, 116, 97, 0, 0, 0, 0),
+            crate::word(13, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(13, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(108, 105, 115, 116, 0, 0, 0, 0),
+            crate::word(18, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(18, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(101, 110, 117, 109, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 116, 114, 117, 99, 116, 0, 0),
+            crate::word(18, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(18, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(105, 110, 116, 101, 114, 102, 97, 99),
+            crate::word(101, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 110, 121, 80, 111, 105, 110, 116),
+            crate::word(101, 114, 0, 0, 0, 0, 0, 0),
+            crate::word(18, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(18, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+                0 => <() as crate::introspect::Introspect>::introspect(),
+                1 => <bool as crate::introspect::Introspect>::introspect(),
+                2 => <i8 as crate::introspect::Introspect>::introspect(),
+                3 => <i16 as crate::introspect::Introspect>::introspect(),
+                4 => <i32 as crate::introspect::Introspect>::introspect(),
+                5 => <i64 as crate::introspect::Introspect>::introspect(),
+                6 => <u8 as crate::introspect::Introspect>::introspect(),
+                7 => <u16 as crate::introspect::Introspect>::introspect(),
+                8 => <u32 as crate::introspect::Introspect>::introspect(),
+                9 => <u64 as crate::introspect::Introspect>::introspect(),
+                10 => <f32 as crate::introspect::Introspect>::introspect(),
+                11 => <f64 as crate::introspect::Introspect>::introspect(),
+                12 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                13 => <crate::data::Owned as crate::introspect::Introspect>::introspect(),
+                14 => <crate::any_pointer::Owned as crate::introspect::Introspect>::introspect(),
+                15 => <u16 as crate::introspect::Introspect>::introspect(),
+                16 => <crate::any_pointer::Owned as crate::introspect::Introspect>::introspect(),
+                17 => <() as crate::introspect::Introspect>::introspect(),
+                18 => <crate::any_pointer::Owned as crate::introspect::Introspect>::introspect(),
+                _ => panic!("invalid field index {}", index),
+            }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
+        ];
+        pub const TYPE_ID: u64 = 0xce23_dcd2_d7b0_0c9b;
+    }
+    pub enum Which<A0, A1, A2, A3, A4> {
+        Void(()),
+        Bool(bool),
+        Int8(i8),
+        Int16(i16),
+        Int32(i32),
+        Int64(i64),
+        Uint8(u8),
+        Uint16(u16),
+        Uint32(u32),
+        Uint64(u64),
+        Float32(f32),
+        Float64(f64),
+        Text(A0),
+        Data(A1),
+        List(A2),
+        Enum(u16),
+        Struct(A3),
+        Interface(()),
+        AnyPointer(A4),
+    }
+    pub type WhichReader<'a> = Which<
+        crate::Result<crate::text::Reader<'a>>,
+        crate::Result<crate::data::Reader<'a>>,
+        crate::any_pointer::Reader<'a>,
+        crate::any_pointer::Reader<'a>,
+        crate::any_pointer::Reader<'a>,
+    >;
+    pub type WhichBuilder<'a> = Which<
+        crate::Result<crate::text::Builder<'a>>,
+        crate::Result<crate::data::Builder<'a>>,
+        crate::any_pointer::Builder<'a>,
+        crate::any_pointer::Builder<'a>,
+        crate::any_pointer::Builder<'a>,
+    >;
+}
+
+pub mod annotation {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_id(self) -> u64 {
+            self.reader.get_data_field::<u64>(0)
+        }
+        #[inline]
+        pub fn get_value(self) -> crate::Result<crate::schema_capnp::value::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_value(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_brand(&self) -> bool {
+            !self.reader.get_pointer_field(1).is_null()
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 1,
+                pointers: 2,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_id(self) -> u64 {
+            self.builder.get_data_field::<u64>(0)
+        }
+        #[inline]
+        pub fn set_id(&mut self, value: u64) {
+            self.builder.set_data_field::<u64>(0, value);
+        }
+        #[inline]
+        pub fn get_value(self) -> crate::Result<crate::schema_capnp::value::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_value(
+            &mut self,
+            value: crate::schema_capnp::value::Reader<'_>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(0),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_value(self) -> crate::schema_capnp::value::Builder<'a> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
+        }
+        #[inline]
+        pub fn has_value(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn get_brand(self) -> crate::Result<crate::schema_capnp::brand::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_brand(
+            &mut self,
+            value: crate::schema_capnp::brand::Reader<'_>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(1),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_brand(self) -> crate::schema_capnp::brand::Builder<'a> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), 0)
+        }
+        #[inline]
+        pub fn has_brand(&self) -> bool {
+            !self.builder.is_pointer_field_null(1)
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {
+        pub fn get_value(&self) -> crate::schema_capnp::value::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
+        }
+        pub fn get_brand(&self) -> crate::schema_capnp::brand::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(1))
+        }
+    }
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 62] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(66, 117, 37, 171, 13, 149, 200, 241),
+            crate::word(13, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(2, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 194, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(25, 0, 0, 0, 175, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 65, 110, 110),
+            crate::word(111, 116, 97, 116, 105, 111, 110, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(69, 0, 0, 0, 26, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(64, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(76, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(73, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(68, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(80, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(77, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(72, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(84, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(118, 97, 108, 117, 101, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(155, 12, 176, 215, 210, 220, 35, 206),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(98, 114, 97, 110, 100, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(43, 66, 101, 96, 240, 85, 52, 144),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+                0 => <u64 as crate::introspect::Introspect>::introspect(),
+                1 => {
+                    <crate::schema_capnp::value::Owned as crate::introspect::Introspect>::introspect(
+                    )
+                }
+                2 => {
+                    <crate::schema_capnp::brand::Owned as crate::introspect::Introspect>::introspect(
+                    )
+                }
+                _ => panic!("invalid field index {}", index),
+            }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0xf1c8_950d_ab25_7542;
+    }
+}
+
+#[repr(u16)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub enum ElementSize {
+    Empty = 0,
+    Bit = 1,
+    Byte = 2,
+    TwoBytes = 3,
+    FourBytes = 4,
+    EightBytes = 5,
+    Pointer = 6,
+    InlineComposite = 7,
+}
+
+impl crate::introspect::Introspect for ElementSize {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::TypeVariant::Enum(crate::introspect::RawEnumSchema {
+            encoded_node: &element_size::ENCODED_NODE,
+            annotation_types: element_size::get_annotation_types,
+        })
+        .into()
+    }
+}
+impl<'a> ::core::convert::From<ElementSize> for crate::dynamic_value::Reader<'a> {
+    fn from(e: ElementSize) -> Self {
+        crate::dynamic_value::Enum::new(
+            e.into(),
+            crate::introspect::RawEnumSchema {
+                encoded_node: &element_size::ENCODED_NODE,
+                annotation_types: element_size::get_annotation_types,
+            }
+            .into(),
+        )
+        .into()
+    }
+}
+impl ::core::convert::TryFrom<u16> for ElementSize {
+    type Error = crate::NotInSchema;
+    fn try_from(
+        value: u16,
+    ) -> ::core::result::Result<Self, <ElementSize as ::core::convert::TryFrom<u16>>::Error> {
+        match value {
+            0 => ::core::result::Result::Ok(Self::Empty),
+            1 => ::core::result::Result::Ok(Self::Bit),
+            2 => ::core::result::Result::Ok(Self::Byte),
+            3 => ::core::result::Result::Ok(Self::TwoBytes),
+            4 => ::core::result::Result::Ok(Self::FourBytes),
+            5 => ::core::result::Result::Ok(Self::EightBytes),
+            6 => ::core::result::Result::Ok(Self::Pointer),
+            7 => ::core::result::Result::Ok(Self::InlineComposite),
+            n => ::core::result::Result::Err(crate::NotInSchema(n)),
+        }
+    }
+}
+impl From<ElementSize> for u16 {
+    #[inline]
+    fn from(x: ElementSize) -> u16 {
+        x as u16
+    }
+}
+impl crate::traits::HasTypeId for ElementSize {
+    const TYPE_ID: u64 = 0xd195_8f7d_ba52_1926u64;
+}
+mod element_size {
+    pub static ENCODED_NODE: [crate::Word; 54] = [
+        crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+        crate::word(38, 25, 82, 186, 125, 143, 149, 209),
+        crate::word(13, 0, 0, 0, 2, 0, 0, 0),
+        crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(21, 0, 0, 0, 202, 0, 0, 0),
+        crate::word(33, 0, 0, 0, 7, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(29, 0, 0, 0, 199, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+        crate::word(97, 112, 110, 112, 58, 69, 108, 101),
+        crate::word(109, 101, 110, 116, 83, 105, 122, 101),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+        crate::word(32, 0, 0, 0, 1, 0, 2, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(89, 0, 0, 0, 50, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(81, 0, 0, 0, 34, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(2, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(73, 0, 0, 0, 42, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(3, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(65, 0, 0, 0, 74, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(4, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(61, 0, 0, 0, 82, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(5, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(57, 0, 0, 0, 90, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(53, 0, 0, 0, 66, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(45, 0, 0, 0, 130, 0, 0, 0),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(101, 109, 112, 116, 121, 0, 0, 0),
+        crate::word(98, 105, 116, 0, 0, 0, 0, 0),
+        crate::word(98, 121, 116, 101, 0, 0, 0, 0),
+        crate::word(116, 119, 111, 66, 121, 116, 101, 115),
+        crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(102, 111, 117, 114, 66, 121, 116, 101),
+        crate::word(115, 0, 0, 0, 0, 0, 0, 0),
+        crate::word(101, 105, 103, 104, 116, 66, 121, 116),
+        crate::word(101, 115, 0, 0, 0, 0, 0, 0),
+        crate::word(112, 111, 105, 110, 116, 101, 114, 0),
+        crate::word(105, 110, 108, 105, 110, 101, 67, 111),
+        crate::word(109, 112, 111, 115, 105, 116, 101, 0),
+    ];
+    pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> crate::introspect::Type {
+        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+    }
+}
+
+pub mod capnp_version {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_major(self) -> u16 {
+            self.reader.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn get_minor(self) -> u8 {
+            self.reader.get_data_field::<u8>(2)
+        }
+        #[inline]
+        pub fn get_micro(self) -> u8 {
+            self.reader.get_data_field::<u8>(3)
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 1,
+                pointers: 0,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_major(self) -> u16 {
+            self.builder.get_data_field::<u16>(0)
+        }
+        #[inline]
+        pub fn set_major(&mut self, value: u16) {
+            self.builder.set_data_field::<u16>(0, value);
+        }
+        #[inline]
+        pub fn get_minor(self) -> u8 {
+            self.builder.get_data_field::<u8>(2)
+        }
+        #[inline]
+        pub fn set_minor(&mut self, value: u8) {
+            self.builder.set_data_field::<u8>(2, value);
+        }
+        #[inline]
+        pub fn get_micro(self) -> u8 {
+            self.builder.get_data_field::<u8>(3)
+        }
+        #[inline]
+        pub fn set_micro(&mut self, value: u8) {
+            self.builder.set_data_field::<u8>(3, value);
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {}
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 63] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(99, 153, 131, 125, 91, 48, 93, 216),
+            crate::word(13, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(0, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 210, 0, 0, 0),
+            crate::word(33, 0, 0, 0, 7, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(29, 0, 0, 0, 175, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 67, 97, 112),
+            crate::word(110, 112, 86, 101, 114, 115, 105, 111),
+            crate::word(110, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(69, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(64, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(76, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(1, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(73, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(68, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(80, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(77, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(72, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(84, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(109, 97, 106, 111, 114, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(7, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(109, 105, 110, 111, 114, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(109, 105, 99, 114, 111, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(6, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+                0 => <u16 as crate::introspect::Introspect>::introspect(),
+                1 => <u8 as crate::introspect::Introspect>::introspect(),
+                2 => <u8 as crate::introspect::Introspect>::introspect(),
+                _ => panic!("invalid field index {}", index),
+            }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0xd85d_305b_7d83_9963;
+    }
+}
+
+pub mod code_generator_request {
+    #[derive(Copy, Clone)]
+    pub struct Owned(());
+    impl crate::introspect::Introspect for Owned {
+        fn introspect() -> crate::introspect::Type {
+            crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                generic: &_private::RAW_SCHEMA,
+                field_types: _private::get_field_types,
+                annotation_types: _private::get_annotation_types,
+            })
+            .into()
+        }
+    }
+    impl crate::traits::Owned for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::OwnedStruct for Owned {
+        type Reader<'a> = Reader<'a>;
+        type Builder<'a> = Builder<'a>;
+    }
+    impl crate::traits::Pipelined for Owned {
+        type Pipeline = Pipeline;
+    }
+
+    pub struct Reader<'a> {
+        reader: crate::private::layout::StructReader<'a>,
+    }
+    impl<'a> ::core::marker::Copy for Reader<'a> {}
+    impl<'a> ::core::clone::Clone for Reader<'a> {
+        fn clone(&self) -> Self {
+            *self
+        }
+    }
+
+    impl<'a> crate::traits::HasTypeId for Reader<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+        fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+            Self { reader }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+        fn from(reader: Reader<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Reader::new(
+                reader.reader,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> ::core::fmt::Debug for Reader<'a> {
+        fn fmt(
+            &self,
+            f: &mut ::core::fmt::Formatter<'_>,
+        ) -> ::core::result::Result<(), ::core::fmt::Error> {
+            core::fmt::Debug::fmt(
+                &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                f,
+            )
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+        fn get_from_pointer(
+            reader: &crate::private::layout::PointerReader<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(reader.get_struct(default)?.into())
+        }
+    }
+
+    impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+        fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+            self.reader
+        }
+    }
+
+    impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+        fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+            self.reader
+                .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+        }
+    }
+
+    impl<'a> Reader<'a> {
+        pub fn reborrow(&self) -> Reader<'_> {
+            Self { ..*self }
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.reader.total_size()
+        }
+        #[inline]
+        pub fn get_nodes(
+            self,
+        ) -> crate::Result<crate::struct_list::Reader<'a, crate::schema_capnp::node::Owned>>
+        {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_nodes(&self) -> bool {
+            !self.reader.get_pointer_field(0).is_null()
+        }
+        #[inline]
+        pub fn get_requested_files(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Reader<
+                'a,
+                crate::schema_capnp::code_generator_request::requested_file::Owned,
+            >,
+        > {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_requested_files(&self) -> bool {
+            !self.reader.get_pointer_field(1).is_null()
+        }
+        #[inline]
+        pub fn get_capnp_version(
+            self,
+        ) -> crate::Result<crate::schema_capnp::capnp_version::Reader<'a>> {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(2),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_capnp_version(&self) -> bool {
+            !self.reader.get_pointer_field(2).is_null()
+        }
+        #[inline]
+        pub fn get_source_info(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Reader<'a, crate::schema_capnp::node::source_info::Owned>,
+        > {
+            crate::traits::FromPointerReader::get_from_pointer(
+                &self.reader.get_pointer_field(3),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn has_source_info(&self) -> bool {
+            !self.reader.get_pointer_field(3).is_null()
+        }
+    }
+
+    pub struct Builder<'a> {
+        builder: crate::private::layout::StructBuilder<'a>,
+    }
+    impl<'a> crate::traits::HasStructSize for Builder<'a> {
+        const STRUCT_SIZE: crate::private::layout::StructSize =
+            crate::private::layout::StructSize {
+                data: 0,
+                pointers: 4,
+            };
+    }
+    impl<'a> crate::traits::HasTypeId for Builder<'a> {
+        const TYPE_ID: u64 = _private::TYPE_ID;
+    }
+    impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+        fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+            Self { builder }
+        }
+    }
+
+    impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+        fn from(builder: Builder<'a>) -> Self {
+            Self::Struct(crate::dynamic_struct::Builder::new(
+                builder.builder,
+                crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                }),
+            ))
+        }
+    }
+
+    impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+        fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+            self.builder
+                .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+        }
+    }
+
+    impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+        fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
+            builder
+                .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                .into()
+        }
+        fn get_from_pointer(
+            builder: crate::private::layout::PointerBuilder<'a>,
+            default: ::core::option::Option<&'a [crate::Word]>,
+        ) -> crate::Result<Self> {
+            ::core::result::Result::Ok(
+                builder
+                    .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                    .into(),
+            )
+        }
+    }
+
+    impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+        fn set_pointer_builder(
+            mut pointer: crate::private::layout::PointerBuilder<'_>,
+            value: Self,
+            canonicalize: bool,
+        ) -> crate::Result<()> {
+            pointer.set_struct(&value.reader, canonicalize)
+        }
+    }
+
+    impl<'a> Builder<'a> {
+        pub fn into_reader(self) -> Reader<'a> {
+            self.builder.into_reader().into()
+        }
+        pub fn reborrow(&mut self) -> Builder<'_> {
+            Builder {
+                builder: self.builder.reborrow(),
+            }
+        }
+        pub fn reborrow_as_reader(&self) -> Reader<'_> {
+            self.builder.as_reader().into()
+        }
+
+        pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+            self.builder.as_reader().total_size()
+        }
+        #[inline]
+        pub fn get_nodes(
+            self,
+        ) -> crate::Result<crate::struct_list::Builder<'a, crate::schema_capnp::node::Owned>>
+        {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(0),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_nodes(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::node::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(0),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_nodes(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::node::Owned> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), size)
+        }
+        #[inline]
+        pub fn has_nodes(&self) -> bool {
+            !self.builder.is_pointer_field_null(0)
+        }
+        #[inline]
+        pub fn get_requested_files(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Builder<
+                'a,
+                crate::schema_capnp::code_generator_request::requested_file::Owned,
+            >,
+        > {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(1),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_requested_files(
+            &mut self,
+            value: crate::struct_list::Reader<
+                'a,
+                crate::schema_capnp::code_generator_request::requested_file::Owned,
+            >,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(1),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_requested_files(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<
+            'a,
+            crate::schema_capnp::code_generator_request::requested_file::Owned,
+        > {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), size)
+        }
+        #[inline]
+        pub fn has_requested_files(&self) -> bool {
+            !self.builder.is_pointer_field_null(1)
+        }
+        #[inline]
+        pub fn get_capnp_version(
+            self,
+        ) -> crate::Result<crate::schema_capnp::capnp_version::Builder<'a>> {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(2),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_capnp_version(
+            &mut self,
+            value: crate::schema_capnp::capnp_version::Reader<'_>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(2),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_capnp_version(self) -> crate::schema_capnp::capnp_version::Builder<'a> {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(2), 0)
+        }
+        #[inline]
+        pub fn has_capnp_version(&self) -> bool {
+            !self.builder.is_pointer_field_null(2)
+        }
+        #[inline]
+        pub fn get_source_info(
+            self,
+        ) -> crate::Result<
+            crate::struct_list::Builder<'a, crate::schema_capnp::node::source_info::Owned>,
+        > {
+            crate::traits::FromPointerBuilder::get_from_pointer(
+                self.builder.get_pointer_field(3),
+                ::core::option::Option::None,
+            )
+        }
+        #[inline]
+        pub fn set_source_info(
+            &mut self,
+            value: crate::struct_list::Reader<'a, crate::schema_capnp::node::source_info::Owned>,
+        ) -> crate::Result<()> {
+            crate::traits::SetPointerBuilder::set_pointer_builder(
+                self.builder.reborrow().get_pointer_field(3),
+                value,
+                false,
+            )
+        }
+        #[inline]
+        pub fn init_source_info(
+            self,
+            size: u32,
+        ) -> crate::struct_list::Builder<'a, crate::schema_capnp::node::source_info::Owned>
+        {
+            crate::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(3), size)
+        }
+        #[inline]
+        pub fn has_source_info(&self) -> bool {
+            !self.builder.is_pointer_field_null(3)
+        }
+    }
+
+    pub struct Pipeline {
+        _typeless: crate::any_pointer::Pipeline,
+    }
+    impl crate::capability::FromTypelessPipeline for Pipeline {
+        fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+            Self {
+                _typeless: typeless,
+            }
+        }
+    }
+    impl Pipeline {
+        pub fn get_capnp_version(&self) -> crate::schema_capnp::capnp_version::Pipeline {
+            crate::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(2))
+        }
+    }
+    mod _private {
+        pub static ENCODED_NODE: [crate::Word; 98] = [
+            crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+            crate::word(206, 215, 10, 33, 246, 70, 197, 191),
+            crate::word(13, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(217, 114, 76, 98, 9, 197, 63, 169),
+            crate::word(4, 0, 7, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(21, 0, 0, 0, 18, 1, 0, 0),
+            crate::word(37, 0, 0, 0, 23, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(49, 0, 0, 0, 231, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+            crate::word(97, 112, 110, 112, 58, 67, 111, 100),
+            crate::word(101, 71, 101, 110, 101, 114, 97, 116),
+            crate::word(111, 114, 82, 101, 113, 117, 101, 115),
+            crate::word(116, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(4, 0, 0, 0, 1, 0, 1, 0),
+            crate::word(98, 0, 129, 46, 176, 14, 234, 207),
+            crate::word(1, 0, 0, 0, 114, 0, 0, 0),
+            crate::word(82, 101, 113, 117, 101, 115, 116, 101),
+            crate::word(100, 70, 105, 108, 101, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 3, 0, 4, 0),
+            crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(97, 0, 0, 0, 50, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(92, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(120, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(3, 0, 0, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(117, 0, 0, 0, 122, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(116, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(144, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(0, 0, 0, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(141, 0, 0, 0, 106, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(140, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(152, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(2, 0, 0, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 1, 0, 3, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(149, 0, 0, 0, 90, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(148, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(176, 0, 0, 0, 2, 0, 1, 0),
+            crate::word(110, 111, 100, 101, 115, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(23, 164, 35, 249, 76, 171, 130, 230),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(114, 101, 113, 117, 101, 115, 116, 101),
+            crate::word(100, 70, 105, 108, 101, 115, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(98, 0, 129, 46, 176, 14, 234, 207),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(99, 97, 112, 110, 112, 86, 101, 114),
+            crate::word(115, 105, 111, 110, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(99, 153, 131, 125, 91, 48, 93, 216),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(115, 111, 117, 114, 99, 101, 73, 110),
+            crate::word(102, 111, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+            crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(174, 87, 19, 4, 227, 29, 142, 243),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+        ];
+        pub fn get_field_types(index: u16) -> crate::introspect::Type {
+            match index {
+        0 => <crate::struct_list::Owned<crate::schema_capnp::node::Owned> as crate::introspect::Introspect>::introspect(),
+        1 => <crate::struct_list::Owned<crate::schema_capnp::code_generator_request::requested_file::Owned> as crate::introspect::Introspect>::introspect(),
+        2 => <crate::schema_capnp::capnp_version::Owned as crate::introspect::Introspect>::introspect(),
+        3 => <crate::struct_list::Owned<crate::schema_capnp::node::source_info::Owned> as crate::introspect::Introspect>::introspect(),
+        _ => panic!("invalid field index {}", index),
+      }
+        }
+        pub fn get_annotation_types(
+            child_index: Option<u16>,
+            index: u32,
+        ) -> crate::introspect::Type {
+            panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+        }
+        pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+            crate::introspect::RawStructSchema {
+                encoded_node: &ENCODED_NODE,
+                nonunion_members: NONUNION_MEMBERS,
+                members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+            };
+        pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2, 3];
+        pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+        pub const TYPE_ID: u64 = 0xbfc5_46f6_210a_d7ce;
+    }
+
+    pub mod requested_file {
+        #[derive(Copy, Clone)]
+        pub struct Owned(());
+        impl crate::introspect::Introspect for Owned {
+            fn introspect() -> crate::introspect::Type {
+                crate::introspect::TypeVariant::Struct(crate::introspect::RawBrandedStructSchema {
+                    generic: &_private::RAW_SCHEMA,
+                    field_types: _private::get_field_types,
+                    annotation_types: _private::get_annotation_types,
+                })
+                .into()
+            }
+        }
+        impl crate::traits::Owned for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::OwnedStruct for Owned {
+            type Reader<'a> = Reader<'a>;
+            type Builder<'a> = Builder<'a>;
+        }
+        impl crate::traits::Pipelined for Owned {
+            type Pipeline = Pipeline;
+        }
+
+        pub struct Reader<'a> {
+            reader: crate::private::layout::StructReader<'a>,
+        }
+        impl<'a> ::core::marker::Copy for Reader<'a> {}
+        impl<'a> ::core::clone::Clone for Reader<'a> {
+            fn clone(&self) -> Self {
+                *self
+            }
+        }
+
+        impl<'a> crate::traits::HasTypeId for Reader<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+            fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                Self { reader }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+            fn from(reader: Reader<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Reader::new(
+                    reader.reader,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> ::core::fmt::Debug for Reader<'a> {
+            fn fmt(
+                &self,
+                f: &mut ::core::fmt::Formatter<'_>,
+            ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                core::fmt::Debug::fmt(
+                    &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                    f,
+                )
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+            fn get_from_pointer(
+                reader: &crate::private::layout::PointerReader<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(reader.get_struct(default)?.into())
+            }
+        }
+
+        impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+            fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                self.reader
+            }
+        }
+
+        impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+            fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                self.reader
+                    .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+            }
+        }
+
+        impl<'a> Reader<'a> {
+            pub fn reborrow(&self) -> Reader<'_> {
+                Self { ..*self }
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.reader.total_size()
+            }
+            #[inline]
+            pub fn get_id(self) -> u64 {
+                self.reader.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn get_filename(self) -> crate::Result<crate::text::Reader<'a>> {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_filename(&self) -> bool {
+                !self.reader.get_pointer_field(0).is_null()
+            }
+            #[inline]
+            pub fn get_imports(
+                self,
+            ) -> crate::Result<
+                crate::struct_list::Reader<
+                    'a,
+                    crate::schema_capnp::code_generator_request::requested_file::import::Owned,
+                >,
+            > {
+                crate::traits::FromPointerReader::get_from_pointer(
+                    &self.reader.get_pointer_field(1),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn has_imports(&self) -> bool {
+                !self.reader.get_pointer_field(1).is_null()
+            }
+        }
+
+        pub struct Builder<'a> {
+            builder: crate::private::layout::StructBuilder<'a>,
+        }
+        impl<'a> crate::traits::HasStructSize for Builder<'a> {
+            const STRUCT_SIZE: crate::private::layout::StructSize =
+                crate::private::layout::StructSize {
+                    data: 1,
+                    pointers: 2,
+                };
+        }
+        impl<'a> crate::traits::HasTypeId for Builder<'a> {
+            const TYPE_ID: u64 = _private::TYPE_ID;
+        }
+        impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+            fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                Self { builder }
+            }
+        }
+
+        impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+            fn from(builder: Builder<'a>) -> Self {
+                Self::Struct(crate::dynamic_struct::Builder::new(
+                    builder.builder,
+                    crate::schema::StructSchema::new(crate::introspect::RawBrandedStructSchema {
+                        generic: &_private::RAW_SCHEMA,
+                        field_types: _private::get_field_types,
+                        annotation_types: _private::get_annotation_types,
+                    }),
+                ))
+            }
+        }
+
+        impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+            fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                self.builder
+                    .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+            }
+        }
+
+        impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+            fn init_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                _size: u32,
+            ) -> Self {
+                builder
+                    .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                    .into()
+            }
+            fn get_from_pointer(
+                builder: crate::private::layout::PointerBuilder<'a>,
+                default: ::core::option::Option<&'a [crate::Word]>,
+            ) -> crate::Result<Self> {
+                ::core::result::Result::Ok(
+                    builder
+                        .get_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE, default)?
+                        .into(),
+                )
+            }
+        }
+
+        impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+            fn set_pointer_builder(
+                mut pointer: crate::private::layout::PointerBuilder<'_>,
+                value: Self,
+                canonicalize: bool,
+            ) -> crate::Result<()> {
+                pointer.set_struct(&value.reader, canonicalize)
+            }
+        }
+
+        impl<'a> Builder<'a> {
+            pub fn into_reader(self) -> Reader<'a> {
+                self.builder.into_reader().into()
+            }
+            pub fn reborrow(&mut self) -> Builder<'_> {
+                Builder {
+                    builder: self.builder.reborrow(),
+                }
+            }
+            pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                self.builder.as_reader().into()
+            }
+
+            pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                self.builder.as_reader().total_size()
+            }
+            #[inline]
+            pub fn get_id(self) -> u64 {
+                self.builder.get_data_field::<u64>(0)
+            }
+            #[inline]
+            pub fn set_id(&mut self, value: u64) {
+                self.builder.set_data_field::<u64>(0, value);
+            }
+            #[inline]
+            pub fn get_filename(self) -> crate::Result<crate::text::Builder<'a>> {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(0),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_filename(&mut self, value: crate::text::Reader<'_>) {
+                self.builder.reborrow().get_pointer_field(0).set_text(value);
+            }
+            #[inline]
+            pub fn init_filename(self, size: u32) -> crate::text::Builder<'a> {
+                self.builder.get_pointer_field(0).init_text(size)
+            }
+            #[inline]
+            pub fn has_filename(&self) -> bool {
+                !self.builder.is_pointer_field_null(0)
+            }
+            #[inline]
+            pub fn get_imports(
+                self,
+            ) -> crate::Result<
+                crate::struct_list::Builder<
+                    'a,
+                    crate::schema_capnp::code_generator_request::requested_file::import::Owned,
+                >,
+            > {
+                crate::traits::FromPointerBuilder::get_from_pointer(
+                    self.builder.get_pointer_field(1),
+                    ::core::option::Option::None,
+                )
+            }
+            #[inline]
+            pub fn set_imports(
+                &mut self,
+                value: crate::struct_list::Reader<
+                    'a,
+                    crate::schema_capnp::code_generator_request::requested_file::import::Owned,
+                >,
+            ) -> crate::Result<()> {
+                crate::traits::SetPointerBuilder::set_pointer_builder(
+                    self.builder.reborrow().get_pointer_field(1),
+                    value,
+                    false,
+                )
+            }
+            #[inline]
+            pub fn init_imports(
+                self,
+                size: u32,
+            ) -> crate::struct_list::Builder<
+                'a,
+                crate::schema_capnp::code_generator_request::requested_file::import::Owned,
+            > {
+                crate::traits::FromPointerBuilder::init_pointer(
+                    self.builder.get_pointer_field(1),
+                    size,
+                )
+            }
+            #[inline]
+            pub fn has_imports(&self) -> bool {
+                !self.builder.is_pointer_field_null(1)
+            }
+        }
+
+        pub struct Pipeline {
+            _typeless: crate::any_pointer::Pipeline,
+        }
+        impl crate::capability::FromTypelessPipeline for Pipeline {
+            fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                Self {
+                    _typeless: typeless,
+                }
+            }
+        }
+        impl Pipeline {}
+        mod _private {
+            pub static ENCODED_NODE: [crate::Word; 73] = [
+                crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                crate::word(98, 0, 129, 46, 176, 14, 234, 207),
+                crate::word(34, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(206, 215, 10, 33, 246, 70, 197, 191),
+                crate::word(2, 0, 7, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(21, 0, 0, 0, 130, 1, 0, 0),
+                crate::word(41, 0, 0, 0, 23, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(49, 0, 0, 0, 175, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                crate::word(97, 112, 110, 112, 58, 67, 111, 100),
+                crate::word(101, 71, 101, 110, 101, 114, 97, 116),
+                crate::word(111, 114, 82, 101, 113, 117, 101, 115),
+                crate::word(116, 46, 82, 101, 113, 117, 101, 115),
+                crate::word(116, 101, 100, 70, 105, 108, 101, 0),
+                crate::word(4, 0, 0, 0, 1, 0, 1, 0),
+                crate::word(229, 87, 35, 18, 147, 65, 80, 174),
+                crate::word(1, 0, 0, 0, 58, 0, 0, 0),
+                crate::word(73, 109, 112, 111, 114, 116, 0, 0),
+                crate::word(12, 0, 0, 0, 3, 0, 4, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(69, 0, 0, 0, 26, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(64, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(76, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(73, 0, 0, 0, 74, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(72, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(84, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(2, 0, 0, 0, 1, 0, 0, 0),
+                crate::word(0, 0, 1, 0, 2, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(81, 0, 0, 0, 66, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(76, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(104, 0, 0, 0, 2, 0, 1, 0),
+                crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(102, 105, 108, 101, 110, 97, 109, 101),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(105, 109, 112, 111, 114, 116, 115, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 3, 0, 1, 0),
+                crate::word(16, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(229, 87, 35, 18, 147, 65, 80, 174),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(14, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+            ];
+            pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                match index {
+                    0 => <u64 as crate::introspect::Introspect>::introspect(),
+                    1 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                    2 => <crate::struct_list::Owned<
+                        crate::schema_capnp::code_generator_request::requested_file::import::Owned,
+                    > as crate::introspect::Introspect>::introspect(),
+                    _ => panic!("invalid field index {}", index),
+                }
+            }
+            pub fn get_annotation_types(
+                child_index: Option<u16>,
+                index: u32,
+            ) -> crate::introspect::Type {
+                panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+            }
+            pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                crate::introspect::RawStructSchema {
+                    encoded_node: &ENCODED_NODE,
+                    nonunion_members: NONUNION_MEMBERS,
+                    members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                };
+            pub static NONUNION_MEMBERS: &[u16] = &[0, 1, 2];
+            pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+            pub const TYPE_ID: u64 = 0xcfea_0eb0_2e81_0062;
+        }
+
+        pub mod import {
+            #[derive(Copy, Clone)]
+            pub struct Owned(());
+            impl crate::introspect::Introspect for Owned {
+                fn introspect() -> crate::introspect::Type {
+                    crate::introspect::TypeVariant::Struct(
+                        crate::introspect::RawBrandedStructSchema {
+                            generic: &_private::RAW_SCHEMA,
+                            field_types: _private::get_field_types,
+                            annotation_types: _private::get_annotation_types,
+                        },
+                    )
+                    .into()
+                }
+            }
+            impl crate::traits::Owned for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::OwnedStruct for Owned {
+                type Reader<'a> = Reader<'a>;
+                type Builder<'a> = Builder<'a>;
+            }
+            impl crate::traits::Pipelined for Owned {
+                type Pipeline = Pipeline;
+            }
+
+            pub struct Reader<'a> {
+                reader: crate::private::layout::StructReader<'a>,
+            }
+            impl<'a> ::core::marker::Copy for Reader<'a> {}
+            impl<'a> ::core::clone::Clone for Reader<'a> {
+                fn clone(&self) -> Self {
+                    *self
+                }
+            }
+
+            impl<'a> crate::traits::HasTypeId for Reader<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructReader<'a>> for Reader<'a> {
+                fn from(reader: crate::private::layout::StructReader<'a>) -> Self {
+                    Self { reader }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+                fn from(reader: Reader<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Reader::new(
+                        reader.reader,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> ::core::fmt::Debug for Reader<'a> {
+                fn fmt(
+                    &self,
+                    f: &mut ::core::fmt::Formatter<'_>,
+                ) -> ::core::result::Result<(), ::core::fmt::Error> {
+                    core::fmt::Debug::fmt(
+                        &::core::convert::Into::<crate::dynamic_value::Reader<'_>>::into(*self),
+                        f,
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+                fn get_from_pointer(
+                    reader: &crate::private::layout::PointerReader<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(reader.get_struct(default)?.into())
+                }
+            }
+
+            impl<'a> crate::traits::IntoInternalStructReader<'a> for Reader<'a> {
+                fn into_internal_struct_reader(self) -> crate::private::layout::StructReader<'a> {
+                    self.reader
+                }
+            }
+
+            impl<'a> crate::traits::Imbue<'a> for Reader<'a> {
+                fn imbue(&mut self, cap_table: &'a crate::private::layout::CapTable) {
+                    self.reader
+                        .imbue(crate::private::layout::CapTableReader::Plain(cap_table))
+                }
+            }
+
+            impl<'a> Reader<'a> {
+                pub fn reborrow(&self) -> Reader<'_> {
+                    Self { ..*self }
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.reader.total_size()
+                }
+                #[inline]
+                pub fn get_id(self) -> u64 {
+                    self.reader.get_data_field::<u64>(0)
+                }
+                #[inline]
+                pub fn get_name(self) -> crate::Result<crate::text::Reader<'a>> {
+                    crate::traits::FromPointerReader::get_from_pointer(
+                        &self.reader.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    )
+                }
+                #[inline]
+                pub fn has_name(&self) -> bool {
+                    !self.reader.get_pointer_field(0).is_null()
+                }
+            }
+
+            pub struct Builder<'a> {
+                builder: crate::private::layout::StructBuilder<'a>,
+            }
+            impl<'a> crate::traits::HasStructSize for Builder<'a> {
+                const STRUCT_SIZE: crate::private::layout::StructSize =
+                    crate::private::layout::StructSize {
+                        data: 1,
+                        pointers: 1,
+                    };
+            }
+            impl<'a> crate::traits::HasTypeId for Builder<'a> {
+                const TYPE_ID: u64 = _private::TYPE_ID;
+            }
+            impl<'a> ::core::convert::From<crate::private::layout::StructBuilder<'a>> for Builder<'a> {
+                fn from(builder: crate::private::layout::StructBuilder<'a>) -> Self {
+                    Self { builder }
+                }
+            }
+
+            impl<'a> ::core::convert::From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+                fn from(builder: Builder<'a>) -> Self {
+                    Self::Struct(crate::dynamic_struct::Builder::new(
+                        builder.builder,
+                        crate::schema::StructSchema::new(
+                            crate::introspect::RawBrandedStructSchema {
+                                generic: &_private::RAW_SCHEMA,
+                                field_types: _private::get_field_types,
+                                annotation_types: _private::get_annotation_types,
+                            },
+                        ),
+                    ))
+                }
+            }
+
+            impl<'a> crate::traits::ImbueMut<'a> for Builder<'a> {
+                fn imbue_mut(&mut self, cap_table: &'a mut crate::private::layout::CapTable) {
+                    self.builder
+                        .imbue(crate::private::layout::CapTableBuilder::Plain(cap_table))
+                }
+            }
+
+            impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+                fn init_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    _size: u32,
+                ) -> Self {
+                    builder
+                        .init_struct(<Self as crate::traits::HasStructSize>::STRUCT_SIZE)
+                        .into()
+                }
+                fn get_from_pointer(
+                    builder: crate::private::layout::PointerBuilder<'a>,
+                    default: ::core::option::Option<&'a [crate::Word]>,
+                ) -> crate::Result<Self> {
+                    ::core::result::Result::Ok(
+                        builder
+                            .get_struct(
+                                <Self as crate::traits::HasStructSize>::STRUCT_SIZE,
+                                default,
+                            )?
+                            .into(),
+                    )
+                }
+            }
+
+            impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+                fn set_pointer_builder(
+                    mut pointer: crate::private::layout::PointerBuilder<'_>,
+                    value: Self,
+                    canonicalize: bool,
+                ) -> crate::Result<()> {
+                    pointer.set_struct(&value.reader, canonicalize)
+                }
+            }
+
+            impl<'a> Builder<'a> {
+                pub fn into_reader(self) -> Reader<'a> {
+                    self.builder.into_reader().into()
+                }
+                pub fn reborrow(&mut self) -> Builder<'_> {
+                    Builder {
+                        builder: self.builder.reborrow(),
+                    }
+                }
+                pub fn reborrow_as_reader(&self) -> Reader<'_> {
+                    self.builder.as_reader().into()
+                }
+
+                pub fn total_size(&self) -> crate::Result<crate::MessageSize> {
+                    self.builder.as_reader().total_size()
+                }
+                #[inline]
+                pub fn get_id(self) -> u64 {
+                    self.builder.get_data_field::<u64>(0)
+                }
+                #[inline]
+                pub fn set_id(&mut self, value: u64) {
+                    self.builder.set_data_field::<u64>(0, value);
+                }
+                #[inline]
+                pub fn get_name(self) -> crate::Result<crate::text::Builder<'a>> {
+                    crate::traits::FromPointerBuilder::get_from_pointer(
+                        self.builder.get_pointer_field(0),
+                        ::core::option::Option::None,
+                    )
+                }
+                #[inline]
+                pub fn set_name(&mut self, value: crate::text::Reader<'_>) {
+                    self.builder.reborrow().get_pointer_field(0).set_text(value);
+                }
+                #[inline]
+                pub fn init_name(self, size: u32) -> crate::text::Builder<'a> {
+                    self.builder.get_pointer_field(0).init_text(size)
+                }
+                #[inline]
+                pub fn has_name(&self) -> bool {
+                    !self.builder.is_pointer_field_null(0)
+                }
+            }
+
+            pub struct Pipeline {
+                _typeless: crate::any_pointer::Pipeline,
+            }
+            impl crate::capability::FromTypelessPipeline for Pipeline {
+                fn new(typeless: crate::any_pointer::Pipeline) -> Self {
+                    Self {
+                        _typeless: typeless,
+                    }
+                }
+            }
+            impl Pipeline {}
+            mod _private {
+                pub static ENCODED_NODE: [crate::Word; 51] = [
+                    crate::word(0, 0, 0, 0, 5, 0, 6, 0),
+                    crate::word(229, 87, 35, 18, 147, 65, 80, 174),
+                    crate::word(48, 0, 0, 0, 1, 0, 1, 0),
+                    crate::word(98, 0, 129, 46, 176, 14, 234, 207),
+                    crate::word(1, 0, 7, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(21, 0, 0, 0, 186, 1, 0, 0),
+                    crate::word(45, 0, 0, 0, 7, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(41, 0, 0, 0, 119, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(115, 99, 104, 101, 109, 97, 46, 99),
+                    crate::word(97, 112, 110, 112, 58, 67, 111, 100),
+                    crate::word(101, 71, 101, 110, 101, 114, 97, 116),
+                    crate::word(111, 114, 82, 101, 113, 117, 101, 115),
+                    crate::word(116, 46, 82, 101, 113, 117, 101, 115),
+                    crate::word(116, 101, 100, 70, 105, 108, 101, 46),
+                    crate::word(73, 109, 112, 111, 114, 116, 0, 0),
+                    crate::word(0, 0, 0, 0, 1, 0, 1, 0),
+                    crate::word(8, 0, 0, 0, 3, 0, 4, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(41, 0, 0, 0, 26, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(36, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(48, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(1, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 1, 0, 1, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(45, 0, 0, 0, 42, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(40, 0, 0, 0, 3, 0, 1, 0),
+                    crate::word(52, 0, 0, 0, 2, 0, 1, 0),
+                    crate::word(105, 100, 0, 0, 0, 0, 0, 0),
+                    crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(9, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(110, 97, 109, 101, 0, 0, 0, 0),
+                    crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(12, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                    crate::word(0, 0, 0, 0, 0, 0, 0, 0),
+                ];
+                pub fn get_field_types(index: u16) -> crate::introspect::Type {
+                    match index {
+                        0 => <u64 as crate::introspect::Introspect>::introspect(),
+                        1 => <crate::text::Owned as crate::introspect::Introspect>::introspect(),
+                        _ => panic!("invalid field index {}", index),
+                    }
+                }
+                pub fn get_annotation_types(
+                    child_index: Option<u16>,
+                    index: u32,
+                ) -> crate::introspect::Type {
+                    panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
+                }
+                pub static RAW_SCHEMA: crate::introspect::RawStructSchema =
+                    crate::introspect::RawStructSchema {
+                        encoded_node: &ENCODED_NODE,
+                        nonunion_members: NONUNION_MEMBERS,
+                        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
+                    };
+                pub static NONUNION_MEMBERS: &[u16] = &[0, 1];
+                pub static MEMBERS_BY_DISCRIMINANT: &[u16] = &[];
+                pub const TYPE_ID: u64 = 0xae50_4193_1223_57e5;
+            }
+        }
+    }
+}
diff --git a/rust/capnp/serialize.rs b/rust/capnp/serialize.rs
new file mode 100644
index 000000000000..ad9e130e5ed7
--- /dev/null
+++ b/rust/capnp/serialize.rs
@@ -0,0 +1,961 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Reading and writing of messages using the
+//! [standard stream framing](https://capnproto.org/encoding.html#serialization-over-a-stream),
+//! where each message is preceded by a segment table indicating the size of its segments.
+
+mod no_alloc_buffer_segments;
+pub use no_alloc_buffer_segments::{NoAllocBufferSegments, NoAllocSliceSegments};
+
+#[cfg(feature = "alloc")]
+use crate::io::{Read, Write};
+#[cfg(feature = "alloc")]
+use alloc::vec::Vec;
+#[cfg(feature = "alloc")]
+use core::convert::TryInto;
+#[cfg(feature = "alloc")]
+use core::ops::Deref;
+
+use crate::message;
+#[cfg(feature = "alloc")]
+use crate::private::units::BYTES_PER_WORD;
+use crate::Result;
+#[cfg(feature = "alloc")]
+use crate::{Error, ErrorKind};
+
+pub const SEGMENTS_COUNT_LIMIT: usize = 512;
+
+/// Segments read from a single flat slice of words.
+#[cfg(feature = "alloc")]
+type SliceSegments<'a> = BufferSegments<&'a [u8]>;
+
+/// Reads a serialized message (including a segment table) from a flat slice of bytes, without copying.
+/// The slice is allowed to extend beyond the end of the message. On success, updates `slice` to point
+/// to the remaining bytes beyond the end of the message.
+///
+/// ALIGNMENT: If the "unaligned" feature is enabled, then there are no alignment requirements on `slice`.
+/// Otherwise, `slice` must be 8-byte aligned (attempts to read the message will trigger errors).
+#[cfg(feature = "alloc")]
+pub fn read_message_from_flat_slice<'a>(
+    slice: &mut &'a [u8],
+    options: message::ReaderOptions,
+) -> Result<message::Reader<BufferSegments<&'a [u8]>>> {
+    let all_bytes = *slice;
+    let mut bytes = *slice;
+    let orig_bytes_len = bytes.len();
+    let Some(segment_lengths_builder) = read_segment_table(&mut bytes, options)? else {
+        return Err(Error::from_kind(ErrorKind::EmptySlice));
+    };
+    let segment_table_bytes_len = orig_bytes_len - bytes.len();
+    assert_eq!(segment_table_bytes_len % BYTES_PER_WORD, 0);
+    let num_words = segment_lengths_builder.total_words();
+    let body_bytes = &all_bytes[segment_table_bytes_len..];
+    if num_words > (body_bytes.len() / BYTES_PER_WORD) {
+        Err(Error::from_kind(ErrorKind::MessageEndsPrematurely(
+            num_words,
+            body_bytes.len() / BYTES_PER_WORD,
+        )))
+    } else {
+        *slice = &body_bytes[(num_words * BYTES_PER_WORD)..];
+        Ok(message::Reader::new(
+            segment_lengths_builder.into_slice_segments(all_bytes, segment_table_bytes_len),
+            options,
+        ))
+    }
+}
+
+/// Reads a serialized message (including a segment table) from a flat slice of bytes, without copying.
+/// The slice is allowed to extend beyond the end of the message. On success, updates `slice` to point
+/// to the remaining bytes beyond the end of the message.
+///
+/// Unlike read_message_from_flat_slice_no_alloc it does not do heap allocation
+///
+/// ALIGNMENT: If the "unaligned" feature is enabled, then there are no alignment requirements on `slice`.
+/// Otherwise, `slice` must be 8-byte aligned (attempts to read the message will trigger errors).
+pub fn read_message_from_flat_slice_no_alloc<'a>(
+    slice: &mut &'a [u8],
+    options: message::ReaderOptions,
+) -> Result<message::Reader<NoAllocSliceSegments<'a>>> {
+    let segments = NoAllocSliceSegments::from_slice(slice, options)?;
+
+    Ok(message::Reader::new(segments, options))
+}
+
+/// Segments read from a buffer, useful for when you have the message in a buffer and don't want the extra
+/// copy of `read_message`.
+#[cfg(feature = "alloc")]
+pub struct BufferSegments<T> {
+    buffer: T,
+
+    // Number of bytes in the segment table.
+    segment_table_bytes_len: usize,
+
+    // Each pair represents a segment inside of `buffer`:
+    // (starting index (in words), ending index (in words)),
+    // where the indices are relative to the end of the segment table.
+    segment_indices: Vec<(usize, usize)>,
+}
+
+#[cfg(feature = "alloc")]
+impl<T: Deref<Target = [u8]>> BufferSegments<T> {
+    /// Reads a serialized message (including a segment table) from a buffer and takes ownership, without copying.
+    /// The buffer is allowed to be longer than the message. Provide this to `Reader::new` with options that make
+    /// sense for your use case. Very long lived mmaps may need unlimited traversal limit.
+    ///
+    /// ALIGNMENT: If the "unaligned" feature is enabled, then there are no alignment requirements on `buffer`.
+    /// Otherwise, `buffer` must be 8-byte aligned (attempts to read the message will trigger errors).
+    pub fn new(buffer: T, options: message::ReaderOptions) -> Result<Self> {
+        let mut segment_bytes = &*buffer;
+
+        let Some(segment_table) = read_segment_table(&mut segment_bytes, options)? else {
+            return Err(Error::from_kind(ErrorKind::EmptyBuffer));
+        };
+        let segment_table_bytes_len = buffer.len() - segment_bytes.len();
+
+        assert!(segment_table.total_words() * 8 <= buffer.len());
+        let segment_indices = segment_table.to_segment_indices();
+        Ok(Self {
+            buffer,
+            segment_table_bytes_len,
+            segment_indices,
+        })
+    }
+
+    pub fn into_buffer(self) -> T {
+        self.buffer
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl<T: Deref<Target = [u8]>> message::ReaderSegments for BufferSegments<T> {
+    fn get_segment(&self, id: u32) -> Option<&[u8]> {
+        if id < self.segment_indices.len() as u32 {
+            let (a, b) = self.segment_indices[id as usize];
+            Some(
+                &self.buffer[(self.segment_table_bytes_len + a * BYTES_PER_WORD)
+                    ..(self.segment_table_bytes_len + b * BYTES_PER_WORD)],
+            )
+        } else {
+            None
+        }
+    }
+
+    fn len(&self) -> usize {
+        self.segment_indices.len()
+    }
+}
+
+/// Owned memory containing a message's segments sequentialized in a single contiguous buffer.
+/// The segments are guaranteed to be 8-byte aligned.
+#[cfg(feature = "alloc")]
+pub struct OwnedSegments {
+    // Each pair represents a segment inside of `owned_space`.
+    // (starting index (in words), ending index (in words))
+    segment_indices: Vec<(usize, usize)>,
+
+    owned_space: Vec<crate::Word>,
+}
+
+#[cfg(feature = "alloc")]
+impl core::ops::Deref for OwnedSegments {
+    type Target = [u8];
+    fn deref(&self) -> &[u8] {
+        crate::Word::words_to_bytes(&self.owned_space[..])
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl core::ops::DerefMut for OwnedSegments {
+    fn deref_mut(&mut self) -> &mut [u8] {
+        crate::Word::words_to_bytes_mut(&mut self.owned_space[..])
+    }
+}
+
+#[cfg(feature = "alloc")]
+impl crate::message::ReaderSegments for OwnedSegments {
+    fn get_segment(&self, id: u32) -> Option<&[u8]> {
+        if id < self.segment_indices.len() as u32 {
+            let (a, b) = self.segment_indices[id as usize];
+            Some(&self[(a * BYTES_PER_WORD)..(b * BYTES_PER_WORD)])
+        } else {
+            None
+        }
+    }
+
+    fn len(&self) -> usize {
+        self.segment_indices.len()
+    }
+}
+
+#[cfg(feature = "alloc")]
+/// Helper object for constructing an `OwnedSegments` or a `SliceSegments`.
+pub struct SegmentLengthsBuilder {
+    segment_indices: Vec<(usize, usize)>,
+    total_words: usize,
+}
+
+#[cfg(feature = "alloc")]
+impl SegmentLengthsBuilder {
+    /// Creates a new `SegmentsLengthsBuilder`, initializing the segment_indices vector with
+    /// `Vec::with_capacitiy(capacity)`. `capacity` should equal the number of times that `push_segment()`
+    /// is expected to be called.
+    pub fn with_capacity(capacity: usize) -> Self {
+        Self {
+            segment_indices: Vec::with_capacity(capacity),
+            total_words: 0,
+        }
+    }
+
+    /// Pushes a new segment length. The `n`th time (starting at 0) this is called specifies the length of
+    /// the segment with ID `n`.
+    pub fn push_segment(&mut self, length_in_words: usize) {
+        self.segment_indices
+            .push((self.total_words, self.total_words + length_in_words));
+        self.total_words += length_in_words;
+    }
+
+    /// Constructs an `OwnedSegments`, allocating a single buffer of 8-byte aligned memory to hold
+    /// all segments.
+    pub fn into_owned_segments(self) -> OwnedSegments {
+        let owned_space = crate::Word::allocate_zeroed_vec(self.total_words);
+        OwnedSegments {
+            segment_indices: self.segment_indices,
+            owned_space,
+        }
+    }
+
+    /// Constructs a `SliceSegments`.
+    /// `slice` contains the full message (including the segment header).
+    pub fn into_slice_segments(
+        self,
+        slice: &[u8],
+        segment_table_bytes_len: usize,
+    ) -> SliceSegments {
+        assert!(self.total_words * BYTES_PER_WORD <= slice.len());
+        BufferSegments {
+            buffer: slice,
+            segment_table_bytes_len,
+            segment_indices: self.segment_indices,
+        }
+    }
+
+    /// Returns the sum of the lengths of the segments pushed so far.
+    pub fn total_words(&self) -> usize {
+        self.total_words
+    }
+
+    /// Returns the vector of segment indices. Each entry is a pair (start_word_index, end_word_index).
+    /// This method primarily exists to enable testing.
+    pub fn to_segment_indices(self) -> Vec<(usize, usize)> {
+        self.segment_indices
+    }
+}
+
+/// Reads a serialized message from a stream with the provided options.
+///
+/// For optimal performance, `read` should be a buffered reader type.
+#[cfg(feature = "alloc")]
+pub fn read_message<R>(
+    mut read: R,
+    options: message::ReaderOptions,
+) -> Result<message::Reader<OwnedSegments>>
+where
+    R: Read,
+{
+    let Some(owned_segments_builder) = read_segment_table(&mut read, options)? else {
+        return Err(Error::from_kind(ErrorKind::PrematureEndOfFile));
+    };
+    read_segments(
+        &mut read,
+        owned_segments_builder.into_owned_segments(),
+        options,
+    )
+}
+
+/// Like `read_message()`, but returns None instead of an error if there are zero bytes left in
+/// `read`. This is useful for reading a stream containing an unknown number of messages -- you
+/// call this function until it returns None.
+#[cfg(feature = "alloc")]
+pub fn try_read_message<R>(
+    mut read: R,
+    options: message::ReaderOptions,
+) -> Result<Option<message::Reader<OwnedSegments>>>
+where
+    R: Read,
+{
+    let Some(owned_segments_builder) = read_segment_table(&mut read, options)? else {
+        return Ok(None);
+    };
+    Ok(Some(read_segments(
+        &mut read,
+        owned_segments_builder.into_owned_segments(),
+        options,
+    )?))
+}
+
+/// Reads a segment table from `read` and returns the total number of words across all
+/// segments, as well as the segment offsets.
+///
+/// The segment table format for streams is defined in the Cap'n Proto
+/// [encoding spec](https://capnproto.org/encoding.html)
+#[cfg(feature = "alloc")]
+fn read_segment_table<R>(
+    read: &mut R,
+    options: message::ReaderOptions,
+) -> Result<Option<SegmentLengthsBuilder>>
+where
+    R: Read,
+{
+    // read the first Word, which contains segment_count and the 1st segment length
+    let mut buf: [u8; 8] = [0; 8];
+    {
+        let n = read.read(&mut buf[..])?;
+        if n == 0 {
+            // Clean EOF on message boundary
+            return Ok(None);
+        } else if n < 8 {
+            read.read_exact(&mut buf[n..])?;
+        }
+    }
+
+    let segment_count = u32::from_le_bytes(buf[0..4].try_into().unwrap()).wrapping_add(1) as usize;
+
+    if segment_count >= SEGMENTS_COUNT_LIMIT || segment_count == 0 {
+        return Err(Error::from_kind(ErrorKind::InvalidNumberOfSegments(
+            segment_count,
+        )));
+    }
+
+    let mut segment_lengths_builder = SegmentLengthsBuilder::with_capacity(segment_count);
+    segment_lengths_builder
+        .push_segment(u32::from_le_bytes(buf[4..8].try_into().unwrap()) as usize);
+    if segment_count > 1 {
+        if segment_count < 4 {
+            read.read_exact(&mut buf)?;
+            for idx in 0..(segment_count - 1) {
+                let segment_len =
+                    u32::from_le_bytes(buf[(idx * 4)..(idx + 1) * 4].try_into().unwrap()) as usize;
+                segment_lengths_builder.push_segment(segment_len);
+            }
+        } else {
+            let mut segment_sizes = vec![0u8; (segment_count & !1) * 4];
+            read.read_exact(&mut segment_sizes[..])?;
+            for idx in 0..(segment_count - 1) {
+                let segment_len =
+                    u32::from_le_bytes(segment_sizes[(idx * 4)..(idx + 1) * 4].try_into().unwrap())
+                        as usize;
+                segment_lengths_builder.push_segment(segment_len);
+            }
+        }
+    }
+
+    // Don't accept a message which the receiver couldn't possibly traverse without hitting the
+    // traversal limit. Without this check, a malicious client could transmit a very large segment
+    // size to make the receiver allocate excessive space and possibly crash.
+    if let Some(limit) = options.traversal_limit_in_words {
+        if segment_lengths_builder.total_words() > limit {
+            return Err(Error::from_kind(ErrorKind::MessageTooLarge(
+                segment_lengths_builder.total_words(),
+            )));
+        }
+    }
+
+    Ok(Some(segment_lengths_builder))
+}
+
+#[cfg(feature = "alloc")]
+/// Reads segments from `read`.
+fn read_segments<R>(
+    read: &mut R,
+    mut owned_segments: OwnedSegments,
+    options: message::ReaderOptions,
+) -> Result<message::Reader<OwnedSegments>>
+where
+    R: Read,
+{
+    read.read_exact(&mut owned_segments[..])?;
+    Ok(crate::message::Reader::new(owned_segments, options))
+}
+
+/// Constructs a flat vector containing the entire message, including a segment header.
+#[cfg(feature = "alloc")]
+pub fn write_message_to_words<A>(message: &message::Builder<A>) -> Vec<u8>
+where
+    A: message::Allocator,
+{
+    flatten_segments(&*message.get_segments_for_output())
+}
+
+/// Like `write_message_to_words()`, but takes a `ReaderSegments`, allowing it to be
+/// used on `message::Reader` objects (via `into_segments()`).
+#[cfg(feature = "alloc")]
+pub fn write_message_segments_to_words<R>(message: &R) -> Vec<u8>
+where
+    R: message::ReaderSegments,
+{
+    flatten_segments(message)
+}
+
+#[cfg(feature = "alloc")]
+fn flatten_segments<R: message::ReaderSegments + ?Sized>(segments: &R) -> Vec<u8> {
+    let word_count = compute_serialized_size(segments);
+    let segment_count = segments.len();
+    let table_size = segment_count / 2 + 1;
+    let mut result = Vec::with_capacity(word_count);
+    result.resize(table_size * BYTES_PER_WORD, 0);
+    {
+        let mut bytes = &mut result[..];
+        write_segment_table_internal(&mut bytes, segments).expect("Failed to write segment table.");
+    }
+    for i in 0..segment_count {
+        let segment = segments.get_segment(i as u32).unwrap();
+        result.extend(segment);
+    }
+    result
+}
+
+/// Writes the provided message to `write`.
+///
+/// For optimal performance, `write` should be a buffered writer. `flush()` will not be called on
+/// the writer.
+///
+/// The only source of errors from this function are `write.write_all()` calls. If you pass in
+/// a writer that never returns an error, then this function will never return an error.
+#[cfg(feature = "alloc")]
+pub fn write_message<W, A>(mut write: W, message: &message::Builder<A>) -> Result<()>
+where
+    W: Write,
+    A: message::Allocator,
+{
+    let segments = message.get_segments_for_output();
+    write_segment_table(&mut write, &segments)?;
+    write_segments(&mut write, &segments)
+}
+
+/// Like `write_message()`, but takes a `ReaderSegments`, allowing it to be
+/// used on `message::Reader` objects (via `into_segments()`).
+#[cfg(feature = "alloc")]
+pub fn write_message_segments<W, R>(mut write: W, segments: &R) -> Result<()>
+where
+    W: Write,
+    R: message::ReaderSegments,
+{
+    write_segment_table_internal(&mut write, segments)?;
+    write_segments(&mut write, segments)
+}
+
+#[cfg(feature = "alloc")]
+fn write_segment_table<W>(write: &mut W, segments: &[&[u8]]) -> Result<()>
+where
+    W: Write,
+{
+    write_segment_table_internal(write, segments)
+}
+
+/// Writes a segment table to `write`.
+///
+/// `segments` must contain at least one segment.
+#[cfg(feature = "alloc")]
+fn write_segment_table_internal<W, R>(write: &mut W, segments: &R) -> Result<()>
+where
+    W: Write,
+    R: message::ReaderSegments + ?Sized,
+{
+    let mut buf: [u8; 8] = [0; 8];
+    let segment_count = segments.len();
+
+    // write the first Word, which contains segment_count and the 1st segment length
+    buf[0..4].copy_from_slice(&(segment_count as u32 - 1).to_le_bytes());
+    buf[4..8].copy_from_slice(
+        &((segments.get_segment(0).unwrap().len() / BYTES_PER_WORD) as u32).to_le_bytes(),
+    );
+    write.write_all(&buf)?;
+
+    if segment_count > 1 {
+        if segment_count < 4 {
+            for idx in 1..segment_count {
+                buf[(idx - 1) * 4..idx * 4].copy_from_slice(
+                    &((segments.get_segment(idx as u32).unwrap().len() / BYTES_PER_WORD) as u32)
+                        .to_le_bytes(),
+                );
+            }
+            if segment_count == 2 {
+                for b in &mut buf[4..8] {
+                    *b = 0
+                }
+            }
+            write.write_all(&buf)?;
+        } else {
+            let mut buf = vec![0; (segment_count & !1) * 4];
+            for idx in 1..segment_count {
+                buf[(idx - 1) * 4..idx * 4].copy_from_slice(
+                    &((segments.get_segment(idx as u32).unwrap().len() / BYTES_PER_WORD) as u32)
+                        .to_le_bytes(),
+                );
+            }
+            if segment_count % 2 == 0 {
+                let start_idx = buf.len() - 4;
+                for b in &mut buf[start_idx..] {
+                    *b = 0
+                }
+            }
+            write.write_all(&buf)?;
+        }
+    }
+    Ok(())
+}
+
+/// Writes segments to `write`.
+#[cfg(feature = "alloc")]
+fn write_segments<W, R: message::ReaderSegments + ?Sized>(write: &mut W, segments: &R) -> Result<()>
+where
+    W: Write,
+{
+    for i in 0.. {
+        if let Some(segment) = segments.get_segment(i) {
+            write.write_all(segment)?;
+        } else {
+            break;
+        }
+    }
+    Ok(())
+}
+
+#[cfg(feature = "alloc")]
+fn compute_serialized_size<R: message::ReaderSegments + ?Sized>(segments: &R) -> usize {
+    // Table size
+    let len = segments.len();
+    let mut size = (len / 2) + 1;
+    for i in 0..len {
+        let segment = segments.get_segment(i as u32).unwrap();
+        size += segment.len() / BYTES_PER_WORD;
+    }
+    size
+}
+
+/// Returns the number of (8-byte) words required to serialize the message (including the
+/// segment table).
+///
+/// Multiply this by 8 (or `std::mem::size_of::<capnp::Word>()`) to get the number of bytes
+/// that [`write_message()`](fn.write_message.html) will write.
+#[cfg(feature = "alloc")]
+pub fn compute_serialized_size_in_words<A>(message: &crate::message::Builder<A>) -> usize
+where
+    A: crate::message::Allocator,
+{
+    compute_serialized_size(&message.get_segments_for_output())
+}
+
+#[cfg(feature = "alloc")]
+#[cfg(test)]
+pub mod test {
+    use alloc::vec::Vec;
+
+    use crate::io::{Read, Write};
+
+    use quickcheck::{quickcheck, TestResult};
+
+    use super::{
+        flatten_segments, read_message, read_message_from_flat_slice, read_segment_table,
+        try_read_message, write_segment_table, write_segments,
+    };
+    use crate::message;
+    use crate::message::ReaderSegments;
+
+    /// Writes segments as if they were a Capnproto message.
+    pub fn write_message_segments<W>(write: &mut W, segments: &[Vec<crate::Word>])
+    where
+        W: Write,
+    {
+        let borrowed_segments: &[&[u8]] = &segments
+            .iter()
+            .map(|segment| crate::Word::words_to_bytes(&segment[..]))
+            .collect::<Vec<_>>()[..];
+        write_segment_table(write, borrowed_segments).unwrap();
+        write_segments(write, borrowed_segments).unwrap();
+    }
+
+    #[test]
+    fn try_read_empty() {
+        let mut buf: &[u8] = &[];
+        assert!(try_read_message(&mut buf, message::ReaderOptions::new())
+            .unwrap()
+            .is_none());
+    }
+
+    #[test]
+    fn test_read_segment_table() {
+        let mut buf = vec![];
+
+        buf.extend(
+            [
+                0, 0, 0, 0, // 1 segments
+                0, 0, 0, 0,
+            ], // 0 length
+        );
+        let segment_lengths_builder =
+            read_segment_table(&mut &buf[..], message::ReaderOptions::new())
+                .unwrap()
+                .unwrap();
+        assert_eq!(0, segment_lengths_builder.total_words());
+        assert_eq!(vec![(0, 0)], segment_lengths_builder.to_segment_indices());
+        buf.clear();
+
+        buf.extend(
+            [
+                0, 0, 0, 0, // 1 segments
+                1, 0, 0, 0,
+            ], // 1 length
+        );
+        let segment_lengths_builder =
+            read_segment_table(&mut &buf[..], message::ReaderOptions::new())
+                .unwrap()
+                .unwrap();
+        assert_eq!(1, segment_lengths_builder.total_words());
+        assert_eq!(vec![(0, 1)], segment_lengths_builder.to_segment_indices());
+        buf.clear();
+
+        buf.extend(
+            [
+                1, 0, 0, 0, // 2 segments
+                1, 0, 0, 0, // 1 length
+                1, 0, 0, 0, // 1 length
+                0, 0, 0, 0,
+            ], // padding
+        );
+        let segment_lengths_builder =
+            read_segment_table(&mut &buf[..], message::ReaderOptions::new())
+                .unwrap()
+                .unwrap();
+        assert_eq!(2, segment_lengths_builder.total_words());
+        assert_eq!(
+            vec![(0, 1), (1, 2)],
+            segment_lengths_builder.to_segment_indices()
+        );
+        buf.clear();
+
+        buf.extend(
+            [
+                2, 0, 0, 0, // 3 segments
+                1, 0, 0, 0, // 1 length
+                1, 0, 0, 0, // 1 length
+                0, 1, 0, 0,
+            ], // 256 length
+        );
+        let segment_lengths_builder =
+            read_segment_table(&mut &buf[..], message::ReaderOptions::new())
+                .unwrap()
+                .unwrap();
+        assert_eq!(258, segment_lengths_builder.total_words());
+        assert_eq!(
+            vec![(0, 1), (1, 2), (2, 258)],
+            segment_lengths_builder.to_segment_indices()
+        );
+        buf.clear();
+
+        buf.extend(
+            [
+                3, 0, 0, 0, // 4 segments
+                77, 0, 0, 0, // 77 length
+                23, 0, 0, 0, // 23 length
+                1, 0, 0, 0, // 1 length
+                99, 0, 0, 0, // 99 length
+                0, 0, 0, 0,
+            ], // padding
+        );
+        let segment_lengths_builder =
+            read_segment_table(&mut &buf[..], message::ReaderOptions::new())
+                .unwrap()
+                .unwrap();
+        assert_eq!(200, segment_lengths_builder.total_words());
+        assert_eq!(
+            vec![(0, 77), (77, 100), (100, 101), (101, 200)],
+            segment_lengths_builder.to_segment_indices()
+        );
+        buf.clear();
+    }
+
+    struct MaxRead<R>
+    where
+        R: Read,
+    {
+        inner: R,
+        max: usize,
+    }
+
+    impl<R> Read for MaxRead<R>
+    where
+        R: Read,
+    {
+        fn read(&mut self, buf: &mut [u8]) -> crate::Result<usize> {
+            if buf.len() <= self.max {
+                self.inner.read(buf)
+            } else {
+                self.inner.read(&mut buf[0..self.max])
+            }
+        }
+    }
+
+    #[test]
+    fn test_read_segment_table_max_read() {
+        // Make sure things still work well when we read less than a word at a time.
+        let mut buf: Vec<u8> = vec![];
+        buf.extend(
+            [
+                0, 0, 0, 0, // 1 segments
+                1, 0, 0, 0,
+            ], // 1 length
+        );
+        let segment_lengths_builder = read_segment_table(
+            &mut MaxRead {
+                inner: &buf[..],
+                max: 2,
+            },
+            message::ReaderOptions::new(),
+        )
+        .unwrap()
+        .unwrap();
+        assert_eq!(1, segment_lengths_builder.total_words());
+        assert_eq!(vec![(0, 1)], segment_lengths_builder.to_segment_indices());
+    }
+
+    #[test]
+    fn test_read_invalid_segment_table() {
+        let mut buf = vec![];
+
+        buf.extend([0, 2, 0, 0]); // 513 segments
+        buf.extend([0; 513 * 4]);
+        assert!(read_segment_table(&mut &buf[..], message::ReaderOptions::new()).is_err());
+        buf.clear();
+
+        buf.extend([0, 0, 0, 0]); // 1 segments
+        assert!(read_segment_table(&mut &buf[..], message::ReaderOptions::new()).is_err());
+        buf.clear();
+
+        buf.extend([0, 0, 0, 0]); // 1 segments
+        buf.extend([0; 3]);
+        assert!(read_segment_table(&mut &buf[..], message::ReaderOptions::new()).is_err());
+        buf.clear();
+
+        buf.extend([255, 255, 255, 255]); // 0 segments
+        assert!(read_segment_table(&mut &buf[..], message::ReaderOptions::new()).is_err());
+        buf.clear();
+    }
+
+    #[test]
+    fn test_write_segment_table() {
+        let mut buf = vec![];
+
+        let segment_0 = [0u8; 0];
+        let segment_1 = [1u8, 1, 1, 1, 1, 1, 1, 1];
+        let segment_199 = [201u8; 199 * 8];
+
+        write_segment_table(&mut buf, &[&segment_0]).unwrap();
+        assert_eq!(
+            &[
+                0, 0, 0, 0, // 1 segments
+                0, 0, 0, 0
+            ], // 0 length
+            &buf[..]
+        );
+        buf.clear();
+
+        write_segment_table(&mut buf, &[&segment_1]).unwrap();
+        assert_eq!(
+            &[
+                0, 0, 0, 0, // 1 segments
+                1, 0, 0, 0
+            ], // 1 length
+            &buf[..]
+        );
+        buf.clear();
+
+        write_segment_table(&mut buf, &[&segment_199]).unwrap();
+        assert_eq!(
+            &[
+                0, 0, 0, 0, // 1 segments
+                199, 0, 0, 0
+            ], // 199 length
+            &buf[..]
+        );
+        buf.clear();
+
+        write_segment_table(&mut buf, &[&segment_0, &segment_1]).unwrap();
+        assert_eq!(
+            &[
+                1, 0, 0, 0, // 2 segments
+                0, 0, 0, 0, // 0 length
+                1, 0, 0, 0, // 1 length
+                0, 0, 0, 0
+            ], // padding
+            &buf[..]
+        );
+        buf.clear();
+
+        write_segment_table(
+            &mut buf,
+            &[&segment_199, &segment_1, &segment_199, &segment_0],
+        )
+        .unwrap();
+        assert_eq!(
+            &[
+                3, 0, 0, 0, // 4 segments
+                199, 0, 0, 0, // 199 length
+                1, 0, 0, 0, // 1 length
+                199, 0, 0, 0, // 199 length
+                0, 0, 0, 0, // 0 length
+                0, 0, 0, 0
+            ], // padding
+            &buf[..]
+        );
+        buf.clear();
+
+        write_segment_table(
+            &mut buf,
+            &[
+                &segment_199,
+                &segment_1,
+                &segment_199,
+                &segment_0,
+                &segment_1,
+            ],
+        )
+        .unwrap();
+        assert_eq!(
+            &[
+                4, 0, 0, 0, // 5 segments
+                199, 0, 0, 0, // 199 length
+                1, 0, 0, 0, // 1 length
+                199, 0, 0, 0, // 199 length
+                0, 0, 0, 0, // 0 length
+                1, 0, 0, 0
+            ], // 1 length
+            &buf[..]
+        );
+        buf.clear();
+    }
+
+    quickcheck! {
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_round_trip(segments: Vec<Vec<crate::Word>>) -> TestResult {
+            if segments.is_empty() { return TestResult::discard(); }
+            let mut buf: Vec<u8> = Vec::new();
+
+            write_message_segments(&mut buf, &segments);
+            let message = read_message(&mut &buf[..], message::ReaderOptions::new()).unwrap();
+            let result_segments = message.into_segments();
+
+            TestResult::from_bool(segments.iter().enumerate().all(|(i, segment)| {
+                crate::Word::words_to_bytes(&segment[..]) == result_segments.get_segment(i as u32).unwrap()
+            }))
+        }
+
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_round_trip_slice_segments(segments: Vec<Vec<crate::Word>>) -> TestResult {
+            if segments.is_empty() { return TestResult::discard(); }
+            let borrowed_segments: &[&[u8]] = &segments.iter()
+                .map(|segment| crate::Word::words_to_bytes(&segment[..]))
+                .collect::<Vec<_>>()[..];
+            let words = flatten_segments(borrowed_segments);
+            let mut word_slice = &words[..];
+            let message = read_message_from_flat_slice(&mut word_slice, message::ReaderOptions::new()).unwrap();
+            assert!(word_slice.is_empty());  // no remaining words
+            let result_segments = message.into_segments();
+
+            TestResult::from_bool(segments.iter().enumerate().all(|(i, segment)| {
+                crate::Word::words_to_bytes(&segment[..]) == result_segments.get_segment(i as u32).unwrap()
+            }))
+        }
+    }
+
+    #[test]
+    fn read_message_from_flat_slice_with_remainder() {
+        let segments = vec![
+            vec![123, 0, 0, 0, 0, 0, 0, 0],
+            vec![4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0],
+        ];
+
+        let borrowed_segments: &[&[u8]] = &segments
+            .iter()
+            .map(|segment| &segment[..])
+            .collect::<Vec<_>>()[..];
+
+        let mut bytes = flatten_segments(borrowed_segments);
+        let extra_bytes: &[u8] = &[9, 9, 9, 9, 9, 9, 9, 9, 8, 7, 6, 5, 4, 3, 2, 1];
+        for &b in extra_bytes {
+            bytes.push(b);
+        }
+        let mut byte_slice = &bytes[..];
+        let message =
+            read_message_from_flat_slice(&mut byte_slice, message::ReaderOptions::new()).unwrap();
+        assert_eq!(byte_slice, extra_bytes);
+        let result_segments = message.into_segments();
+        for (idx, segment) in segments.iter().enumerate() {
+            assert_eq!(
+                *segment,
+                result_segments
+                    .get_segment(idx as u32)
+                    .expect("segment should exist")
+            );
+        }
+    }
+
+    #[test]
+    fn read_message_from_flat_slice_too_short() {
+        let segments = vec![
+            vec![1, 0, 0, 0, 0, 0, 0, 0],
+            vec![2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],
+        ];
+
+        let borrowed_segments: &[&[u8]] = &segments
+            .iter()
+            .map(|segment| &segment[..])
+            .collect::<Vec<_>>()[..];
+
+        let mut bytes = flatten_segments(borrowed_segments);
+        while !bytes.is_empty() {
+            bytes.pop();
+            assert!(
+                read_message_from_flat_slice(&mut &bytes[..], message::ReaderOptions::new())
+                    .is_err()
+            );
+        }
+    }
+
+    #[test]
+    fn compute_serialized_size() {
+        const LIST_LENGTH_IN_WORDS: u32 = 5;
+        let mut m = message::Builder::new_default();
+        {
+            let root: crate::any_pointer::Builder = m.init_root();
+            let _list_builder: crate::primitive_list::Builder<u64> =
+                root.initn_as(LIST_LENGTH_IN_WORDS);
+        }
+
+        // The message body has a list pointer (one word) and the list (LIST_LENGTH_IN_WORDS words).
+        // The message has one segment, so the header is one word.
+        assert_eq!(
+            super::compute_serialized_size_in_words(&m) as u32,
+            1 + 1 + LIST_LENGTH_IN_WORDS
+        )
+    }
+}
diff --git a/rust/capnp/serialize/no_alloc_buffer_segments.rs b/rust/capnp/serialize/no_alloc_buffer_segments.rs
new file mode 100644
index 000000000000..d3837738d702
--- /dev/null
+++ b/rust/capnp/serialize/no_alloc_buffer_segments.rs
@@ -0,0 +1,627 @@
+use core::convert::TryInto;
+
+use crate::message::ReaderOptions;
+use crate::message::ReaderSegments;
+use crate::private::units::BYTES_PER_WORD;
+use crate::{Error, ErrorKind, Result};
+use core::ops::Deref;
+
+use super::SEGMENTS_COUNT_LIMIT;
+
+const U32_LEN_IN_BYTES: usize = core::mem::size_of::<u32>();
+
+struct ReadSegmentTableResult {
+    segments_count: usize,
+    segment_table_length_bytes: usize,
+    total_segments_length_bytes: usize,
+}
+
+fn read_segment_table(slice: &[u8], options: ReaderOptions) -> Result<ReadSegmentTableResult> {
+    let mut remaining = slice;
+
+    verify_alignment(remaining.as_ptr())?;
+
+    let segments_count = u32_to_segments_count(read_u32_le(&mut remaining)?)?;
+
+    if segments_count >= SEGMENTS_COUNT_LIMIT {
+        return Err(Error::from_kind(ErrorKind::InvalidNumberOfSegments(
+            segments_count,
+        )));
+    }
+
+    let mut total_segments_length_bytes = 0_usize;
+
+    for _ in 0..segments_count {
+        let segment_length_in_bytes = u32_to_segment_length_bytes(read_u32_le(&mut remaining)?)?;
+
+        total_segments_length_bytes = total_segments_length_bytes
+            .checked_add(segment_length_in_bytes)
+            .ok_or_else(|| Error::from_kind(ErrorKind::MessageSizeOverflow))?;
+    }
+
+    // Don't accept a message which the receiver couldn't possibly traverse without hitting the
+    // traversal limit. Without this check, a malicious client could transmit a very large segment
+    // size to make the receiver allocate excessive space and possibly crash.
+    if let Some(limit) = options.traversal_limit_in_words {
+        let total_segments_length_words = total_segments_length_bytes / 8;
+        if total_segments_length_words > limit {
+            return Err(Error::from_kind(ErrorKind::MessageTooLarge(
+                total_segments_length_words,
+            )));
+        }
+    }
+
+    // If number of segments is even, header length will not be aligned by 8, we need to consume
+    // padding from the remainder of the message
+    if segments_count % 2 == 0 {
+        let _padding = read_u32_le(&mut remaining)?;
+    }
+
+    let expected_data_offset = calculate_data_offset(segments_count)
+        .ok_or_else(|| Error::from_kind(ErrorKind::MessageSizeOverflow))?;
+
+    let consumed_bytes = slice.len() - remaining.len();
+
+    assert_eq!(
+        expected_data_offset, consumed_bytes,
+        "Expected header size and actual header size must match, otherwise we have a bug in this code"
+    );
+
+    // If data section of the message is smaller than calculated total segments length, the message
+    // is malformed. It looks like it's ok to have extra bytes in the end, according to
+    // of `SliceSegments` implementation.
+    if remaining.len() < total_segments_length_bytes {
+        return Err(Error::from_kind(ErrorKind::MessageEndsPrematurely(
+            total_segments_length_bytes / BYTES_PER_WORD,
+            remaining.len() / BYTES_PER_WORD,
+        )));
+    }
+
+    Ok(ReadSegmentTableResult {
+        segments_count,
+        segment_table_length_bytes: expected_data_offset,
+        total_segments_length_bytes,
+    })
+}
+
+/// Alias for the common case where the buffer in `NoAllocBufferSegments` is a u8 slice.
+pub type NoAllocSliceSegments<'b> = NoAllocBufferSegments<&'b [u8]>;
+
+enum NoAllocBufferSegmentType {
+    SingleSegment(usize, usize),
+    MultipleSegments,
+}
+
+/// `NoAllocBufferSegments` is similar to [`crate::serialize::BufferSegments`] but optimized for
+/// low memory embedded environment. It does not do heap allocations.
+///
+/// # Performance considerations
+///
+/// Due to lack of heap allocations, `NoAllocBufferSegments` does not cache segments offset and
+/// length and has to parse message header every time `NoAllocBufferSegments::get_segment` is called.
+/// The parsing has O(N) complexity where N is total number of segments in the message.
+/// `NoAllocBufferSegments` has optimization for single segment messages: if message has only one
+/// segment, it will be parsed only once during creation and no parsing will be required on `get_segment` calls
+pub struct NoAllocBufferSegments<T> {
+    buffer: T,
+    segment_type: NoAllocBufferSegmentType,
+}
+
+impl<'b> NoAllocBufferSegments<&'b [u8]> {
+    /// Reads a serialized message (including a segment table) from a buffer and takes ownership, without copying.
+    /// The buffer is allowed to extend beyond the end of the message. On success, updates `slice` to point
+    /// to the remaining bytes beyond the end of the message.
+    ///
+    /// ALIGNMENT: If the "unaligned" feature is enabled, then there are no alignment requirements on `buffer`.
+    /// Otherwise, `buffer` must be 8-byte aligned (attempts to read the message will trigger errors).
+    pub fn from_slice(slice: &mut &'b [u8], options: ReaderOptions) -> Result<Self> {
+        let segment_table_info = read_segment_table(slice, options)?;
+
+        let message_length = segment_table_info.segment_table_length_bytes
+            + segment_table_info.total_segments_length_bytes;
+
+        let message = &slice[..message_length];
+        *slice = &slice[message_length..];
+
+        if segment_table_info.segments_count == 1 {
+            Ok(Self {
+                buffer: message,
+                segment_type: NoAllocBufferSegmentType::SingleSegment(
+                    segment_table_info.segment_table_length_bytes,
+                    message_length,
+                ),
+            })
+        } else {
+            Ok(Self {
+                buffer: message,
+                segment_type: NoAllocBufferSegmentType::MultipleSegments,
+            })
+        }
+    }
+}
+
+impl<T: Deref<Target = [u8]>> NoAllocBufferSegments<T> {
+    /// Reads a serialized message (including a segment table) from a buffer and takes ownership, without copying.
+    /// The buffer is allowed to extend beyond the end of the message.
+    ///
+    /// ALIGNMENT: If the "unaligned" feature is enabled, then there are no alignment requirements on `buffer`.
+    /// Otherwise, `buffer` must be 8-byte aligned (attempts to read the message will trigger errors).
+    pub fn from_buffer(buffer: T, options: ReaderOptions) -> Result<Self> {
+        let segment_table_info = read_segment_table(&buffer, options)?;
+        let message_length = segment_table_info.segment_table_length_bytes
+            + segment_table_info.total_segments_length_bytes;
+
+        if segment_table_info.segments_count == 1 {
+            Ok(Self {
+                buffer,
+                segment_type: NoAllocBufferSegmentType::SingleSegment(
+                    segment_table_info.segment_table_length_bytes,
+                    message_length,
+                ),
+            })
+        } else {
+            Ok(Self {
+                buffer,
+                segment_type: NoAllocBufferSegmentType::MultipleSegments,
+            })
+        }
+    }
+}
+
+impl<T: Deref<Target = [u8]>> ReaderSegments for NoAllocBufferSegments<T> {
+    fn get_segment(&self, idx: u32) -> Option<&[u8]> {
+        // panic safety: we are doing a lot of `unwrap` here. We assume that underlying message slice
+        // holds valid capnp message - we already verified slice in read_segment_table(),
+        // so these unwraps are not expected to panic unless we have bug in the code.
+
+        let idx: usize = idx.try_into().unwrap();
+
+        match self.segment_type {
+            NoAllocBufferSegmentType::SingleSegment(start, end) => {
+                if idx == 0 {
+                    Some(&self.buffer[start..end])
+                } else {
+                    None
+                }
+            }
+            NoAllocBufferSegmentType::MultipleSegments => {
+                let mut buf = &*self.buffer;
+
+                let segments_count = u32_to_segments_count(read_u32_le(&mut buf).unwrap()).unwrap();
+
+                if idx >= segments_count {
+                    return None;
+                }
+
+                let mut segment_offset = calculate_data_offset(segments_count).unwrap();
+
+                for _ in 0..idx {
+                    segment_offset = segment_offset
+                        .checked_add(
+                            u32_to_segment_length_bytes(read_u32_le(&mut buf).unwrap()).unwrap(),
+                        )
+                        .unwrap();
+                }
+
+                let segment_length =
+                    u32_to_segment_length_bytes(read_u32_le(&mut buf).unwrap()).unwrap();
+
+                Some(&self.buffer[segment_offset..(segment_offset + segment_length)])
+            }
+        }
+    }
+
+    fn len(&self) -> usize {
+        // panic safety: we are doing a lot of `unwrap` here. We assume that underlying message slice
+        // holds valid capnp message - we already verified slice in read_segment_table(),
+
+        match self.segment_type {
+            NoAllocBufferSegmentType::SingleSegment { .. } => 1,
+            NoAllocBufferSegmentType::MultipleSegments => {
+                u32_to_segments_count(read_u32_le(&mut &*self.buffer).unwrap()).unwrap()
+            }
+        }
+    }
+}
+
+/// Verifies whether pointer meets alignment requirements
+///
+/// If crate is compiled with "unaligned" feature, then this function does nothing since
+/// there are no alignment requirements in this mode.
+///
+/// If crate was not compiled with "unaligned" feature, it will verify that pointer is aligned
+/// by WORD boundary.
+fn verify_alignment(ptr: *const u8) -> Result<()> {
+    if cfg!(feature = "unaligned") {
+        return Ok(());
+    }
+
+    if ptr.align_offset(BYTES_PER_WORD) == 0 {
+        Ok(())
+    } else {
+        Err(Error::from_kind(
+            ErrorKind::MessageNotAlignedBy8BytesBoundary,
+        ))
+    }
+}
+
+/// Reads u32 little endian value from the front of the slice and truncates processed bytes
+/// Returns Error if there are not enough bytes to read u32
+fn read_u32_le(slice: &mut &[u8]) -> Result<u32> {
+    if slice.len() < U32_LEN_IN_BYTES {
+        return Err(Error::from_kind(ErrorKind::MessageEndsPrematurely(
+            U32_LEN_IN_BYTES,
+            slice.len(),
+        )));
+    }
+
+    // Panic safety: we just confirmed that `slice` has at least `U32_LEN_IN_BYTES` so nothing
+    // here should panic
+    let u32_buf: [u8; U32_LEN_IN_BYTES] = slice[..U32_LEN_IN_BYTES].try_into().unwrap();
+    *slice = &slice[U32_LEN_IN_BYTES..];
+
+    Ok(u32::from_le_bytes(u32_buf))
+}
+
+/// Converts 32 bit value which represents encoded segments count in header to usize segment count
+fn u32_to_segments_count(val: u32) -> Result<usize> {
+    // This conversion can fail on 8 or 16 bit machines.
+    let result: Option<usize> = val.try_into().ok();
+
+    // According to encoding schema, segments count is encoded as (count - 1), where 0 means one
+    // segment, 1 - two segments and so on, so we need to add +1 to value read from the stream.
+    // We need to do +1 to value read from the stream.
+    let result = result.and_then(|v: usize| v.checked_add(1));
+
+    result.ok_or_else(|| Error::from_kind(ErrorKind::FourByteLengthTooBigForUSize))
+}
+
+/// Converts 32 bit vlaue which represents encoded segment length to usize segment length in bytes
+fn u32_to_segment_length_bytes(val: u32) -> Result<usize> {
+    // This convertion can fail on 8 or 16 bit machines.
+    let length_in_words: Option<usize> = val.try_into().ok();
+
+    let length_in_bytes = length_in_words.and_then(|l| l.checked_mul(BYTES_PER_WORD));
+
+    length_in_bytes.ok_or_else(|| Error::from_kind(ErrorKind::FourByteSegmentLengthTooBigForUSize))
+}
+
+/// Calculates expected offset of the message data (beginning of first segment)
+/// in the capnp message.
+/// Message data comes right after message header and potential padding
+///
+/// Returns None if it's impossible to calculate offset without arithmentic overflow of usize or
+/// if segments count is invalid
+fn calculate_data_offset(segments_count: usize) -> Option<usize> {
+    // Message data goes right after message header.
+    // Message header has following format:
+    //
+    // Segment count (u32)
+    // Segments length (u32 per each segment)
+    // Padding to align header size by 8 bytes (it will be either 0 bytes or 4 bytes)
+
+    // It should be impossible to have properly encoded message with 0 segments
+    if segments_count == 0 {
+        return None;
+    }
+
+    let mut data_offset = 0_usize;
+
+    {
+        // 4 bytes encoded segments count
+        let segments_count_len = U32_LEN_IN_BYTES;
+        data_offset = data_offset.checked_add(segments_count_len)?;
+    }
+
+    {
+        // 4 bytes per each segment
+        let segments_lengt_len = segments_count.checked_mul(U32_LEN_IN_BYTES)?;
+        data_offset = data_offset.checked_add(segments_lengt_len)?;
+    }
+
+    // Message data must be aligned by 8 bytes. If there was even number of segments, then
+    // header size will not be aligned by 8, in this case we have to add 4 byte padding to make
+    // data offset aligned by 8.
+    let padding_len = match data_offset % BYTES_PER_WORD {
+        0 => 0,
+        4 => 4,
+        _ => unreachable!(
+            "Mis-alignment by anything other than 4 should be impossible, this is a bug"
+        ),
+    };
+
+    data_offset = data_offset.checked_add(padding_len)?;
+
+    // It's a sanity check to ensure that message offset has correct alignment
+    assert_eq!(
+        data_offset % BYTES_PER_WORD,
+        0,
+        "data_offset after adding panic must be aligned by 8. \
+            If it's not, it's a bug"
+    );
+
+    Some(data_offset)
+}
+
+#[cfg(test)]
+mod tests {
+    #[cfg(feature = "alloc")]
+    use quickcheck::{quickcheck, TestResult};
+
+    use super::calculate_data_offset;
+    #[cfg(feature = "alloc")]
+    use crate::{
+        message::{ReaderOptions, ReaderSegments},
+        serialize, word, Word,
+    };
+
+    #[cfg(feature = "alloc")]
+    use crate::OutputSegments;
+
+    use super::{
+        read_u32_le, u32_to_segment_length_bytes, u32_to_segments_count, verify_alignment,
+    };
+    #[cfg(feature = "alloc")]
+    use super::{NoAllocBufferSegmentType, NoAllocBufferSegments, NoAllocSliceSegments};
+
+    #[cfg(feature = "alloc")]
+    use alloc::vec::Vec;
+
+    #[repr(align(8))]
+    struct Aligned([u8; 8]);
+
+    #[cfg(feature = "unaligned")]
+    #[test]
+    fn test_verify_alignment_unaligned_mode() {
+        // To run this test do
+        // `% cargo test --features unaligned`
+
+        // make sure there is no padding
+        assert_eq!(core::mem::size_of::<Aligned>(), 8);
+
+        let aligned = Aligned([0; 8]);
+
+        // no alignment requirements in "unaligned" mode
+        for idx in 0..8 {
+            verify_alignment(unsafe { aligned.0.as_ptr().add(idx) }).unwrap();
+        }
+    }
+
+    #[cfg(not(feature = "unaligned"))]
+    #[test]
+    fn test_verify_alignment() {
+        // make sure there is no padding
+        assert_eq!(core::mem::size_of::<Aligned>(), 8);
+
+        let aligned = Aligned([0; 8]);
+
+        verify_alignment(aligned.0.as_ptr()).unwrap();
+        for idx in 1..8 {
+            verify_alignment(unsafe { aligned.0.as_ptr().add(idx) }).unwrap_err();
+        }
+    }
+
+    #[test]
+    fn test_read_u32_le() {
+        let buffer = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08];
+        let mut buffer_remaining = &buffer[..];
+
+        assert_eq!(read_u32_le(&mut buffer_remaining).unwrap(), 0x04030201);
+        assert_eq!(buffer_remaining, &buffer[4..]);
+    }
+
+    #[test]
+    fn test_read_u32_le_truncated() {
+        let buffer = [0x01, 0x02, 0x03];
+        let mut buffer_remaining = &buffer[..];
+
+        read_u32_le(&mut buffer_remaining).unwrap_err();
+        assert_eq!(buffer_remaining, &buffer[..]);
+    }
+
+    #[test]
+    fn test_u32_to_segments_count() {
+        assert_eq!(u32_to_segments_count(0).unwrap(), 1);
+        assert_eq!(u32_to_segments_count(10).unwrap(), 11);
+        // There is no way to reproduce "negative" case on 64 bit machine
+    }
+
+    #[test]
+    fn test_u32_to_segment_length_bytes() {
+        assert_eq!(u32_to_segment_length_bytes(0).unwrap(), 0);
+        assert_eq!(u32_to_segment_length_bytes(123).unwrap(), 123 * 8);
+    }
+
+    #[test]
+    fn test_calculate_data_offset_no_padding() {
+        assert_eq!(calculate_data_offset(0), None);
+
+        assert_eq!(calculate_data_offset(1), Some(8));
+
+        assert_eq!(calculate_data_offset(2), Some(16));
+        assert_eq!(calculate_data_offset(3), Some(16));
+
+        assert_eq!(calculate_data_offset(100), Some(408));
+        assert_eq!(calculate_data_offset(101), Some(408));
+    }
+
+    #[cfg(feature = "alloc")]
+    quickcheck! {
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_no_alloc_buffer_segments_single_segment_optimization(
+            segment_0 : Vec<Word>) -> TestResult
+        {
+            let words = &segment_0[..];
+            let bytes = Word::words_to_bytes(words);
+            let output_segments = OutputSegments::SingleSegment([bytes]);
+            let mut msg = vec![];
+
+            serialize::write_message_segments(&mut msg, &output_segments).unwrap();
+
+            let no_alloc_segments =
+                NoAllocSliceSegments::from_slice(&mut msg.as_slice(), ReaderOptions::new()).unwrap();
+
+            assert!(matches!(
+                no_alloc_segments,
+                NoAllocBufferSegments { buffer: _,
+                                        segment_type : NoAllocBufferSegmentType::SingleSegment { .. },
+                }
+            ));
+
+            assert_eq!(no_alloc_segments.len(), 1);
+            assert_eq!(no_alloc_segments.get_segment(0), Some(bytes));
+            assert_eq!(no_alloc_segments.get_segment(1), None);
+            TestResult::from_bool(true)
+        }
+
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_no_alloc_buffer_segments_multiple_segments(segments_vec: Vec<Vec<Word>>) -> TestResult {
+            if segments_vec.is_empty() { return TestResult::discard() };
+
+            let segments: Vec<_> = segments_vec.iter().map(|s|
+                                                           Word::words_to_bytes(s.as_slice())).collect();
+
+            let output_segments = OutputSegments::MultiSegment(segments.clone());
+
+            let mut msg = vec![];
+
+            serialize::write_message_segments(&mut msg, &output_segments).unwrap();
+
+            let no_alloc_segments =
+                NoAllocSliceSegments::from_slice(&mut msg.as_slice(), ReaderOptions::new()).unwrap();
+
+            assert_eq!(no_alloc_segments.len(), segments.len());
+            for (i, segment) in segments.iter().enumerate() {
+                assert_eq!(no_alloc_segments.get_segment(i as u32), Some(*segment));
+            }
+
+            assert_eq!(
+                no_alloc_segments.get_segment(no_alloc_segments.len() as u32),
+                None
+            );
+            TestResult::from_bool(true)
+        }
+    }
+
+    #[cfg(feature = "alloc")]
+    #[test]
+    fn test_no_alloc_buffer_segments_message_postfix() {
+        let output_segments = OutputSegments::SingleSegment([&[1, 2, 3, 4, 5, 6, 7, 8]]);
+        let mut buf = Word::allocate_zeroed_vec(2);
+        serialize::write_message_segments(Word::words_to_bytes_mut(&mut buf), &output_segments)
+            .unwrap();
+        buf.push(word(11, 12, 13, 14, 15, 16, 0, 0));
+
+        let remaining = &mut Word::words_to_bytes(&buf);
+        NoAllocSliceSegments::from_slice(remaining, ReaderOptions::new()).unwrap();
+
+        // Confirm that slice pointer was advanced to data past first message
+        assert_eq!(*remaining, &[11, 12, 13, 14, 15, 16, 0, 0]);
+    }
+
+    #[cfg(feature = "alloc")]
+    #[test]
+    fn test_no_alloc_buffer_segments_message_invalid() {
+        let mut buf = vec![];
+
+        buf.extend([0, 2, 0, 0]); // 513 segments
+        buf.extend([0; 513 * 8]);
+        assert!(NoAllocSliceSegments::from_slice(&mut &buf[..], ReaderOptions::new()).is_err());
+        buf.clear();
+
+        buf.extend([0, 0, 0, 0]); // 1 segments
+        assert!(NoAllocSliceSegments::from_slice(&mut &buf[..], ReaderOptions::new()).is_err());
+        buf.clear();
+
+        buf.extend([0, 0, 0, 0]); // 1 segments
+        buf.extend([0; 3]);
+        assert!(NoAllocSliceSegments::from_slice(&mut &buf[..], ReaderOptions::new()).is_err());
+        buf.clear();
+
+        buf.extend([255, 255, 255, 255]); // 0 segments
+        assert!(NoAllocSliceSegments::from_slice(&mut &buf[..], ReaderOptions::new()).is_err());
+        buf.clear();
+    }
+
+    #[cfg(feature = "alloc")]
+    quickcheck! {
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_no_alloc_buffer_segments_message_truncated(segments_vec: Vec<Vec<Word>>) -> TestResult {
+            if segments_vec.is_empty() { return TestResult::discard() }
+
+            let segments: Vec<_> = segments_vec.iter()
+                .map(|s| Word::words_to_bytes(s.as_slice())).collect();
+
+            let output_segments = OutputSegments::MultiSegment(segments.clone());
+
+            let mut msg = vec![];
+
+            serialize::write_message_segments(&mut msg, &output_segments).unwrap();
+
+            // Lop off the final element.
+            msg.pop().unwrap();
+
+            let no_alloc_segments =
+                NoAllocSliceSegments::from_slice(&mut msg.as_slice(), ReaderOptions::new());
+
+            assert!(no_alloc_segments.is_err());
+            TestResult::from_bool(true)
+        }
+
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_no_alloc_buffer_segments_message_options_limit(
+            segments_vec: Vec<Vec<Word>>) -> TestResult
+        {
+            let mut word_count = 0;
+            let segments: Vec<_> = segments_vec.iter()
+                .map(|s| {
+                    let ws = Word::words_to_bytes(s.as_slice());
+                    word_count += s.len();
+                    ws
+                }).collect();
+            if word_count == 0 { return TestResult::discard() };
+
+            let output_segments = OutputSegments::MultiSegment(segments.clone());
+
+            let mut msg = vec![];
+
+            serialize::write_message_segments(&mut msg, &output_segments).unwrap();
+
+            let mut options = ReaderOptions::new();
+            options.traversal_limit_in_words(Some(word_count));
+
+            let _no_alloc_segments =
+                NoAllocSliceSegments::from_slice(&mut msg.as_slice(), options).unwrap();
+
+            let mut options = ReaderOptions::new();
+            options.traversal_limit_in_words(Some(word_count - 1));
+
+            let no_alloc_segments = NoAllocSliceSegments::from_slice(&mut msg.as_slice(), options);
+
+            assert!(no_alloc_segments.is_err());
+            TestResult::from_bool(true)
+        }
+
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_no_alloc_buffer_segments_bad_alignment(segment_0: Vec<Word>) -> TestResult {
+            if segment_0.is_empty() { return TestResult::discard(); }
+            let output_segments = OutputSegments::SingleSegment([Word::words_to_bytes(&segment_0)]);
+
+            let mut msg = vec![];
+
+            serialize::write_message_segments(&mut msg, &output_segments).unwrap();
+            // mis-align buffer by 1 byte
+            msg.insert(0_usize, 0_u8);
+
+            let no_alloc_segments = NoAllocSliceSegments::from_slice(&mut &msg[1..], ReaderOptions::new());
+
+            if cfg!(feature = "unaligned") {
+                // If we build with "unaligned" feature, alignment requirements should not be enforced
+                no_alloc_segments.unwrap();
+            } else {
+                assert!(no_alloc_segments.is_err());
+            }
+            TestResult::from_bool(true)
+        }
+    }
+}
diff --git a/rust/capnp/serialize_packed.rs b/rust/capnp/serialize_packed.rs
new file mode 100644
index 000000000000..286a36950981
--- /dev/null
+++ b/rust/capnp/serialize_packed.rs
@@ -0,0 +1,618 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! Reading and writing of messages using the
+//! [packed stream encoding](https://capnproto.org/encoding.html#packing).
+
+use crate::io::{BufRead, Read, Write};
+use core::{mem, ptr, slice};
+
+#[cfg(feature = "alloc")]
+use crate::message;
+#[cfg(feature = "alloc")]
+use crate::serialize;
+use crate::{Error, ErrorKind, Result};
+
+/// A `BufRead` wrapper that unpacks packed data. Returns an error on any `read()`
+/// call that would end within an all-zero (tag 0x00) or uncompressed (tag 0xff)
+/// run of words. Calls that come from `serialize_packed::read_message()` and
+/// `serialize_packed::try_read_message()` always mirror `write()` calls from
+/// `serialize_packed::write_message()`, so they always safely span such runs.
+struct PackedRead<R>
+where
+    R: BufRead,
+{
+    inner: R,
+}
+
+impl<R> PackedRead<R>
+where
+    R: BufRead,
+{
+    fn get_read_buffer(&mut self) -> Result<(*const u8, *const u8)> {
+        let buf = self.inner.fill_buf()?;
+        Ok((buf.as_ptr(), buf.as_ptr().wrapping_add(buf.len())))
+    }
+}
+
+#[inline]
+fn ptr_sub<T>(p1: *const T, p2: *const T) -> usize {
+    (p1 as usize - p2 as usize) / mem::size_of::<T>()
+}
+
+macro_rules! refresh_buffer(
+    ($this:expr, $size:ident, $in_ptr:ident, $in_end:ident, $out:ident,
+     $outBuf:ident, $buffer_begin:ident) => (
+        {
+            $this.inner.consume($size);
+            let (b, e) = $this.get_read_buffer()?;
+            $in_ptr = b;
+            $in_end = e;
+            $size = ptr_sub($in_end, $in_ptr);
+            $buffer_begin = b;
+            if $size == 0 {
+                return Err(Error::from_kind(ErrorKind::PrematureEndOfPackedInput));
+            }
+        }
+        );
+    );
+
+impl<R> Read for PackedRead<R>
+where
+    R: BufRead,
+{
+    fn read(&mut self, out_buf: &mut [u8]) -> Result<usize> {
+        let len = out_buf.len();
+        if len == 0 {
+            return Ok(0);
+        }
+
+        assert!(len % 8 == 0, "PackedRead reads must be word-aligned.");
+
+        unsafe {
+            let out_buf_start = out_buf.as_mut_ptr();
+            let mut out = out_buf_start;
+            let out_end: *mut u8 = out.wrapping_add(len);
+
+            let (mut in_ptr, mut in_end) = self.get_read_buffer()?;
+            let mut buffer_begin = in_ptr;
+            let mut size = ptr_sub(in_end, in_ptr);
+            if size == 0 {
+                return Ok(0);
+            }
+
+            loop {
+                let tag: u8;
+
+                assert_eq!(
+                    ptr_sub(out, out_buf_start) % 8,
+                    0,
+                    "Output pointer should always be aligned here."
+                );
+
+                if ptr_sub(in_end, in_ptr) < 10 {
+                    if ptr_sub(in_end, in_ptr) == 0 {
+                        refresh_buffer!(self, size, in_ptr, in_end, out, out_buf, buffer_begin);
+                        continue;
+                    }
+
+                    //# We have at least 1, but not 10, bytes available. We need to read
+                    //# slowly, doing a bounds check on each byte.
+
+                    tag = *in_ptr;
+                    in_ptr = in_ptr.offset(1);
+
+                    for i in 0..8 {
+                        if (tag & (1u8 << i)) != 0 {
+                            if ptr_sub(in_end, in_ptr) == 0 {
+                                refresh_buffer!(
+                                    self,
+                                    size,
+                                    in_ptr,
+                                    in_end,
+                                    out,
+                                    out_buf,
+                                    buffer_begin
+                                );
+                            }
+                            *out = *in_ptr;
+                            out = out.offset(1);
+                            in_ptr = in_ptr.offset(1);
+                        } else {
+                            *out = 0;
+                            out = out.offset(1);
+                        }
+                    }
+
+                    if ptr_sub(in_end, in_ptr) == 0 && (tag == 0 || tag == 0xff) {
+                        refresh_buffer!(self, size, in_ptr, in_end, out, out_buf, buffer_begin);
+                    }
+                } else {
+                    tag = *in_ptr;
+                    in_ptr = in_ptr.offset(1);
+
+                    for n in 0..8 {
+                        let is_nonzero = (tag & (1u8 << n)) != 0;
+                        *out = (*in_ptr) & ((-i8::from(is_nonzero)) as u8);
+                        out = out.offset(1);
+                        in_ptr = in_ptr.offset(isize::from(is_nonzero));
+                    }
+                }
+                if tag == 0 {
+                    assert!(
+                        ptr_sub(in_end, in_ptr) > 0,
+                        "Should always have non-empty buffer here."
+                    );
+
+                    let run_length: usize = (*in_ptr) as usize * 8;
+                    in_ptr = in_ptr.offset(1);
+
+                    if run_length > ptr_sub(out_end, out) {
+                        return Err(Error::from_kind(
+                            ErrorKind::PackedInputDidNotEndCleanlyOnASegmentBoundary,
+                        ));
+                    }
+
+                    ptr::write_bytes(out, 0, run_length);
+                    out = out.add(run_length);
+                } else if tag == 0xff {
+                    assert!(
+                        ptr_sub(in_end, in_ptr) > 0,
+                        "Should always have non-empty buffer here"
+                    );
+
+                    let mut run_length: usize = (*in_ptr) as usize * 8;
+                    in_ptr = in_ptr.offset(1);
+
+                    if run_length > ptr_sub(out_end, out) {
+                        return Err(Error::from_kind(
+                            ErrorKind::PackedInputDidNotEndCleanlyOnASegmentBoundary,
+                        ));
+                    }
+
+                    let in_remaining = ptr_sub(in_end, in_ptr);
+                    if in_remaining >= run_length {
+                        //# Fast path.
+                        ptr::copy_nonoverlapping(in_ptr, out, run_length);
+                        out = out.add(run_length);
+                        in_ptr = in_ptr.add(run_length);
+                    } else {
+                        //# Copy over the first buffer, then do one big read for the rest.
+                        ptr::copy_nonoverlapping(in_ptr, out, in_remaining);
+                        out = out.add(in_remaining);
+                        run_length -= in_remaining;
+
+                        self.inner.consume(size);
+                        {
+                            let buf = slice::from_raw_parts_mut::<u8>(out, run_length);
+                            self.inner.read_exact(buf)?;
+                        }
+
+                        out = out.add(run_length);
+
+                        if out == out_end {
+                            return Ok(len);
+                        } else {
+                            let (b, e) = self.get_read_buffer()?;
+                            in_ptr = b;
+                            in_end = e;
+                            size = ptr_sub(e, b);
+                            buffer_begin = in_ptr;
+                            continue;
+                        }
+                    }
+                }
+
+                if out == out_end {
+                    self.inner.consume(ptr_sub(in_ptr, buffer_begin));
+                    return Ok(len);
+                }
+            }
+        }
+    }
+}
+
+/// Reads a packed message from a stream using the provided options.
+#[cfg(feature = "alloc")]
+pub fn read_message<R>(
+    read: R,
+    options: message::ReaderOptions,
+) -> Result<crate::message::Reader<serialize::OwnedSegments>>
+where
+    R: BufRead,
+{
+    let packed_read = PackedRead { inner: read };
+    serialize::read_message(packed_read, options)
+}
+
+/// Like read_message(), but returns None instead of an error if there are zero bytes left in `read`.
+#[cfg(feature = "alloc")]
+pub fn try_read_message<R>(
+    read: R,
+    options: message::ReaderOptions,
+) -> Result<Option<crate::message::Reader<serialize::OwnedSegments>>>
+where
+    R: BufRead,
+{
+    let packed_read = PackedRead { inner: read };
+    serialize::try_read_message(packed_read, options)
+}
+
+struct PackedWrite<W>
+where
+    W: Write,
+{
+    inner: W,
+}
+
+impl<W> Write for PackedWrite<W>
+where
+    W: Write,
+{
+    fn write_all(&mut self, in_buf: &[u8]) -> Result<()> {
+        unsafe {
+            let mut buf_idx: usize = 0;
+            let mut buf: [u8; 64] = [0; 64];
+
+            let mut in_ptr: *const u8 = in_buf.as_ptr();
+            let in_end: *const u8 = in_buf.as_ptr().wrapping_add(in_buf.len());
+
+            while in_ptr < in_end {
+                if buf_idx + 10 > buf.len() {
+                    //# Oops, we're out of space. We need at least 10
+                    //# bytes for the fast path, since we don't
+                    //# bounds-check on every byte.
+                    self.inner.write_all(&buf[..buf_idx])?;
+                    buf_idx = 0;
+                }
+
+                let tag_pos = buf_idx;
+                buf_idx += 1;
+
+                let bit0 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit0 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit1 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit1 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit2 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit2 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit3 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit3 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit4 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit4 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit5 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit5 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit6 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit6 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let bit7 = u8::from(*in_ptr != 0);
+                *buf.get_unchecked_mut(buf_idx) = *in_ptr;
+                buf_idx += bit7 as usize;
+                in_ptr = in_ptr.offset(1);
+
+                let tag: u8 = bit0
+                    | (bit1 << 1)
+                    | (bit2 << 2)
+                    | (bit3 << 3)
+                    | (bit4 << 4)
+                    | (bit5 << 5)
+                    | (bit6 << 6)
+                    | (bit7 << 7);
+
+                *buf.get_unchecked_mut(tag_pos) = tag;
+
+                if tag == 0 {
+                    //# An all-zero word is followed by a count of
+                    //# consecutive zero words (not including the first
+                    //# one).
+
+                    let mut in_word: *const [u8; 8] = in_ptr as *const [u8; 8];
+                    let mut limit: *const [u8; 8] = in_end as *const [u8; 8];
+                    if ptr_sub(limit, in_word) > 255 {
+                        limit = in_word.offset(255);
+                    }
+                    while in_word < limit && *in_word == [0; 8] {
+                        in_word = in_word.offset(1);
+                    }
+
+                    *buf.get_unchecked_mut(buf_idx) =
+                        ptr_sub(in_word, in_ptr as *const [u8; 8]) as u8;
+                    buf_idx += 1;
+                    in_ptr = in_word as *const u8;
+                } else if tag == 0xff {
+                    //# An all-nonzero word is followed by a count of
+                    //# consecutive uncompressed words, followed by the
+                    //# uncompressed words themselves.
+
+                    //# Count the number of consecutive words in the input
+                    //# which have no more than a single zero-byte. We look
+                    //# for at least two zeros because that's the point
+                    //# where our compression scheme becomes a net win.
+                    let run_start = in_ptr;
+                    let mut limit = in_end;
+                    if ptr_sub(limit, in_ptr) > 255 * 8 {
+                        limit = in_ptr.offset(255 * 8);
+                    }
+
+                    while in_ptr < limit {
+                        let mut c = 0;
+
+                        for _ in 0..8 {
+                            c += u8::from(*in_ptr == 0);
+                            in_ptr = in_ptr.offset(1);
+                        }
+
+                        if c >= 2 {
+                            //# Un-read the word with multiple zeros, since
+                            //# we'll want to compress that one.
+                            in_ptr = in_ptr.offset(-8);
+                            break;
+                        }
+                    }
+
+                    let count: usize = ptr_sub(in_ptr, run_start);
+                    *buf.get_unchecked_mut(buf_idx) = (count / 8) as u8;
+                    buf_idx += 1;
+
+                    self.inner.write_all(&buf[..buf_idx])?;
+                    buf_idx = 0;
+                    self.inner
+                        .write_all(slice::from_raw_parts::<u8>(run_start, count))?;
+                }
+            }
+
+            self.inner.write_all(&buf[..buf_idx])?;
+            Ok(())
+        }
+    }
+}
+
+/// Writes a packed message to a stream.
+///
+/// The only source of errors from this function are `write.write_all()` calls. If you pass in
+/// a writer that never returns an error, then this function will never return an error.
+#[cfg(feature = "alloc")]
+pub fn write_message<W, A>(write: W, message: &crate::message::Builder<A>) -> Result<()>
+where
+    W: Write,
+    A: crate::message::Allocator,
+{
+    let packed_write = PackedWrite { inner: write };
+    serialize::write_message(packed_write, message)
+}
+
+#[cfg(feature = "alloc")]
+#[cfg(test)]
+mod tests {
+    use alloc::vec::Vec;
+
+    use crate::io::{Read, Write};
+
+    use quickcheck::{quickcheck, TestResult};
+
+    use super::read_message;
+    use crate::message::ReaderOptions;
+    use crate::serialize::test::write_message_segments;
+    use crate::serialize_packed::{PackedRead, PackedWrite};
+    use crate::ErrorKind;
+
+    #[test]
+    pub fn premature_eof() {
+        let input_bytes: &[u8] = &[];
+        let mut packed_read = PackedRead { inner: input_bytes };
+
+        let mut output_bytes: Vec<u8> = vec![0; 8];
+        assert!(packed_read.read_exact(&mut output_bytes[..]).is_err());
+    }
+
+    pub fn check_unpacks_to(packed: &[u8], unpacked: &[u8]) {
+        let mut packed_read = PackedRead { inner: packed };
+
+        let mut bytes: Vec<u8> = vec![0; unpacked.len()];
+        packed_read.read_exact(&mut bytes[..]).unwrap();
+
+        assert!(packed_read.inner.is_empty()); // nothing left to read
+        assert_eq!(bytes, unpacked);
+    }
+
+    pub fn check_packing(unpacked: &[u8], packed: &[u8]) {
+        // --------
+        // write
+
+        let mut bytes: Vec<u8> = vec![0; packed.len()];
+        {
+            let mut packed_write = PackedWrite {
+                inner: &mut bytes[..],
+            };
+            packed_write.write_all(unpacked).unwrap();
+        }
+
+        assert_eq!(bytes, packed);
+
+        // --------
+        // read
+        check_unpacks_to(packed, unpacked);
+    }
+
+    #[test]
+    pub fn simple_packing() {
+        check_packing(&[], &[]);
+        check_packing(&[0; 8], &[0, 0]);
+        check_packing(&[0, 0, 12, 0, 0, 34, 0, 0], &[0x24, 12, 34]);
+        check_packing(
+            &[1, 3, 2, 4, 5, 7, 6, 8],
+            &[0xff, 1, 3, 2, 4, 5, 7, 6, 8, 0],
+        );
+        check_packing(
+            &[0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 2, 4, 5, 7, 6, 8],
+            &[0, 0, 0xff, 1, 3, 2, 4, 5, 7, 6, 8, 0],
+        );
+        check_packing(
+            &[0, 0, 12, 0, 0, 34, 0, 0, 1, 3, 2, 4, 5, 7, 6, 8],
+            &[0x24, 12, 34, 0xff, 1, 3, 2, 4, 5, 7, 6, 8, 0],
+        );
+        check_packing(
+            &[1, 3, 2, 4, 5, 7, 6, 8, 8, 6, 7, 4, 5, 2, 3, 1],
+            &[0xff, 1, 3, 2, 4, 5, 7, 6, 8, 1, 8, 6, 7, 4, 5, 2, 3, 1],
+        );
+
+        check_packing(
+            &[
+                1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4,
+                5, 6, 7, 8, 0, 2, 4, 0, 9, 0, 5, 1,
+            ],
+            &[
+                0xff, 1, 2, 3, 4, 5, 6, 7, 8, 3, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1,
+                2, 3, 4, 5, 6, 7, 8, 0xd6, 2, 4, 9, 5, 1,
+            ],
+        );
+        check_packing(
+            &[
+                1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 6, 2, 4, 3, 9, 0, 5, 1, 1, 2, 3, 4,
+                5, 6, 7, 8, 0, 2, 4, 0, 9, 0, 5, 1,
+            ],
+            &[
+                0xff, 1, 2, 3, 4, 5, 6, 7, 8, 3, 1, 2, 3, 4, 5, 6, 7, 8, 6, 2, 4, 3, 9, 0, 5, 1, 1,
+                2, 3, 4, 5, 6, 7, 8, 0xd6, 2, 4, 9, 5, 1,
+            ],
+        );
+
+        check_packing(
+            &[
+                8, 0, 100, 6, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 1,
+            ],
+            &[0xed, 8, 100, 6, 1, 1, 2, 0, 2, 0xd4, 1, 2, 3, 1],
+        );
+
+        check_packing(&[0; 16], &[0, 1]);
+        check_packing(
+            &[
+                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            ],
+            &[0, 2],
+        );
+    }
+
+    quickcheck! {
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_round_trip(segments: Vec<Vec<crate::Word>>) -> TestResult {
+            use crate::message::ReaderSegments;
+            if segments.is_empty() { return TestResult::discard(); }
+            let mut buf: Vec<u8> = Vec::new();
+
+            write_message_segments(&mut PackedWrite { inner: &mut buf }, &segments);
+            let message = read_message(&mut &buf[..], ReaderOptions::new()).unwrap();
+            let result_segments = message.into_segments();
+
+            TestResult::from_bool(segments.iter().enumerate().all(|(i, segment)| {
+                crate::Word::words_to_bytes(&segment[..]) == result_segments.get_segment(i as u32).unwrap()
+            }))
+        }
+
+        #[cfg_attr(miri, ignore)] // miri takes a long time with quickcheck
+        fn test_unpack(packed: Vec<u8>) -> TestResult {
+            let len = packed.len();
+            let mut packed_read = PackedRead { inner: &packed[..] };
+
+            let mut out_buffer: Vec<u8> = vec![0; len * 8];
+
+            let _ = packed_read.read_exact(&mut out_buffer);
+            TestResult::from_bool(true)
+        }
+    }
+
+    #[test]
+    fn did_not_end_cleanly_on_a_segment_boundary() {
+        let packed = &[0xff, 1, 2, 3, 4, 5, 6, 7, 8, 37, 1, 2];
+        let mut packed_read = PackedRead { inner: &packed[..] };
+
+        let mut bytes: Vec<u8> = vec![0; 200];
+        match packed_read.read_exact(&mut bytes[..]) {
+            Ok(_) => panic!("should have been an error"),
+            Err(e) => {
+                assert_eq!(
+                    e.kind,
+                    ErrorKind::PackedInputDidNotEndCleanlyOnASegmentBoundary,
+                );
+            }
+        }
+    }
+
+    #[test]
+    fn premature_end_of_packed_input() {
+        fn helper(packed: &[u8]) {
+            let mut packed_read = PackedRead { inner: packed };
+
+            let mut bytes: Vec<u8> = vec![0; 200];
+            match packed_read.read_exact(&mut bytes[..]) {
+                Ok(_) => panic!("should have been an error"),
+                Err(e) => {
+                    assert_eq!(e.kind, ErrorKind::PrematureEndOfPackedInput);
+                }
+            }
+        }
+
+        helper(&[0xf0, 1, 2]);
+        helper(&[0]);
+        helper(&[0xff, 1, 2, 3, 4, 5, 6, 7, 8]);
+
+        // In this case, the error is only due to the fact that the unpacked data does not
+        // fill up the given output buffer.
+        helper(&[1, 1]);
+    }
+
+    #[test]
+    fn packed_segment_table() {
+        let packed_buf = &[0x11, 4, 1, 0, 1, 0, 0];
+
+        check_unpacks_to(
+            packed_buf,
+            &[
+                4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+                0, 0, 0, 0,
+            ],
+        );
+
+        // At one point, this failed due to serialize::read_message()
+        // reading the segment table only one word at a time.
+        read_message(&mut &packed_buf[..], Default::default()).unwrap();
+    }
+}
diff --git a/rust/capnp/stringify.rs b/rust/capnp/stringify.rs
new file mode 100644
index 000000000000..d11bfbeb7b14
--- /dev/null
+++ b/rust/capnp/stringify.rs
@@ -0,0 +1,181 @@
+use crate::dynamic_value;
+use core::fmt::{self, Formatter};
+
+#[derive(Clone, Copy, Debug, Default)]
+pub(crate) struct Indent {
+    /// None means everything gets printed on a single line.
+    indent: Option<usize>,
+}
+
+impl Indent {
+    fn no_indent() -> Self {
+        Self { indent: None }
+    }
+
+    fn enabled() -> Self {
+        Self { indent: Some(0) }
+    }
+
+    fn next(self) -> Self {
+        match self.indent {
+            None => self,
+            Some(x) => Self {
+                indent: Some(x + 1),
+            },
+        }
+    }
+
+    fn maybe_newline(&self, formatter: &mut Formatter) -> Result<(), fmt::Error> {
+        match self.indent {
+            None => Ok(()),
+            Some(indent) => {
+                formatter.write_str("\n")?;
+                for _ in 0..indent {
+                    formatter.write_str("  ")?;
+                }
+                Ok(())
+            }
+        }
+    }
+
+    fn comma(&self, formatter: &mut Formatter) -> Result<(), fmt::Error> {
+        match self.indent {
+            None => formatter.write_str(", "),
+            Some(_) => formatter.write_str(","),
+        }
+    }
+}
+
+fn cvt<T, E>(r: core::result::Result<T, E>) -> Result<T, fmt::Error> {
+    match r {
+        Ok(v) => Ok(v),
+        Err(_) => Err(fmt::Error),
+    }
+}
+
+pub(crate) fn print(
+    value: dynamic_value::Reader,
+    formatter: &mut Formatter,
+    indent: Indent,
+) -> Result<(), fmt::Error> {
+    match value {
+        dynamic_value::Reader::Void => formatter.write_str("()"),
+        dynamic_value::Reader::Bool(b) => formatter.write_fmt(format_args!("{b}")),
+        dynamic_value::Reader::Int8(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::Int16(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::Int32(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::Int64(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::UInt8(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::UInt16(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::UInt32(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::UInt64(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::Float32(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::Float64(x) => formatter.write_fmt(format_args!("{x}")),
+        dynamic_value::Reader::Enum(e) => match cvt(e.get_enumerant())? {
+            Some(enumerant) => {
+                formatter.write_str(cvt(cvt(enumerant.get_proto().get_name())?.to_str())?)
+            }
+            None => formatter.write_fmt(format_args!("{}", e.get_value())),
+        },
+        dynamic_value::Reader::Text(t) => formatter.write_fmt(format_args!("{t:?}")),
+        dynamic_value::Reader::Data(d) => {
+            formatter.write_str("0x\"")?;
+            for b in d {
+                formatter.write_fmt(format_args!("{:02x}", *b))?;
+            }
+            formatter.write_str("\"")
+        }
+        dynamic_value::Reader::List(list) => {
+            if list.is_empty() {
+                formatter.write_str("[]")
+            } else {
+                formatter.write_str("[")?;
+                let indent2 = indent.next();
+                for (idx, value) in list.iter().enumerate() {
+                    indent2.maybe_newline(formatter)?;
+                    print(cvt(value)?, formatter, indent2)?;
+                    if idx + 1 < list.len() as usize {
+                        indent2.comma(formatter)?;
+                    }
+                }
+                indent.maybe_newline(formatter)?;
+                formatter.write_str("]")
+            }
+        }
+        dynamic_value::Reader::Struct(st) => {
+            let schema = st.get_schema();
+            let union_fields = cvt(schema.get_union_fields())?;
+            let non_union_fields = cvt(schema.get_non_union_fields())?;
+            if union_fields.len() + non_union_fields.len() == 0 {
+                return formatter.write_str("()");
+            }
+            formatter.write_str("(")?;
+            let indent2 = indent.next();
+            let mut union_field = match cvt(st.which())? {
+                None => None,
+                Some(field) => {
+                    // If it's not the default descriminant, then we always need to print it.
+                    if field.get_proto().get_discriminant_value() != 0 || cvt(st.has(field))? {
+                        Some(field)
+                    } else {
+                        None
+                    }
+                }
+            };
+            let mut first = true;
+            for field in non_union_fields {
+                if let Some(ff) = union_field {
+                    if ff.get_index() < field.get_index() {
+                        // It's time to print the union field.
+                        if first {
+                            first = false
+                        } else {
+                            indent2.comma(formatter)?;
+                        }
+                        indent2.maybe_newline(formatter)?;
+                        formatter.write_str(cvt(cvt(ff.get_proto().get_name())?.to_str())?)?;
+                        formatter.write_str(" = ")?;
+                        print(cvt(st.get(ff))?, formatter, indent2)?;
+                        union_field = None;
+                    }
+                }
+                if cvt(st.has(field))? {
+                    if first {
+                        first = false
+                    } else {
+                        indent2.comma(formatter)?;
+                    }
+                    indent2.maybe_newline(formatter)?;
+                    formatter.write_str(cvt(cvt(field.get_proto().get_name())?.to_str())?)?;
+                    formatter.write_str(" = ")?;
+                    print(cvt(st.get(field))?, formatter, indent2)?;
+                }
+            }
+            if let Some(ff) = union_field {
+                // Union field comes last.
+                if !first {
+                    indent2.comma(formatter)?;
+                }
+                indent2.maybe_newline(formatter)?;
+                formatter.write_str(cvt(cvt(ff.get_proto().get_name())?.to_str())?)?;
+                formatter.write_str(" = ")?;
+                print(cvt(st.get(ff))?, formatter, indent2)?;
+            }
+            indent.maybe_newline(formatter)?;
+            formatter.write_str(")")
+        }
+        dynamic_value::Reader::AnyPointer(_) => formatter.write_str("<opaque pointer>"),
+        dynamic_value::Reader::Capability(_) => formatter.write_str("<external capability>"),
+    }
+}
+
+impl<'a> fmt::Debug for dynamic_value::Reader<'a> {
+    fn fmt(&self, f: &mut Formatter) -> Result<(), fmt::Error> {
+        let indent = if f.alternate() {
+            Indent::enabled()
+        } else {
+            Indent::no_indent()
+        };
+        print(*self, f, indent)
+    }
+}
diff --git a/rust/capnp/struct_list.rs b/rust/capnp/struct_list.rs
new file mode 100644
index 000000000000..5c2775ddc1fd
--- /dev/null
+++ b/rust/capnp/struct_list.rs
@@ -0,0 +1,300 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of structs.
+
+use core::marker::PhantomData;
+
+use crate::introspect;
+use crate::private::layout::{
+    InlineComposite, ListBuilder, ListReader, PointerBuilder, PointerReader,
+};
+use crate::traits::{FromPointerBuilder, FromPointerReader, HasStructSize, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned<T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    marker: PhantomData<T>,
+}
+
+impl<T> introspect::Introspect for Owned<T>
+where
+    T: introspect::Introspect + crate::traits::OwnedStruct,
+{
+    fn introspect() -> introspect::Type {
+        introspect::Type::list_of(T::introspect())
+    }
+}
+
+impl<T> crate::traits::Owned for Owned<T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    type Reader<'a> = Reader<'a, T>;
+    type Builder<'a> = Builder<'a, T>;
+}
+
+pub struct Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    marker: PhantomData<T>,
+    reader: ListReader<'a>,
+}
+
+impl<'a, T> Clone for Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    fn clone(&self) -> Reader<'a, T> {
+        *self
+    }
+}
+impl<'a, T> Copy for Reader<'a, T> where T: crate::traits::OwnedStruct {}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a, T>, T::Reader<'a>> {
+        ListIter::new(self, self.len())
+    }
+}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    pub fn reborrow(&self) -> Reader<'_, T> {
+        Reader {
+            reader: self.reader,
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<'a, T> FromPointerReader<'a> for Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a, T>> {
+        Ok(Reader {
+            reader: reader.get_list(InlineComposite, default)?,
+            marker: PhantomData,
+        })
+    }
+}
+
+impl<'a, T> IndexMove<u32, T::Reader<'a>> for Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    fn index_move(&self, index: u32) -> T::Reader<'a> {
+        self.get(index)
+    }
+}
+
+impl<'a, T> Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> T::Reader<'a> {
+        assert!(index < self.len());
+        self.reader.get_struct_element(index).into()
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<T::Reader<'a>> {
+        if index < self.len() {
+            Some(self.reader.get_struct_element(index).into())
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> crate::traits::IntoInternalListReader<'a> for Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    marker: PhantomData<T>,
+    builder: ListBuilder<'a>,
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn into_reader(self) -> Reader<'a, T> {
+        Reader {
+            marker: PhantomData,
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    /// Sets the list element, with the following limitation based on the fact that structs in a
+    /// struct list are allocated inline: if the source struct is larger than the target struct
+    /// (as can happen if it was created with a newer version of the schema), then it will be
+    /// truncated, losing fields.
+    pub fn set_with_caveats<'b>(&mut self, index: u32, value: T::Reader<'b>) -> Result<()>
+    where
+        T::Reader<'b>: crate::traits::IntoInternalStructReader<'b>,
+    {
+        assert!(index < self.len());
+        use crate::traits::IntoInternalStructReader;
+        self.builder
+            .reborrow()
+            .get_struct_element(index)
+            .copy_content_from(&value.into_internal_struct_reader())
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    pub fn reborrow(&mut self) -> Builder<'_, T> {
+        Builder {
+            builder: self.builder.reborrow(),
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<'a, T> FromPointerBuilder<'a> for Builder<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a, T> {
+        Builder {
+            marker: PhantomData,
+            builder: builder.init_struct_list(size, T::Builder::STRUCT_SIZE),
+        }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a, T>> {
+        Ok(Builder {
+            marker: PhantomData,
+            builder: builder.get_struct_list(T::Builder::STRUCT_SIZE, default)?,
+        })
+    }
+}
+
+impl<'a, T> Builder<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    /// Gets the element at position `index`. Panics if `index` is greater than or
+    /// equal to `len()`.
+    pub fn get(self, index: u32) -> T::Builder<'a> {
+        assert!(index < self.len());
+        self.builder.get_struct_element(index).into()
+    }
+
+    /// Gets the element at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<T::Builder<'a>> {
+        if index < self.len() {
+            Some(self.builder.get_struct_element(index).into())
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a, T> crate::traits::SetPointerBuilder for Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a, T>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
+
+impl<'a, T> ::core::iter::IntoIterator for Reader<'a, T>
+where
+    T: crate::traits::OwnedStruct,
+{
+    type Item = T::Reader<'a>;
+    type IntoIter = ListIter<Reader<'a, T>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a, T: crate::traits::OwnedStruct> From<Reader<'a, T>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a, T>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader::new(
+            t.reader,
+            T::introspect(),
+        ))
+    }
+}
+
+impl<'a, T: crate::traits::OwnedStruct> From<Builder<'a, T>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a, T>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder::new(
+            t.builder,
+            T::introspect(),
+        ))
+    }
+}
diff --git a/rust/capnp/text.rs b/rust/capnp/text.rs
new file mode 100644
index 000000000000..fa2a72701444
--- /dev/null
+++ b/rust/capnp/text.rs
@@ -0,0 +1,294 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! UTF-8 encoded text.
+
+use core::str;
+
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned(());
+
+impl crate::traits::Owned for Owned {
+    type Reader<'a> = Reader<'a>;
+    type Builder<'a> = Builder<'a>;
+}
+
+impl crate::introspect::Introspect for Owned {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::TypeVariant::Text.into()
+    }
+}
+
+/// Wrapper around utf-8 encoded text.
+/// This is defined as a tuple struct to allow pattern matching
+/// on it via byte literals (for example `text::Reader(b"hello")`).
+#[derive(Copy, Clone, PartialEq)]
+pub struct Reader<'a>(pub &'a [u8]);
+
+impl<'a> core::cmp::PartialEq<&'a str> for Reader<'a> {
+    fn eq(&self, other: &&'a str) -> bool {
+        self.as_bytes() == other.as_bytes()
+    }
+}
+
+impl<'a> core::cmp::PartialEq<Reader<'a>> for &'a str {
+    fn eq(&self, other: &Reader<'a>) -> bool {
+        self.as_bytes() == other.as_bytes()
+    }
+}
+
+impl<'a> core::fmt::Debug for Reader<'a> {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        match self.to_str() {
+            Ok(s) => write!(f, "{:?}", s),
+            Err(_) => write!(f, "<invalid utf-8: {:?}>", self.as_bytes()),
+        }
+    }
+}
+
+impl<'a> From<&'a str> for Reader<'a> {
+    fn from(value: &'a str) -> Self {
+        Self(value.as_bytes())
+    }
+}
+
+impl<'a> From<&'a [u8]> for Reader<'a> {
+    fn from(value: &'a [u8]) -> Self {
+        Self(value)
+    }
+}
+
+impl<'a, const N: usize> From<&'a [u8; N]> for Reader<'a> {
+    fn from(value: &'a [u8; N]) -> Self {
+        Self(&value[..])
+    }
+}
+
+impl<'a> TryFrom<Reader<'a>> for &'a str {
+    type Error = core::str::Utf8Error;
+    fn try_from(value: Reader<'a>) -> core::result::Result<&'a str, core::str::Utf8Error> {
+        let Reader(v) = value;
+        str::from_utf8(v)
+    }
+}
+
+impl<'a> crate::traits::FromPointerReader<'a> for Reader<'a> {
+    fn get_from_pointer(
+        reader: &crate::private::layout::PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a>> {
+        reader.get_text(default)
+    }
+}
+
+impl<'a> Reader<'a> {
+    /// The string's length, in bytes.
+    pub fn len(&self) -> usize {
+        self.as_bytes().len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn as_bytes(self) -> &'a [u8] {
+        let Self(d) = self;
+        d
+    }
+
+    /// Converts to a `str`, returning a error if the data contains invalid utf-8.
+    pub fn to_str(self) -> core::result::Result<&'a str, core::str::Utf8Error> {
+        let Self(s) = self;
+        str::from_utf8(s)
+    }
+
+    #[cfg(feature = "alloc")]
+    /// Converts to a `String`, returning a error if the data contains invalid utf-8.
+    pub fn to_string(self) -> core::result::Result<alloc::string::String, core::str::Utf8Error> {
+        Ok(self.to_str()?.into())
+    }
+}
+
+pub struct Builder<'a> {
+    /// Does not include the trailing null byte.
+    bytes: &'a mut [u8],
+
+    /// Position at which `push_ascii()` and `push_str()` will write to.
+    pos: usize,
+}
+
+impl<'a> core::cmp::PartialEq for Builder<'a> {
+    fn eq(&self, other: &Self) -> bool {
+        self.bytes == other.bytes
+    }
+}
+
+impl<'a> core::cmp::PartialEq<&'a str> for Builder<'a> {
+    fn eq(&self, other: &&'a str) -> bool {
+        self.bytes == other.as_bytes()
+    }
+}
+
+impl<'a> core::cmp::PartialEq<Builder<'a>> for &'a str {
+    fn eq(&self, other: &Builder<'a>) -> bool {
+        self.as_bytes() == other.bytes
+    }
+}
+
+impl<'a> Builder<'a> {
+    pub fn new(bytes: &mut [u8]) -> Builder<'_> {
+        Builder { bytes, pos: 0 }
+    }
+
+    pub fn with_pos(bytes: &mut [u8], pos: usize) -> Builder<'_> {
+        Builder { bytes, pos }
+    }
+
+    /// The string's length, in bytes.
+    pub fn len(&self) -> usize {
+        self.bytes.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn as_bytes(self) -> &'a [u8] {
+        self.bytes
+    }
+
+    /// Converts to a `str`, returning a error if the data contains invalid utf-8.
+    pub fn to_str(self) -> core::result::Result<&'a str, core::str::Utf8Error> {
+        str::from_utf8(self.bytes)
+    }
+
+    #[cfg(feature = "alloc")]
+    /// Converts to a `String`, returning a error if the data contains invalid utf-8.
+    pub fn to_string(self) -> core::result::Result<alloc::string::String, core::str::Utf8Error> {
+        Ok(self.to_str()?.into())
+    }
+
+    pub fn as_bytes_mut(self) -> &'a mut [u8] {
+        &mut self.bytes[..]
+    }
+
+    /// Writes a single ascii character at position `pos` and increments `pos`.
+    pub fn push_ascii(&mut self, ascii: u8) {
+        assert!(ascii < 128);
+        self.bytes[self.pos] = ascii;
+        self.pos += 1;
+    }
+
+    /// Writes a string at position `pos` and increases `pos` a corresponding amount.
+    pub fn push_str(&mut self, string: &str) {
+        let bytes = string.as_bytes();
+        self.bytes[self.pos..(self.pos + bytes.len())].copy_from_slice(bytes);
+        self.pos += bytes.len();
+    }
+
+    /// Zeroes all data and resets `pos`.
+    pub fn clear(&mut self) {
+        for b in &mut self.bytes[..self.pos] {
+            *b = 0;
+        }
+        self.pos = 0;
+    }
+
+    pub fn reborrow(&mut self) -> Builder<'_> {
+        Builder {
+            bytes: self.bytes,
+            pos: self.pos,
+        }
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader(self.bytes)
+    }
+
+    pub fn reborrow_as_reader(&self) -> Reader<'_> {
+        Reader(self.bytes)
+    }
+}
+
+impl<'a> core::fmt::Debug for Builder<'a> {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        match self.reborrow_as_reader().to_str() {
+            Ok(s) => write!(f, "{:?}", s),
+            Err(_) => write!(f, "<invalid utf-8>"),
+        }
+    }
+}
+
+impl<'a> crate::traits::FromPointerBuilder<'a> for Builder<'a> {
+    fn init_pointer(builder: crate::private::layout::PointerBuilder<'a>, size: u32) -> Builder<'a> {
+        builder.init_text(size)
+    }
+    fn get_from_pointer(
+        builder: crate::private::layout::PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a>> {
+        builder.get_text(default)
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a>,
+        _canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_text(value);
+        Ok(())
+    }
+}
+
+// Extra impl to make any_pointer::Builder::set_as() and similar methods work
+// more smoothly.
+impl<'a> crate::traits::SetPointerBuilder for &'a str {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: &'a str,
+        _canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_text(value.into());
+        Ok(())
+    }
+}
+
+impl<'a> From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::Text(t)
+    }
+}
+
+impl<'a> From<&'a str> for crate::dynamic_value::Reader<'a> {
+    fn from(t: &'a str) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::Text(t.into())
+    }
+}
+
+impl<'a> From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::Text(t)
+    }
+}
diff --git a/rust/capnp/text_list.rs b/rust/capnp/text_list.rs
new file mode 100644
index 000000000000..72cbd2647ba9
--- /dev/null
+++ b/rust/capnp/text_list.rs
@@ -0,0 +1,216 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+//! List of strings containing UTF-8 encoded text.
+
+use crate::private::layout::{ListBuilder, ListReader, Pointer, PointerBuilder, PointerReader};
+use crate::traits::{FromPointerBuilder, FromPointerReader, IndexMove, ListIter};
+use crate::Result;
+
+#[derive(Copy, Clone)]
+pub struct Owned;
+
+impl crate::traits::Owned for Owned {
+    type Reader<'a> = Reader<'a>;
+    type Builder<'a> = Builder<'a>;
+}
+
+impl crate::introspect::Introspect for Owned {
+    fn introspect() -> crate::introspect::Type {
+        crate::introspect::Type::list_of(crate::introspect::TypeVariant::Text.into())
+    }
+}
+
+#[derive(Clone, Copy)]
+pub struct Reader<'a> {
+    reader: ListReader<'a>,
+}
+
+impl<'a> Reader<'a> {
+    pub fn new<'b>(reader: ListReader<'b>) -> Reader<'b> {
+        Reader::<'b> { reader }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.reader.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn iter(self) -> ListIter<Reader<'a>, Result<crate::text::Reader<'a>>> {
+        let l = self.len();
+        ListIter::new(self, l)
+    }
+}
+
+impl<'a> FromPointerReader<'a> for Reader<'a> {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Reader<'a>> {
+        Ok(Reader {
+            reader: reader.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a> IndexMove<u32, Result<crate::text::Reader<'a>>> for Reader<'a> {
+    fn index_move(&self, index: u32) -> Result<crate::text::Reader<'a>> {
+        self.get(index)
+    }
+}
+
+impl<'a> Reader<'a> {
+    /// Gets the `text::Reader` at position `index`. Panics if `index` is
+    /// greater than or equal to `len()`.
+    pub fn get(self, index: u32) -> Result<crate::text::Reader<'a>> {
+        assert!(index < self.len());
+        self.reader.get_pointer_element(index).get_text(None)
+    }
+
+    /// Gets the `text::Reader` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<crate::text::Reader<'a>>> {
+        if index < self.len() {
+            Some(self.reader.get_pointer_element(index).get_text(None))
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a> crate::traits::IntoInternalListReader<'a> for Reader<'a> {
+    fn into_internal_list_reader(self) -> ListReader<'a> {
+        self.reader
+    }
+}
+
+pub struct Builder<'a> {
+    builder: ListBuilder<'a>,
+}
+
+impl<'a> Builder<'a> {
+    pub fn new(builder: ListBuilder<'a>) -> Builder<'a> {
+        Builder { builder }
+    }
+
+    pub fn len(&self) -> u32 {
+        self.builder.len()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.len() == 0
+    }
+
+    pub fn set(&mut self, index: u32, value: crate::text::Reader) {
+        assert!(index < self.len());
+        self.builder
+            .reborrow()
+            .get_pointer_element(index)
+            .set_text(value);
+    }
+
+    pub fn into_reader(self) -> Reader<'a> {
+        Reader {
+            reader: self.builder.into_reader(),
+        }
+    }
+
+    pub fn reborrow<'b>(&'b mut self) -> Builder<'b> {
+        Builder::<'b> {
+            builder: self.builder.reborrow(),
+        }
+    }
+}
+
+impl<'a> FromPointerBuilder<'a> for Builder<'a> {
+    fn init_pointer(builder: PointerBuilder<'a>, size: u32) -> Builder<'a> {
+        Builder {
+            builder: builder.init_list(Pointer, size),
+        }
+    }
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Builder<'a>> {
+        Ok(Builder {
+            builder: builder.get_list(Pointer, default)?,
+        })
+    }
+}
+
+impl<'a> Builder<'a> {
+    /// Gets the `text::Builder` at position `index`. Panics if `index` is
+    /// greater than or equal to `len()`.
+    pub fn get(self, index: u32) -> Result<crate::text::Builder<'a>> {
+        assert!(index < self.len());
+        self.builder.get_pointer_element(index).get_text(None)
+    }
+
+    /// Gets the `text::Builder` at position `index`. Returns `None` if `index`
+    /// is greater than or equal to `len()`.
+    pub fn try_get(self, index: u32) -> Option<Result<crate::text::Builder<'a>>> {
+        if index < self.len() {
+            Some(self.builder.get_pointer_element(index).get_text(None))
+        } else {
+            None
+        }
+    }
+}
+
+impl<'a> crate::traits::SetPointerBuilder for Reader<'a> {
+    fn set_pointer_builder<'b>(
+        mut pointer: crate::private::layout::PointerBuilder<'b>,
+        value: Reader<'a>,
+        canonicalize: bool,
+    ) -> Result<()> {
+        pointer.set_list(&value.reader, canonicalize)
+    }
+}
+
+impl<'a> ::core::iter::IntoIterator for Reader<'a> {
+    type Item = Result<crate::text::Reader<'a>>;
+    type IntoIter = ListIter<Reader<'a>, Self::Item>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl<'a> From<Reader<'a>> for crate::dynamic_value::Reader<'a> {
+    fn from(t: Reader<'a>) -> crate::dynamic_value::Reader<'a> {
+        crate::dynamic_value::Reader::List(crate::dynamic_list::Reader {
+            reader: t.reader,
+            element_type: crate::introspect::TypeVariant::Text.into(),
+        })
+    }
+}
+
+impl<'a> From<Builder<'a>> for crate::dynamic_value::Builder<'a> {
+    fn from(t: Builder<'a>) -> crate::dynamic_value::Builder<'a> {
+        crate::dynamic_value::Builder::List(crate::dynamic_list::Builder {
+            builder: t.builder,
+            element_type: crate::introspect::TypeVariant::Text.into(),
+        })
+    }
+}
diff --git a/rust/capnp/traits.rs b/rust/capnp/traits.rs
new file mode 100644
index 000000000000..39e050ab4abf
--- /dev/null
+++ b/rust/capnp/traits.rs
@@ -0,0 +1,233 @@
+// Copyright (c) 2013-2015 Sandstorm Development Group, Inc. and contributors
+// Licensed under the MIT License:
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+use crate::private::layout::CapTable;
+use crate::private::layout::{
+    ListReader, PointerBuilder, PointerReader, StructBuilder, StructReader, StructSize,
+};
+use crate::Result;
+
+use core::marker::PhantomData;
+
+pub trait HasStructSize {
+    const STRUCT_SIZE: StructSize;
+}
+
+/// Trait for all types that can be converted to a low-level `StructReader`.
+pub trait IntoInternalStructReader<'a> {
+    fn into_internal_struct_reader(self) -> StructReader<'a>;
+}
+
+/// Trait for all types that can be converted to a low-level `ListReader`.
+pub trait IntoInternalListReader<'a> {
+    fn into_internal_list_reader(self) -> ListReader<'a>;
+}
+
+pub trait FromPointerReader<'a>: Sized {
+    fn get_from_pointer(
+        reader: &PointerReader<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Self>;
+}
+
+/// A trait to encode relationships between readers and builders.
+///
+/// If `Foo` is a Cap'n Proto struct and `Bar` is a Rust-native struct, then
+/// `foo::Reader<'a>` is to `foo::Owned` as `&'a Bar` is to `Bar`, and
+/// `foo::Builder<'a>` is to `foo::Owned` as `&'a mut Bar` is to `Bar`.
+/// The relationship is formalized by an `impl capnp::traits::Owned for foo::Owned`.
+/// Because Cap'n Proto struct layout differs from Rust struct layout, a `foo::Owned` value
+/// cannot be used for anything interesting on its own; the `foo::Owned` type is useful
+/// nonetheless as a type parameter, e.g. for a generic container that owns a Cap'n Proto
+/// message of type `T: capnp::traits::Owned`.
+pub trait Owned: crate::introspect::Introspect {
+    type Reader<'a>: FromPointerReader<'a> + SetPointerBuilder;
+    type Builder<'a>: FromPointerBuilder<'a>;
+}
+
+pub trait OwnedStruct: crate::introspect::Introspect {
+    type Reader<'a>: From<StructReader<'a>> + SetPointerBuilder + IntoInternalStructReader<'a>;
+    type Builder<'a>: From<StructBuilder<'a>> + HasStructSize;
+}
+
+pub trait Pipelined {
+    type Pipeline;
+}
+
+pub trait FromPointerBuilder<'a>: Sized {
+    fn init_pointer(builder: PointerBuilder<'a>, length: u32) -> Self;
+    fn get_from_pointer(
+        builder: PointerBuilder<'a>,
+        default: Option<&'a [crate::Word]>,
+    ) -> Result<Self>;
+}
+
+pub trait SetPointerBuilder {
+    fn set_pointer_builder(
+        builder: PointerBuilder<'_>,
+        from: Self,
+        canonicalize: bool,
+    ) -> Result<()>;
+}
+
+pub trait Imbue<'a> {
+    fn imbue(&mut self, caps: &'a CapTable);
+}
+
+pub trait ImbueMut<'a> {
+    fn imbue_mut(&mut self, caps: &'a mut CapTable);
+}
+
+pub trait HasTypeId {
+    const TYPE_ID: u64;
+}
+
+pub trait IndexMove<I, T> {
+    fn index_move(&self, index: I) -> T;
+}
+
+pub struct ListIter<T, U> {
+    marker: PhantomData<U>,
+    list: T,
+    index: u32,
+    size: u32,
+}
+
+impl<T, U> ListIter<T, U> {
+    pub fn new(list: T, size: u32) -> Self {
+        Self {
+            list,
+            index: 0,
+            size,
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<U, T: IndexMove<u32, U>> ::core::iter::Iterator for ListIter<T, U> {
+    type Item = U;
+    fn next(&mut self) -> ::core::option::Option<U> {
+        if self.index < self.size {
+            let result = self.list.index_move(self.index);
+            self.index += 1;
+            Some(result)
+        } else {
+            None
+        }
+    }
+
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        (self.size as usize, Some(self.size as usize))
+    }
+
+    fn nth(&mut self, p: usize) -> Option<U> {
+        if self.index + (p as u32) < self.size {
+            self.index += p as u32;
+            let result = self.list.index_move(self.index);
+            self.index += 1;
+            Some(result)
+        } else {
+            self.index = self.size;
+            None
+        }
+    }
+}
+
+impl<U, T: IndexMove<u32, U>> ::core::iter::ExactSizeIterator for ListIter<T, U> {
+    fn len(&self) -> usize {
+        self.size as usize
+    }
+}
+
+impl<U, T: IndexMove<u32, U>> ::core::iter::DoubleEndedIterator for ListIter<T, U> {
+    fn next_back(&mut self) -> ::core::option::Option<U> {
+        if self.size > self.index {
+            self.size -= 1;
+            Some(self.list.index_move(self.size))
+        } else {
+            None
+        }
+    }
+}
+
+pub struct ShortListIter<T, U> {
+    marker: PhantomData<U>,
+    list: T,
+    index: u16,
+    size: u16,
+}
+
+impl<T, U> ShortListIter<T, U> {
+    pub fn new(list: T, size: u16) -> Self {
+        Self {
+            list,
+            index: 0,
+            size,
+            marker: PhantomData,
+        }
+    }
+}
+
+impl<U, T: IndexMove<u16, U>> ::core::iter::Iterator for ShortListIter<T, U> {
+    type Item = U;
+    fn next(&mut self) -> ::core::option::Option<U> {
+        if self.index < self.size {
+            let result = self.list.index_move(self.index);
+            self.index += 1;
+            Some(result)
+        } else {
+            None
+        }
+    }
+
+    fn size_hint(&self) -> (usize, Option<usize>) {
+        (self.size as usize, Some(self.size as usize))
+    }
+
+    fn nth(&mut self, p: usize) -> Option<U> {
+        if self.index + (p as u16) < self.size {
+            self.index += p as u16;
+            let result = self.list.index_move(self.index);
+            self.index += 1;
+            Some(result)
+        } else {
+            self.index = self.size;
+            None
+        }
+    }
+}
+
+impl<U, T: IndexMove<u16, U>> ::core::iter::ExactSizeIterator for ShortListIter<T, U> {
+    fn len(&self) -> usize {
+        self.size as usize
+    }
+}
+
+impl<U, T: IndexMove<u16, U>> ::core::iter::DoubleEndedIterator for ShortListIter<T, U> {
+    fn next_back(&mut self) -> ::core::option::Option<U> {
+        if self.size > self.index {
+            self.size -= 1;
+            Some(self.list.index_move(self.size))
+        } else {
+            None
+        }
+    }
+}
-- 
2.34.1


